<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker容器创建过程解析</title>
    <url>/2022/07/31/Docker%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="一、docker-run命令的背后发生了什么？"><a href="#一、docker-run命令的背后发生了什么？" class="headerlink" title="一、docker run命令的背后发生了什么？"></a>一、docker run命令的背后发生了什么？</h2><p>平时在创建docker容器的时候会使用<code>docker run</code>命令，并给定一些参数，那么在执行<code>docker run</code>时docker在背后到底为我们做了哪些事情呢？</p>
<h3 id="1、docker常用命令执行流程"><a href="#1、docker常用命令执行流程" class="headerlink" title="1、docker常用命令执行流程"></a>1、docker常用命令执行流程</h3><p>先来看官方给出的一张容器创建过程图：</p>
<img src="/images/docker创建容器流程图-官方.png" alt="img" style="zoom: 50%;" />

<p>这张图描述了<code>docker build</code>、<code>docker pull</code>和<code>docker run</code>三个命令在Client、Docker daemon和Regitry之间的交互流程。接下来我们着重分析<code>dockr run</code>命令是如何执行的。</p>
<span id="more"></span>

<h3 id="2、docker-run命令执行流程"><a href="#2、docker-run命令执行流程" class="headerlink" title="2、docker run命令执行流程"></a>2、docker run命令执行流程</h3><p>先假设我们要创建一个ubuntu容器，那么首先会执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -i -t ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p>执行上述命令后，docker会为我们启动一个ubuntu容器，那么docker在后台都执行了哪些动作呢？</p>
<p>docker创建容器的大致过程可以用下面这幅图来描述：</p>
<img src="/images/docker_run大致流程.png" alt="docker_run大致流程" style="zoom: 33%;" />

<p>首先你的操作系统上得要有一个docker daemon后台进程在运行，然后当执行上面这行命令时：</p>
<p>step1  docker client(即：docker终端命令行)会向docker daemon发送请求，启动一个容器；</p>
<p>step2  docker daemon会向host os(一般为linux)请求创建容器；</p>
<p>step3  linux会创建一个空的容器（可以简单理解为：一个未安装操作系统的裸机，只有虚拟出来的CPU、内存等硬件资源）</p>
<p>step4  docker daemon请检查本机是否存在docker镜像文件（可以简单理解为操作系统安装光盘），如果有，则加载到容器中（即：光盘插入裸机，准备安装操作系统）</p>
<p>step5  将镜像文件加载到容器中（即：裸机上安装好了操作系统，不再是裸机状态）</p>
<p>在docker完成上述步骤后，我们就得到了一个ubuntu”虚拟机”，然后就可以执行各种操作了。</p>
<p>如果在本地没有镜像文件，那么docker回到镜像仓库下载指定得镜像，下载到本地后，再进行装载到容器的操作。这种情况下创建容器的完整流程如下图所示：</p>
<img src="/images/docker拉取镜像创建容器的大致流程.png" alt="img" style="zoom:33%;" />



<p>经过上面的分析，我们已经知道了docker创建的大致流程，但是有一些细节我们目前还是不知道的。步骤1中client给docker daemon发送了什么请求？是一个请求还是多个请求？步骤2和步骤3可以看作是一个大操作——在操作系统中（一般为Linux）创建容器。创建容器肯定是要分配资源的，那么docker是怎么向操作系统申请资源的？又申请了哪些资源？步骤4比较好理解，就是在本地或远端寻找镜像文件，但是步骤5又是怎么把镜像文件加载到新创建的空容器中的呢？</p>
<p>一番搜索后并没有得到满意的答案，为了清楚的了解上述问题，我们接下来将探索docker源码相关部分。</p>
<h2 id="二、docker内部是怎么完成容器创建步骤的？"><a href="#二、docker内部是怎么完成容器创建步骤的？" class="headerlink" title="二、docker内部是怎么完成容器创建步骤的？"></a>二、docker内部是怎么完成容器创建步骤的？</h2><p>上一节已经梳理清楚了docker创建容器的流程，这一节我们就来探索一下docker内部是怎么完成容器创建每一个步骤的？</p>
<h3 id="1、创建容器时，client向docker-daemon发送了什么请求？"><a href="#1、创建容器时，client向docker-daemon发送了什么请求？" class="headerlink" title="1、创建容器时，client向docker daemon发送了什么请求？"></a>1、创建容器时，client向docker daemon发送了什么请求？</h3><p>首先看一下在docker client模块中处理<code>docker run</code>命令的函数代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// integration/internal/container/container.go文件</span></span><br><span class="line"><span class="comment">// Run creates and start a container with the specified options</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(ctx context.Context, t *testing.T, client client.APIClient, ops ...<span class="keyword">func</span>(*TestContainerConfig)</span></span>) <span class="type">string</span> &#123;</span><br><span class="line">	t.Helper()</span><br><span class="line">	id := Create(ctx, t, client, ops...) <span class="comment">// step1 创建容器</span></span><br><span class="line"></span><br><span class="line">	err := client.ContainerStart(ctx, id, types.ContainerStartOptions&#123;&#125;) <span class="comment">// step2 开启容器</span></span><br><span class="line">	assert.NilError(t, err)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1、<a href="https://www.dockone.io/article/1239">run执行流详解（以volume，network和libcontainer为线索）</a></p>
<p>2、<a href="https://blog.csdn.net/qq_33339479/article/details/122134279">runc原理概述</a></p>
]]></content>
      <categories>
        <category>编程 - docker</category>
      </categories>
      <tags>
        <tag>docker容器创建</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker源码整体分析</title>
    <url>/2022/07/31/Docker%E6%BA%90%E7%A0%81%E6%95%B4%E4%BD%93%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="一、Docker总体架构"><a href="#一、Docker总体架构" class="headerlink" title="一、Docker总体架构"></a>一、Docker总体架构</h2><p>Docker对于我们使用者来说，就是一个C&#x2F;S模式的架构，但是Docker后端是一个非常松耦合的架构，每个模块都有它自己的用处，这些模块组合起来共同支撑着Docker的运行，而且这些模块可以很容易的被其他软件嵌入使用。</p>
<p>先来看一张Docker架构图：</p>
<img src="/images/Docker总体架构图.jpg" alt="img" style="zoom: 33%;" />

<span id="more"></span>

<p>Docker Client就是我们使用的命令行工具<code>docker</code>，它与Docker Daemon之间使用Http进行联系，当我们使用<code>docker</code>下发容器相关的命令时，Docker Client就会给Docker Daemon发送Post请求。</p>
<p>Docker Daemon以后台进程dockerd驻留在系统后台，它负责接收Docker Client传递过来的请求，然后封装为一个Job，在代码里面实际上一个<code>Task</code>，Task中会调度下层的网络、镜像、命令空间、进程创建等模块。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mucao@mucao-vm:~$ ps aux | grep docker</span><br><span class="line">root        1089  0.8  3.9 1456804 79428 ?       Ssl  12:31   0:01 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure>

<p>在Driver模块就是具体负责管理容器资源和容器生命周期，我理解它是一个小的调度系统，在里面又分为负责镜像管理的graphdriver、负责网络的networkdriver和负责进程创建的execdriver。</p>
<p>最后真正负责容器运行和生命周期的是libcontainer，它里面包含cgroups、namespace、虚拟网卡等，负责和主机Linux系统打交道。</p>
<h2 id="二、Docker各模块源码介绍"><a href="#二、Docker各模块源码介绍" class="headerlink" title="二、Docker各模块源码介绍"></a>二、Docker各模块源码介绍</h2><p>目前Docker各个模块都是在自己独立的源码仓库，并且在Docker运行时各个模块也是分块，从这个角度讲Docker不再是一个单独的软件，而是一个虚拟化系统。</p>
<p>在Docker架构图上标注出来了模块与源码仓库对应的关系，如下图所示：</p>
<p><img src="/images/Docker%E6%A8%A1%E5%9D%97%E4%B8%8E%E6%BA%90%E7%A0%81%E4%BB%93%E5%BA%93%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.jpg" alt="docker模块与源码仓库对应关系"></p>
<p>下面我们逐一来介绍：</p>
<h3 id="1、cli"><a href="#1、cli" class="headerlink" title="1、cli"></a>1、cli</h3><p>docker client在cli仓库，地址为<a href="https://github.com/docker/cli%EF%BC%8Ccli%E4%B8%BB%E8%A6%81%E4%BE%9D%E8%B5%96%E4%BA%8E%60cobra%60%E5%AE%8C%E6%88%90%E4%B8%BB%E5%91%BD%E4%BB%A4%E5%92%8C%E5%AD%90%E5%91%BD%E4%BB%A4%E7%9A%84%E6%9E%84%E5%BB%BA%E3%80%82">https://github.com/docker/cli，cli主要依赖于`cobra`完成主命令和子命令的构建。</a></p>
<p>下面这个是<code>docker</code>命令的入口函数代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cmd/docker/docker.go文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	dockerCli, err := command.NewDockerCli()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Fprintln(os.Stderr, err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	logrus.SetOutput(dockerCli.Err())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := runDocker(dockerCli); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> sterr, ok := err.(cli.StatusError); ok &#123;</span><br><span class="line">			<span class="keyword">if</span> sterr.Status != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">				fmt.Fprintln(dockerCli.Err(), sterr.Status)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// StatusError should only be used for errors, and all errors should</span></span><br><span class="line">			<span class="comment">// have a non-zero exit status, so never exit with 0</span></span><br><span class="line">			<span class="keyword">if</span> sterr.StatusCode == <span class="number">0</span> &#123;</span><br><span class="line">				os.Exit(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			os.Exit(sterr.StatusCode)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Fprintln(dockerCli.Err(), err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">...... 省略其他</span><br></pre></td></tr></table></figure>

<p>重点在<code>rundocker</code>函数:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cmd/docker/docker.go文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runDocker</span><span class="params">(dockerCli *command.DockerCli)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	tcmd := newDockerCommand(dockerCli)</span><br><span class="line">	</span><br><span class="line">    ...... <span class="comment">// 省略</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// We&#x27;ve parsed global args already, so reset args to those</span></span><br><span class="line">	<span class="comment">// which remain.</span></span><br><span class="line">	cmd.SetArgs(args)</span><br><span class="line">	<span class="keyword">return</span> cmd.Execute()</span><br><span class="line">&#125;</span><br><span class="line">...... 省略其他</span><br></pre></td></tr></table></figure>

<p>接下来我们看看newDockerCommand函数中做了什么事情：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cmd/docker/docker.go文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newDockerCommand</span><span class="params">(dockerCli *command.DockerCli)</span></span> *cli.TopLevelCommand &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		opts    *cliflags.ClientOptions</span><br><span class="line">		flags   *pflag.FlagSet</span><br><span class="line">		helpCmd *cobra.Command</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	cmd := &amp;cobra.Command&#123;</span><br><span class="line">		...... <span class="comment">// 省略</span></span><br><span class="line">	&#125;</span><br><span class="line">	opts, flags, helpCmd = cli.SetupRootCommand(cmd)</span><br><span class="line">	flags.BoolP(<span class="string">&quot;version&quot;</span>, <span class="string">&quot;v&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;Print version information and quit&quot;</span>)</span><br><span class="line"></span><br><span class="line">	setFlagErrorFunc(dockerCli, cmd)</span><br><span class="line"></span><br><span class="line">	setupHelpCommand(dockerCli, cmd, helpCmd)</span><br><span class="line">	setHelpFunc(dockerCli, cmd)</span><br><span class="line"></span><br><span class="line">	cmd.SetOut(dockerCli.Out())</span><br><span class="line">	commands.AddCommands(cmd, dockerCli)</span><br><span class="line"></span><br><span class="line">	cli.DisableFlagsInUseLine(cmd)</span><br><span class="line">	setValidateArgs(dockerCli, cmd)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// flags must be the top-level command flags, not cmd.Flags()</span></span><br><span class="line">	<span class="keyword">return</span> cli.NewTopLevelCommand(cmd, dockerCli, opts, flags)</span><br><span class="line">&#125;</span><br><span class="line">...... 省略其他</span><br></pre></td></tr></table></figure>

<p>在这里面主要干了两件事情，一是创建cobra.Command结构体，而是注册子命令，这里面的子命令就包括<code>docker run</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">main()</span><br><span class="line">|--&gt; command.NewDockerCli()</span><br><span class="line">|--&gt; runDocker(dockerCli)</span><br><span class="line">     |--&gt; newDockerCommand(dockerCli)</span><br><span class="line">     	  |--&gt; cmd := &amp;cobra.Command&#123;...&#125;</span><br><span class="line">          |--&gt; commands.AddCommands(cmd, dockerCli)</span><br><span class="line">          |    |--&gt; 注册其他命令         </span><br><span class="line">          |    |--&gt; container.NewRunCommand(dockerCli)</span><br><span class="line">          |        |--&gt; runRun(dockerCli, cmd.Flags(), &amp;opts, copts) <span class="comment">// 实际执行该函数</span></span><br><span class="line">          |             |--&gt; runContainer(...)</span><br><span class="line">          |                  |--&gt; 向daemon发送post /containers/create</span><br><span class="line">          |                  |--&gt; 向daemon发送post /containers/&#123;id&#125;/start</span><br><span class="line">          |--&gt; tcmd.Initialize()</span><br><span class="line">          |--&gt; cmd.Execute()</span><br><span class="line">      </span><br></pre></td></tr></table></figure>



<h3 id="2、moby"><a href="#2、moby" class="headerlink" title="2、moby"></a>2、moby</h3><p>moby中主要实现了接受请求、创建任务，然后和containerd进行交互，是docker面向用户层面的api封装。地址为<a href="https://github.com/moby/moby">https://github.com/moby/moby</a></p>
<p><img src="/images/docker_daemon.jpg" alt="img"></p>
<p>moby中会启动一个http server，然后注册各种路由表。</p>
<h3 id="3、containerd"><a href="#3、containerd" class="headerlink" title="3、containerd"></a>3、containerd</h3><p>containerd在整个Docker中占有非常重要的地位，我理解它是一个调度器作用的存在，地址为<a href="https://github.com/containerd/containerd%E3%80%82%E4%B8%8B%E9%9D%A2%E6%88%91%E4%BB%AC%E7%9C%8B%E4%B8%80%E5%BC%A0%E5%AE%98%E7%BD%91%E7%BB%99%E5%87%BA%E7%9A%84containerd%E7%9A%84%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E5%9B%BE%EF%BC%9A">https://github.com/containerd/containerd。下面我们看一张官网给出的containerd的整体结构图：</a></p>
<p><img src="/images/containerd%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="containerd architecture diagram"></p>
<p><strong>containerd</strong>可用作 Linux 和 Windows 的守护进程。它管理其主机系统的完整容器生命周期，从图像传输和存储到容器执行和监督，再到低级存储到网络附件等等。</p>
<p>containerd中有个重要的结构<code>Task</code>，这个结构内嵌了<code>Proess</code>，也就是说可以当进程一样使用。在containerd这一层看的出来已经逐渐的和操作系统的进程融合了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.go 文件</span></span><br><span class="line"><span class="comment">// Task is the executable object within containerd</span></span><br><span class="line"><span class="keyword">type</span> Task <span class="keyword">interface</span> &#123;</span><br><span class="line">	Process</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pause suspends the execution of the task</span></span><br><span class="line">	Pause(context.Context) <span class="type">error</span></span><br><span class="line">	<span class="comment">// Resume the execution of the task</span></span><br><span class="line">	Resume(context.Context) <span class="type">error</span></span><br><span class="line">	<span class="comment">// Exec creates a new process inside the task</span></span><br><span class="line">	Exec(context.Context, <span class="type">string</span>, *specs.Process, cio.Creator) (Process, <span class="type">error</span>)</span><br><span class="line">	<span class="comment">// Pids returns a list of system specific process ids inside the task</span></span><br><span class="line">	Pids(context.Context) ([]ProcessInfo, <span class="type">error</span>)</span><br><span class="line">	<span class="comment">// Checkpoint serializes the runtime and memory information of a task into an</span></span><br><span class="line">	<span class="comment">// OCI Index that can be pushed and pulled from a remote resource.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Additional software like CRIU maybe required to checkpoint and restore tasks</span></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> Checkpoint supports to dump task information to a directory, in this way,</span></span><br><span class="line">	<span class="comment">// an empty OCI Index will be returned.</span></span><br><span class="line">	Checkpoint(context.Context, ...CheckpointTaskOpts) (Image, <span class="type">error</span>)</span><br><span class="line">	<span class="comment">// Update modifies executing tasks with updated settings</span></span><br><span class="line">	Update(context.Context, ...UpdateTaskOpts) <span class="type">error</span></span><br><span class="line">	<span class="comment">// LoadProcess loads a previously created exec&#x27;d process</span></span><br><span class="line">	LoadProcess(context.Context, <span class="type">string</span>, cio.Attach) (Process, <span class="type">error</span>)</span><br><span class="line">	<span class="comment">// Metrics returns task metrics for runtime specific metrics</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// The metric types are generic to containerd and change depending on the runtime</span></span><br><span class="line">	<span class="comment">// For the built in Linux runtime, github.com/containerd/cgroups.Metrics</span></span><br><span class="line">	<span class="comment">// are returned in protobuf format</span></span><br><span class="line">	Metrics(context.Context) (*types.Metric, <span class="type">error</span>)</span><br><span class="line">	<span class="comment">// Spec returns the current OCI specification for the task</span></span><br><span class="line">	Spec(context.Context) (*oci.Spec, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Process接口就代表着Linux操作系统中的进程，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// process.go 文件</span></span><br><span class="line"><span class="comment">// Process represents a system process</span></span><br><span class="line"><span class="keyword">type</span> </span><br><span class="line">	Wait(context.Context) (&lt;-<span class="keyword">chan</span> ExitStatus, <span class="type">error</span>)</span><br><span class="line">	<span class="comment">// CloseIO allows various pipes to be closed on the process</span></span><br><span class="line">	CloseIO(context.Context, ...IOCloserOpts) <span class="type">error</span></span><br><span class="line">	<span class="comment">// Resize changes the width and height of the process&#x27;s terminal</span></span><br><span class="line">	Resize(ctx context.Context, w, h <span class="type">uint32</span>) <span class="type">error</span></span><br><span class="line">	<span class="comment">// IO returns the io set for the process</span></span><br><span class="line">	IO() cio.IO</span><br><span class="line">	<span class="comment">// Status returns the executing status of the process</span></span><br><span class="line">	Status(context.Context) (Status, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、runc"><a href="#4、runc" class="headerlink" title="4、runc"></a>4、runc</h3><p>runc负责容器生命周期的管理，现在已经是作为一个独立的命令行工具发布。地址为<a href="https://github.com/opencontainers/runc%E3%80%82%E5%AE%83%E6%98%AFOCI(%E5%BC%80%E5%8F%91%E5%AE%B9%E5%99%A8%E6%A0%87%E5%87%86)%E7%9A%84%E5%AE%9E%E7%8E%B0%E3%80%82">https://github.com/opencontainers/runc。它是OCI(开发容器标准)的实现。</a></p>
<p>它的执行流程大致如下图：</p>
<p><img src="/images/runc_init1.jpg" alt="runc_init1"></p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>我们再来总体看一下这些模块源码之间的关系。</p>
<p><img src="/images/docker%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB.jpeg" alt="docker模块源码之间关系"></p>
<p>各个模块的执行流程关系如下所示：</p>
<p><img src="/images/docker%E5%90%84%E6%A8%A1%E5%9D%97%E6%89%A7%E8%A1%8C%E5%85%B3%E7%B3%BB.png" alt="这里写图片描述"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1、<a href="https://containerd.io/">containerd官网</a></p>
<p>2、<a href="https://www.infoq.cn/news/docker-source-code-analysis-part1">Docker 源码分析（一）：Docker 架构</a></p>
]]></content>
      <categories>
        <category>编程 - docker</category>
      </categories>
      <tags>
        <tag>docker源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Java远程调试各参数说明</title>
    <url>/2022/08/17/Java%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E5%90%84%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>首先，JAVA自身支持调试功能，并提供了一个简单的调试工具JDB，类似于功能强大的GDB，JDB也是一个字符界面的调试环境，并支持设置断点，支持线程级的调试。</p>
<p>JAVA的调试方法如下：</p>
<h2 id="1、首先设置JVM参数，使之工作在DEBUG模式下，加入参数："><a href="#1、首先设置JVM参数，使之工作在DEBUG模式下，加入参数：" class="headerlink" title="1、首先设置JVM参数，使之工作在DEBUG模式下，加入参数："></a>1、首先设置JVM参数，使之工作在DEBUG模式下，加入参数：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=5432,<span class="built_in">suspend</span>=n,onthrow=java.io.IOException,launch=/sbin/echo</span><br></pre></td></tr></table></figure>

<p>其中，<code>-Xdebug</code>是通知JVM工作在DEBUG模式下，<code>-Xrunjdwp</code>是通知JVM使用(java debug wire protocol)来运行调试环境。该参数同时了一系列的调试选项：</p>
<ul>
<li><code>transport</code>指定了调试数据的传送方式，</li>
<li><code>dt_socket</code>是指用SOCKET模式，另有<code>dt_shmem</code>指用共享内存方式，其中，dt_shmem只适用于Windows平台。</li>
<li><code>server</code>参数是指是否支持在server模式的VM中.</li>
<li><code>onthrow</code>指明，当产生该类型的Exception时，JVM就会中断下来，进行调式。该参数可选。</li>
<li><code>launch</code>指明，当JVM被中断下来时，执行的可执行程序。该参数可选</li>
<li><code>suspend</code>指明，是否在调试客户端建立起来后，再执行JVM。</li>
<li><code>onuncaught</code>(&#x3D;y或n)指明出现uncaught exception 后，是否中断JVM的执行.</li>
</ul>
<span id="more"></span>

<h3 id="几个例子"><a href="#几个例子" class="headerlink" title="几个例子"></a>几个例子</h3><p>example1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xrunjdwp:transport=dt_socket,server=y,address=8000</span><br></pre></td></tr></table></figure>

<p>解释：在8000端口监听Socket连接，挂起VM并且不加载运行主函数直到调试请求到达</p>
<p>example2</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xrunjdwp:transport=dt_shmem,server=y,<span class="built_in">suspend</span>=n</span><br></pre></td></tr></table></figure>

<p>解释：选择一个可用的共享内存（因为没有指address）并监听该内存连接，同时加载运行主函数</p>
<p>example3</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xrunjdwp:transport=dt_socket,address=myhost:8000</span><br></pre></td></tr></table></figure>

<p>解释：连接到myhost:8000提供的调试服务（server&#x3D;n，以调试客户端存在），挂起VM并且不加载运行主函数</p>
<p>example4</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xrunjdwp:transport=dt_shmem,address=mysharedmemory</span><br></pre></td></tr></table></figure>

<p>解释：通过共享内存的方式连接到调试服务，挂起VM并且不加载运行主函数</p>
<p>example5</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xrunjdwp: transport=dt_socket,server=y,address=8000,onthrow=java.io.IOException, launch=/usr/local/bin/debugstub</span><br></pre></td></tr></table></figure>

<p>解释：等待java.io.IOException被抛出，然后挂起VM并监听8000端口连接，在接到调试请求后以命令<code>/usr/local/bin/debugstub dt_socket myhost:8000</code>执行</p>
<p>example6</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xrunjdwp:transport=dt_shmem,server=y,onuncaught=y,launch=d:\bin\debugstub.exe</span><br></pre></td></tr></table></figure>

<p>解释：等待一个<code>RuntimeException</code>被抛出，然后挂起VM并监听一个可用的共享内存，在接到调试请求后以命令<code>d:\bin\debugstub.exe dt_shmem &lt;address&gt;</code>执行,<code>&lt;address&gt;</code>是可用的共享内存</p>
<h2 id="2、启动调试工具。"><a href="#2、启动调试工具。" class="headerlink" title="2、启动调试工具。"></a>2、启动调试工具。</h2><p>最简单的调试工具就是上面提到的JDB，以上述调试用JVM为例，可以用下面的命运行启动JDB：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$jdb</span> -connect com.sun.jdi.SocketAttach:port=5432,hostname=192.168.11.213</span><br></pre></td></tr></table></figure>

<p>另外，还有好多的可视化调试工具，如 eclipse,jsawt等等。Eclipses可用 ant debug来建立一个调试方法。</p>
<p>其实就是使用了JDK的<a href="https://blog.csdn.net/qq_38835878/article/details/114539300">JPDA</a>，在启动服务器（Jboss或者Tomcat等）的命令行参数里面加上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Xdebug -Xrunjdwp:transport=dt_socket,address=8787,server=y,<span class="built_in">suspend</span>=n</span><br></pre></td></tr></table></figure>



<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1、<a href="https://www.iteye.com/blog/chainhou-1837059">https://www.iteye.com/blog/chainhou-1837059</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>远程调试</tag>
      </tags>
  </entry>
  <entry>
    <title>异步操作测试工具Awaitility</title>
    <url>/2022/07/06/%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7Awaitility/</url>
    <content><![CDATA[<p>平时在写单元测试的时候，经常会遇到一些异步场景，不确定异步线程中当前的执行状态是否已经达到自己预期的观测点，这个时候我们都会使用<code>Thread.sleep(time)</code>方式武断的等待一段时间，或者自己写个while死循环来不停的检测某个条件是否满足。前一种方式会浪费测试用例执行时间，后一种方式不够优雅。awaitility工具就是用来解决这个场景的。</p>
<span id="more"></span>

<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>异步系统难以测试。不仅因为需要处理多线程、超时和并发问题，还因为这些细节会遮蔽测试代码的意图。Awaitility是一个DSL，允许你准确且易读地表达对于异步系统的期望。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updatesCustomerStatus</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Publish an asynchronous message to a broker (e.g. RabbitMQ):</span></span><br><span class="line">    messageBroker.publishMessage(updateCustomerStatusMessage);</span><br><span class="line">    <span class="comment">// Awaitility lets you wait until the asynchronous operation completes:</span></span><br><span class="line">    await().atMost(<span class="number">5</span>, SECONDS).until(customerStatusIsUpdated());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><p>Maven:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.awaitility<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>awaitility<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Gradle（Groovy DSL）:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">testImplementation <span class="string">&#x27;org.awaitility:awaitility:4.2.0&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="三、静态导入"><a href="#三、静态导入" class="headerlink" title="三、静态导入"></a>三、静态导入</h2><p>为了有效地使用Awaitility，建议从Awaitility框架静态导入如下方法：</p>
<ul>
<li><code>org.awaitility.Awaitility.*</code></li>
</ul>
<p>导入下面这些方法可能也是有用的：</p>
<ul>
<li><code>java.time.Duration.*</code></li>
<li><code>java.util.concurrent.TimeUnit.*</code></li>
<li><code>org.hamcrest.Matchers.*</code></li>
<li><code>org.junit.Assert.*</code></li>
</ul>
<h2 id="四、使用示例"><a href="#四、使用示例" class="headerlink" title="四、使用示例"></a>四、使用示例</h2><h3 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h3><p>假设我们发送”add user”消息给我们的异步系统，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">publish(<span class="keyword">new</span> <span class="title class_">AddUserMessage</span>(<span class="string">&quot;Awaitility Rocks&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>在你的测试用例中，Awaitility可以帮助你轻松的检测数据库已经被更新了。最简单的形式就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().until(newUserIsAdded());</span><br></pre></td></tr></table></figure>

<p>在测试用例中你自己得实现<code>newUserIsAdded</code>方法。只有当它指定的条件被满足了，Awaitility才会停止等待。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Callable&lt;Boolean&gt; <span class="title function_">newUserIsAdded</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> () -&gt; userRepository.size() == <span class="number">1</span>; <span class="comment">// The condition that must be fulfilled</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你当然也可以内联<code>newUserIsAdded</code>方法，就像下面这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().until(() -&gt; userRepository.size() == <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>默认情况下Awaitility将会等待10秒钟，并且当到这个时间的时候如果用户仓库的数据量不等于1，那么它就会抛出一个<a href="http://static.javadoc.io/org.awaitility/awaitility/4.2.0/org/awaitility/core/ConditionTimeoutException.html">ConditionTimeoutException</a>异常来使测试失败。如果你想要不同的超时时间，你可以像下面这样定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().atMost(<span class="number">5</span>, SECONDS).until(newUserWasAdded());</span><br></pre></td></tr></table></figure>

<h3 id="复用等待条件"><a href="#复用等待条件" class="headerlink" title="复用等待条件"></a>复用等待条件</h3><p>Awaitility也支持分割等待条件为数据提供（supplying）和条件匹配（matching）部分，这样可以更好的使用。下面是例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().until( userRepositorySize(), equalTo(<span class="number">1</span>) );</span><br></pre></td></tr></table></figure>

<p><code>userRepositorySize</code>方法现在是一个<code>Integer</code>类型的<code>Callable</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Callable&lt;Integer&gt; <span class="title function_">userRepositorySize</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> () -&gt; userRepository.size(); <span class="comment">// The suppling part of the condition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>equalTo</code> 是一个标准的 <a href="http://code.google.com/p/hamcrest/">Hamcrest</a> 匹配器（matcher），为Awaitility指定条件匹配部分。</p>
<p>现在我们可以在不同的测试用例中重用<code>userRepositorySize</code>。假设我们有一个测试用例在同一时间添加三个用户（user）对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">publish(<span class="keyword">new</span> <span class="title class_">AddUserMessage</span>(<span class="string">&quot;User 1&quot;</span>), <span class="keyword">new</span> <span class="title class_">AddUserMessage</span>(<span class="string">&quot;User 2&quot;</span>), <span class="keyword">new</span> <span class="title class_">AddUserMessage</span>(<span class="string">&quot;User 3&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>我们现在重用<code>userRepositorySize</code> “condition supplier”，并且简单的更新Hamcrest匹配器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().until( userRepositorySize(), equalTo(<span class="number">3</span>) );</span><br></pre></td></tr></table></figure>

<p>在下面这种简单的例子中，你当然也可以利用Java的方法引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().until(userRepository::size, equalTo(<span class="number">3</span>) );</span><br></pre></td></tr></table></figure>

<h3 id="字段类型条件"><a href="#字段类型条件" class="headerlink" title="字段类型条件"></a>字段类型条件</h3><p>你也可以通过字段引用来构建数据提供部分，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().until( fieldIn(object).ofType(<span class="type">int</span>.class), equalTo(<span class="number">2</span>) );</span><br></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().until( fieldIn(object).ofType(<span class="type">int</span>.class).andWithName(<span class="string">&quot;fieldName&quot;</span>), equalTo(<span class="number">2</span>) );</span><br></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().until( fieldIn(object).ofType(<span class="type">int</span>.class).andAnnotatedWith(MyAnnotation.class), equalTo(<span class="number">2</span>) );</span><br></pre></td></tr></table></figure>

<h3 id="Atomic-Adders-and-Accumulators"><a href="#Atomic-Adders-and-Accumulators" class="headerlink" title="Atomic, Adders and Accumulators"></a>Atomic, Adders and Accumulators</h3><p>如果你正在使用原子类型（Atomic），Awaitility提供简单的方法设置等待条件，直到原子类变量满足特定的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">atomic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// Do some async stuff that eventually updates the atomic integer</span></span><br><span class="line">await().untilAtomic(atomic, equalTo(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>等待一个<code>AtomicBoolean</code>更加简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AtomicBoolean</span> <span class="variable">atomic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// Do some async stuff that eventually updates the atomic boolean</span></span><br><span class="line">await().untilTrue(atomic);</span><br></pre></td></tr></table></figure>

<p>如果你在使用Adders，例如 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/LongAdder.html">LongAdder</a>，Awaitility允许你简单等待它到达一个特定值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().untilAdder(myLongAdder, equalTo(<span class="number">5L</span>))</span><br></pre></td></tr></table></figure>

<p>Likewise, if using Accumulators such as <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/LongAccumulator.html">LongAccumulator</a>, you can do:</p>
<p>同样地，如果使用Accumulators例如 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/LongAccumulator.html">LongAccumulator</a>，你可以像下面这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().untilAccumulator(myLongAccumulator, equalTo(<span class="number">5L</span>))</span><br></pre></td></tr></table></figure>



<h3 id="Lambdas"><a href="#Lambdas" class="headerlink" title="Lambdas"></a>Lambdas</h3><p>你可以条件中使用lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().atMost(<span class="number">5</span>, SECONDS).until(() -&gt; userRepository.size() == <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>或者方法引用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().atMost(<span class="number">5</span>, SECONDS).until(userRepository::isNotEmpty);</span><br></pre></td></tr></table></figure>

<p>或者组合方法引用和Hamcrest匹配器（matchers）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().atMost(<span class="number">5</span>, SECONDS).until(userRepository::size, is(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>你也可以使用断言：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().atMost(<span class="number">5</span>, SECONDS).until(userRepository::size, size -&gt; size == <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>使用示例参考： <a href="http://www.jayway.com/2014/04/23/java-8-and-assertj-support-in-awaitility-1-6-0/">Jayway team blog</a>.</p>
<h3 id="使用AssertJ或者Fest-Assert"><a href="#使用AssertJ或者Fest-Assert" class="headerlink" title="使用AssertJ或者Fest Assert"></a>使用AssertJ或者Fest Assert</h3><p>你可以使用 <a href="http://joel-costigliola.github.io/assertj/">AssertJ</a> 或 <a href="https://code.google.com/p/fest/">Fest Assert</a> 作为Hamcrest的替代者。实际上可以使用任意的第三方库，只要它会在发生错误的时候抛异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().atMost(<span class="number">5</span>, SECONDS).untilAsserted(() -&gt; assertThat(fakeRepository.getValue()).isEqualTo(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<h3 id="At-Least"><a href="#At-Least" class="headerlink" title="At Least"></a>At Least</h3><p>你可以使用Awaitility等待至少某段时间。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().atLeast(<span class="number">1</span>, SECONDS).and().atMost(<span class="number">2</span>, SECONDS).until(value(), equalTo(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>例子中，在由<code>atLeast</code>指定的时长之前条件会被满足，否则会抛出一个异常来表明在指定的时长之前条件可能不会被满足。</p>
<h3 id="断言值被保持"><a href="#断言值被保持" class="headerlink" title="断言值被保持"></a>断言值被保持</h3><p>从Awaitility 4.0.2开始，可以断言某个值被保持了指定的时长。例如，如果你需要确定在数据库中的某个值在1500毫秒中被保持了800毫秒，就可以像下面这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().during(<span class="number">800</span>, MILLISECONDS).atMost(<span class="number">1500</span>, MILLISECONDS).until(() -&gt; myRepository.findById(<span class="string">&quot;id&quot;</span>), equalTo(<span class="string">&quot;something&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>Awaitility最多等待1500毫秒，并且会检测<code>myRepository.findById(&quot;id&quot;)</code>必须等于”something”至少800毫秒。</p>
<h2 id="五、重要事项"><a href="#五、重要事项" class="headerlink" title="五、重要事项"></a>五、重要事项</h2><p>Awaitility不会确保线程安全和线程同步！那是你自己的责任！确保你的代码正确处理了同步，或者你正在使用线程安全的数据结构，例如volatile字段或类，比如AtomicInteger和ConcurrentHashMap。</p>
<p><strong>参考资料:</strong></p>
<ol>
<li>GitHub地址：<a href="https://github.com/awaitility/awaitility">https://github.com/awaitility/awaitility</a></li>
<li>Getting started：<a href="https://github.com/awaitility/awaitility/wiki/Getting_started">https://github.com/awaitility/awaitility/wiki/Getting_started</a></li>
<li>用户手册：<a href="https://github.com/awaitility/awaitility/wiki/Usage">https://github.com/awaitility/awaitility/wiki/Usage</a></li>
<li><a href="https://github.com/awaitility/awaitility/blob/master/awaitility/src/test/java/org/awaitility/AwaitilityTest.java">Awaitility test case</a></li>
<li><a href="https://github.com/awaitility/awaitility/blob/master/awaitility-java8-test/src/test/java/org/awaitility/AwaitilityJava8Test.java">Awaitility test case Java 8</a></li>
<li><a href="https://github.com/awaitility/awaitility/blob/master/awaitility/src/test/java/org/awaitility/UsingFieldSupplierTest.java">Field supplier test case</a></li>
<li><a href="https://github.com/awaitility/awaitility/blob/master/awaitility/src/test/java/org/awaitility/UsingAtomicTest.java">Atomic test case</a></li>
<li><a href="http://awaitility.googlecode.com/files/awaitility-khelg-2011.pdf">Presentation</a> from <a href="http://www.jayway.com/">Jayway</a>‘s KHelg 2011</li>
</ol>
]]></content>
      <categories>
        <category>编程 - 测试</category>
      </categories>
      <tags>
        <tag>Awaitility</tag>
      </tags>
  </entry>
  <entry>
    <title>Junit5设计分析（三）</title>
    <url>/2022/09/03/Junit5%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>代码仓库：<a href="https://github.com/junit-team/junit5/">https://github.com/junit-team/junit5/</a></p>
<p>在”Junit5设计分析（一）”和”Junit5设计分析（二）”中，我们已经梳理清楚了Junit5执行测试的主流程、测试任务发现和参数解析。下面就是进入Junit5设计分析的终极目标——<strong>Junit5顶层设计</strong>。</p>
<h2 id="一、执行任务的核心类"><a href="#一、执行任务的核心类" class="headerlink" title="一、执行任务的核心类"></a>一、执行任务的核心类</h2><p>在执行测试任务的主干流程上，<strong>Launcher</strong>负责接收测试请求（request），然后会找到测试引擎<strong>TestEngine</strong>进行处理，测试引擎会将找到的测试任务<strong>TestTask</strong>提交给执行器<strong>HierarchicalTestExecutorService</strong>。</p>
<p>下面这幅图展示了它们之间的合作关系：</p>
<p><img src="/images/Junit5%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%A1%B6%E5%B1%82%E8%AE%BE%E8%AE%A1.png" alt="Junit5源码分析-顶层设计"></p>
<span id="more"></span>

<h2 id="二、测试任务层次结构"><a href="#二、测试任务层次结构" class="headerlink" title="二、测试任务层次结构"></a>二、测试任务层次结构</h2><p>测试引擎处理测试请求的结果就是生成具有层次结构的测试任务类。其实在“Junit5设计分析（一）”的主干流程中有程序执行中的测试任务层次结构，下面单独进行展示：</p>
<p><img src="/images/Junit5%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%B5%8B%E8%AF%95%E4%BB%BB%E5%8A%A1%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="Junit5源码分析-测试任务层次结构"></p>
<p>测试任务一共分为三个层次，分别是：引擎层次、测试类层次、测试方法层次，它们都对应着具体的类型。下面展示这些类型的层次关系：</p>
<p><img src="/images/%E4%B8%89%E4%B8%AA%E5%B1%82%E6%AC%A1%E6%B5%8B%E8%AF%95%E4%BB%BB%E5%8A%A1%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB.png" alt="image-20220829110813045"></p>
<p>从集成层次图中可以看到<code>JupiterEngineDescriptor</code>、<code>ClassTestDescriptor</code>、<code>TestMethodTestDescriptor</code>三个类都实现了<code>TestDescripter</code>接口，因此它们可以描述测试任务，只是对应的描述层次不同。并且，它们三个类都实现了<code>Node</code>接口，因此它们可以像树结构一样被组织起来。</p>
<h2 id="三、Junit5中的设计模式"><a href="#三、Junit5中的设计模式" class="headerlink" title="三、Junit5中的设计模式"></a>三、Junit5中的设计模式</h2><h3 id="1、过滤器模式"><a href="#1、过滤器模式" class="headerlink" title="1、过滤器模式"></a>1、过滤器模式</h3><p>在”Junit5设计分析（二）”中，我们跟读<code>DefaultLauncher#discoverRoot</code>方法的时候，看到了过滤器的应用。下面是对应的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.junit.platform.launcher.core.DefaultLauncher#discoverRoot方法</span></span><br><span class="line"><span class="keyword">private</span> Root <span class="title function_">discoverRoot</span><span class="params">(LauncherDiscoveryRequest discoveryRequest, String phase)</span> &#123;</span><br><span class="line">    <span class="comment">// 1、创建Root对象</span></span><br><span class="line">    <span class="type">Root</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Root</span>();</span><br><span class="line">	<span class="comment">// 2、从每一个TestEngine中发现TestDescriptor</span></span><br><span class="line">    <span class="keyword">for</span> (TestEngine testEngine : <span class="built_in">this</span>.testEngines) &#123;</span><br><span class="line">        <span class="comment">// @formatter:off</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">engineIsExcluded</span> <span class="operator">=</span> discoveryRequest.getEngineFilters().stream()</span><br><span class="line">            .map(engineFilter -&gt; engineFilter.apply(testEngine)) <span class="comment">// ref-1</span></span><br><span class="line">            .anyMatch(FilterResult::excluded);</span><br><span class="line">        <span class="comment">// @formatter:on</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (engineIsExcluded) &#123;</span><br><span class="line">            ...... 打印日志</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		...... 打印日志</span><br><span class="line">		<span class="comment">// 2.1 发现TestDescriptor</span></span><br><span class="line">        Optional&lt;TestDescriptor&gt; engineRoot = discoverEngineRoot(testEngine, discoveryRequest);</span><br><span class="line">        <span class="comment">// 2、2 将发现的发现TestDescriptor添加到root对象中</span></span><br><span class="line">        engineRoot.ifPresent(rootDescriptor -&gt; root.add(testEngine, rootDescriptor));</span><br><span class="line">    &#125;</span><br><span class="line">    root.applyPostDiscoveryFilters(discoveryRequest);</span><br><span class="line">    <span class="comment">// 3、删除掉没有测试任务的TestDescriptor</span></span><br><span class="line">    root.prune();</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ref-1</code>处应用了过滤器。我们先来看看网上给出的过滤器模式的定义，然后再来看看Junit5中过滤器的实现，我觉得这样来学习过滤器模式更有实践意义。</p>
<h4 id="过滤器模式的定义"><a href="#过滤器模式的定义" class="headerlink" title="过滤器模式的定义"></a>过滤器模式的定义</h4><p>过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。</p>
<h4 id="Junit5中过滤器的实现"><a href="#Junit5中过滤器的实现" class="headerlink" title="Junit5中过滤器的实现"></a>Junit5中过滤器的实现</h4><p>其实过滤器模式比较简单，在Junit5中首先定义了一个<code>Filter</code>，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.junit.platform.engine;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="meta">@API(status = STABLE, since = &quot;1.0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Filter</span>&lt;T&gt; &#123;</span><br><span class="line">    ...... 省略其他静态方法</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Apply this filter to the supplied object.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	FilterResult <span class="title function_">apply</span><span class="params">(T object)</span>; <span class="comment">// ref-2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>网上查到的过滤器模式，是传入一组对象，然后调用过滤方法，返回一组结果对象。Junit5的<code>Filter</code>是在过滤单个对象，然后生成过滤结果。</p>
<p>我们再来看一个实现，加深一下理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.junit.platform.launcher;</span><br><span class="line"></span><br><span class="line"><span class="meta">@API(status = STABLE, since = &quot;1.0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EngineFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&lt;TestEngine&gt; &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> EngineFilter <span class="title function_">includeEngines</span><span class="params">(String... engineIds)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> includeEngines(Arrays.asList(engineIds));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> EngineFilter <span class="title function_">includeEngines</span><span class="params">(List&lt;String&gt; engineIds)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EngineFilter</span>(engineIds, Type.INCLUDE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> EngineFilter <span class="title function_">excludeEngines</span><span class="params">(String... engineIds)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> excludeEngines(Arrays.asList(engineIds));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> EngineFilter <span class="title function_">excludeEngines</span><span class="params">(List&lt;String&gt; engineIds)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EngineFilter</span>(engineIds, Type.EXCLUDE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; engineIds;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">EngineFilter</span><span class="params">(List&lt;String&gt; engineIds, Type type)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.engineIds = validateAndTrim(engineIds);</span><br><span class="line">		<span class="built_in">this</span>.type = type;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> FilterResult <span class="title function_">apply</span><span class="params">(TestEngine testEngine)</span> &#123;</span><br><span class="line">		Preconditions.notNull(testEngine, <span class="string">&quot;TestEngine must not be null&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">engineId</span> <span class="operator">=</span> testEngine.getId();</span><br><span class="line">		Preconditions.notBlank(engineId, <span class="string">&quot;TestEngine ID must not be null or blank&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.type == Type.INCLUDE) &#123; <span class="comment">// ref-3</span></span><br><span class="line">			<span class="keyword">return</span> includedIf(<span class="built_in">this</span>.engineIds.stream().anyMatch(engineId::equals), <span class="comment">//</span></span><br><span class="line">				() -&gt; String.format(<span class="string">&quot;Engine ID [%s] is in included list [%s]&quot;</span>, engineId, <span class="built_in">this</span>.engineIds), <span class="comment">//</span></span><br><span class="line">				() -&gt; String.format(<span class="string">&quot;Engine ID [%s] is not in included list [%s]&quot;</span>, engineId, <span class="built_in">this</span>.engineIds));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> includedIf(<span class="built_in">this</span>.engineIds.stream().noneMatch(engineId::equals), <span class="comment">//</span></span><br><span class="line">				() -&gt; String.format(<span class="string">&quot;Engine ID [%s] is not in excluded list [%s]&quot;</span>, engineId, <span class="built_in">this</span>.engineIds), <span class="comment">//</span></span><br><span class="line">				() -&gt; String.format(<span class="string">&quot;Engine ID [%s] is in excluded list [%s]&quot;</span>, engineId, <span class="built_in">this</span>.engineIds));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>EngineFilter#apply</code>方法内的<code>ref-3</code>处，会依据当前过滤类型是包含还是排除来使用保存的一组“标准”（<code>engineIds</code>）对目标（<code>testEngine</code>）进行过滤。</p>
<p>我们可以看到<code>EngineFilter</code>代码逻辑比较简单，但是它提供的静态工厂方法和<code>includedIf</code>封装都值得学习，这些封装使得<code>EngineFilter</code>更加易用且阅读清晰。</p>
<p>小总结：<strong>过滤器模式就是从一组对象中挑选出满足要求的对象</strong>。</p>
<h3 id="2、观察者模式"><a href="#2、观察者模式" class="headerlink" title="2、观察者模式"></a>2、观察者模式</h3><p>当单元测试执行的时候，会产生很多的变化，这些变化就形成了事件，如果有关心这些变化的对象，那么它们就可以向<code>Launcher</code>中注册监听器，当事件发生的时候会被通知到。</p>
<p>我们先来看看Junit5中使用观察者模式的地方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.junit.platform.engine.support.hierarchical.NodeTestTask#executeRecursively 方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">executeRecursively</span><span class="params">()</span> &#123;</span><br><span class="line">    taskContext.getListener().executionStarted(testDescriptor); <span class="comment">// ref-4</span></span><br><span class="line">    started = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    throwableCollector.execute(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// @formatter:off</span></span><br><span class="line">        List&lt;NodeTestTask&lt;C&gt;&gt; children = testDescriptor.getChildren().stream()</span><br><span class="line">            .map(descriptor -&gt; <span class="keyword">new</span> <span class="title class_">NodeTestTask</span>&lt;C&gt;(taskContext, descriptor))</span><br><span class="line">            .collect(toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line">        <span class="comment">// @formatter:on</span></span><br><span class="line"></span><br><span class="line">        context = node.before(context);</span><br><span class="line"></span><br><span class="line">        <span class="type">DynamicTestExecutor</span> <span class="variable">dynamicTestExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultDynamicTestExecutor</span>();</span><br><span class="line">        context = node.execute(context, dynamicTestExecutor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!children.isEmpty()) &#123;</span><br><span class="line">            children.forEach(child -&gt; child.setParentContext(context));</span><br><span class="line">            taskContext.getExecutorService().invokeAll(children);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dynamicTestExecutor.awaitFinished();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    throwableCollector.execute(() -&gt; node.after(context));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NodeTestTask#executeRecursively</code>在”Junit5设计分析（一）”中就分析过了，不过当时是分析的Junit5单元测试主干流程。今天我们看看<code>ref-4</code>处的监听器调用部分。</p>
<p><code>taskContext.getListener()</code>返回的是<code>EngineExecutionListener</code>，然后调用它的<code>executionStarted</code>方法，通知测试开始执行了。</p>
<p>还是和前面一样，我们先看看观察者模式的定义，然后再看看Junit5中的实际实现。</p>
<h4 id="观察者模式的定义"><a href="#观察者模式的定义" class="headerlink" title="观察者模式的定义"></a>观察者模式的定义</h4><p><strong>模式动机</strong></p>
<p>建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。</p>
<p><strong>模式定义</strong></p>
<p>观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish&#x2F;Subscribe）模式、模型-视图（Model&#x2F;View）模式、源-监听器（Source&#x2F;Listener）模式或从属者（Dependents）模式。</p>
<p>观察者模式是一种对象行为型模式。</p>
<p><strong>模式结构</strong></p>
<p>观察者模式包含如下角色：</p>
<ul>
<li>Subject: 目标</li>
<li>ConcreteSubject: 具体目标</li>
<li>Observer: 观察者</li>
<li>ConcreteObserver: 具体观察者</li>
</ul>
<p><img src="/images/Obeserver.jpg" alt="观察者模式_模式结构"></p>
<p>(图片来自于网络)</p>
<p><strong>时序图</strong></p>
<p><img src="/images/seq_Obeserver.jpg" alt="观察者模式_时序图"></p>
<p>当目标发生状态改变的时候，会通知观察者。</p>
<h4 id="Junit5中观察者的实现"><a href="#Junit5中观察者的实现" class="headerlink" title="Junit5中观察者的实现"></a>Junit5中观察者的实现</h4><p>我们先来看看Junit5中观察者接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.junit.platform.engine;</span><br><span class="line"></span><br><span class="line"><span class="meta">@API(status = STABLE, since = &quot;1.0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EngineExecutionListener</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">dynamicTestRegistered</span><span class="params">(TestDescriptor testDescriptor)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">executionSkipped</span><span class="params">(TestDescriptor testDescriptor, String reason)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">executionStarted</span><span class="params">(TestDescriptor testDescriptor)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">executionFinished</span><span class="params">(TestDescriptor testDescriptor, TestExecutionResult testExecutionResult)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">reportingEntryPublished</span><span class="params">(TestDescriptor testDescriptor, ReportEntry entry)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>EngineExecutionListener</code>中并没有定义独立的事件类，而是不同的事件对应着不同的方法，<code>executionSkipped</code>、<code>executionStarted</code>和<code>executionFinished</code>三个方法最明显。</p>
<p>当有事件发生的时候，就会触发对应的方法，然后把相关的对象传递给具体的实现类。我们接下来看看都有哪些实现类：</p>
<img src="images/image-20220902111014837.png" alt="image-20220902111014837" style="zoom:50%;" />

<p>在IDEA中看，只有一个实现类，我们来详细看看这个实现类的细节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.junit.platform.launcher.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExecutionListenerAdapter</span> <span class="keyword">implements</span> <span class="title class_">EngineExecutionListener</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> TestPlan testPlan;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> TestExecutionListener testExecutionListener;</span><br><span class="line"></span><br><span class="line">	ExecutionListenerAdapter(TestPlan testPlan, TestExecutionListener testExecutionListener) &#123;</span><br><span class="line">		<span class="built_in">this</span>.testPlan = testPlan;</span><br><span class="line">		<span class="built_in">this</span>.testExecutionListener = testExecutionListener;</span><br><span class="line">	&#125;</span><br><span class="line">	...... <span class="comment">// 所有的方法实现都委派给了testExecutionListener</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>ExecutionListenerAdapter</code>是一个适配器类，真正执行事件处理的是<code>TestExecutionListener</code>，这个类其实是接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.junit.platform.launcher;</span><br><span class="line"></span><br><span class="line"><span class="meta">@API(status = STABLE, since = &quot;1.0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TestExecutionListener</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">testPlanExecutionStarted</span><span class="params">(TestPlan testPlan)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">testPlanExecutionFinished</span><span class="params">(TestPlan testPlan)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">dynamicTestRegistered</span><span class="params">(TestIdentifier testIdentifier)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">executionSkipped</span><span class="params">(TestIdentifier testIdentifier, String reason)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">executionStarted</span><span class="params">(TestIdentifier testIdentifier)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">executionFinished</span><span class="params">(TestIdentifier testIdentifier, TestExecutionResult testExecutionResult)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">reportingEntryPublished</span><span class="params">(TestIdentifier testIdentifier, ReportEntry entry)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个接口里面的方法是和<code>EngineExecutionListener</code>接口基本一致，就多出来了<code>testPlanExecutionStarted</code>和<code>testPlanExecutionFinished</code>方法。</p>
<p>在使用IDEA执行单元测试的时候，传入进来的实现类是<code>JUnit5TestExecutionListener</code>，它会处理相应的事件，并把结果在IDEA上呈现。</p>
<p>这儿需要注意的是Junit5应该是遵循了分层设计，<code>TestExecutionListener</code>和<code>EngineExecutionListener</code>接口功能几乎一致，但是它们却是在不同层次的测试执行事件观察者抽象，<code>TestExecutionListener</code>是在<code>Launcher</code>层面进行的抽象，层次更高，<code>EngineExecutionListener</code>是在测试执行引擎层面的抽象。</p>
<p>在Junit5中被观察的目标是<code>NodeTestTask</code>，它在执行测试动作的时候会通知观察者，比如<code>ref-4</code>处代码就是在通知观察者测试开始执行了。</p>
<h2 id="四、-API注解"><a href="#四、-API注解" class="headerlink" title="四、@API注解"></a>四、@API注解</h2><p>在贴出来的类层次图和一些类的源码中都有<code>@API</code>注解，我们接下来就探索一下这个注解。</p>
<p>该项目的地址为：<a href="https://github.com/apiguardian-team/apiguardian">https://github.com/apiguardian-team/apiguardian</a></p>
<p>这是一个非常小的项目，它的作用也是非常的明确，我们直接来看看它的类注释上的内容：</p>
<blockquote>
<p>@API is used to annotate public types, methods, constructors, and fields within a framework or application in order to publish their status and level of stability and to indicate how they are intended to be used by consumers of the API.</p>
<p>If @API is present on a type, it is considered to hold for all public members of the type as well. However, a member of such an annotated type is allowed to declare a API.Status of lower stability. For example, a class annotated with @API(status &#x3D; STABLE) may declare a constructor for internal usage that is annotated with @API(status &#x3D; INTERNAL).</p>
</blockquote>
<p>简单的说，这个注解就是用来标注接口和类的稳定性的，方便使用者明白类和接口的意图。</p>
<p>然后我们来看看Junit5中的一个实际例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.junit.platform.launcher;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标识出这个接口是稳定的，可以被外部使用，status最后被修改时接口的版本为1.0</span></span><br><span class="line"><span class="meta">@API(status = STABLE, since = &quot;1.0&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TestExecutionListener</span> &#123;</span><br><span class="line">    ...... 省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>写了三篇文章来分析Junit5，先是分析了Junit5单元测试执行的主干流程，然后分析了测试任务发现过程、参数解析过程，最后分析了执行任务的核心类、测试任务层次结构和涉及到的设计模式。基本上算是把Junit5分析透彻了，从中学习到了很多的知识，特别时接口的分层、异常处理技巧，还有过滤器模式和观察者模式的应用。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1、<a href="https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/observer.html#id16">观察者模式</a></p>
]]></content>
      <categories>
        <category>Java - 测试</category>
      </categories>
      <tags>
        <tag>JUnit5</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker网络分析</title>
    <url>/2022/07/11/Dokcer%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>在进行探索之前，我们先来看一张Docker网络整体结构图</p>
<p><img src="/images/Docker%E7%BD%91%E7%BB%9C%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="image"></p>
<p>在这个图中eth0和veth是虚拟网卡对，docker0是网桥，ens33是物理网卡。所有的网络数据报文最终都是要经过物理网卡ens33发送出去的，那么Container之间是怎么通信的？Container与外部互联网主机之间又是怎么通信的呢？接下来的内容就来探索这些问题。</p>
<span id="more"></span>

<h2 id="虚拟网桥Docker0和主机物理网卡是如何传递数据的？"><a href="#虚拟网桥Docker0和主机物理网卡是如何传递数据的？" class="headerlink" title="虚拟网桥Docker0和主机物理网卡是如何传递数据的？"></a>虚拟网桥Docker0和主机物理网卡是如何传递数据的？</h2><p>我们先来看看刚建好的容器里面是否可以和外部互联网通信？经过验证，<strong>Docker中的容器可以ping通<a href="http://www.baidu.com/">www.baidu.com</a></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@b18022430c6d:/<span class="comment"># ping www.baidu.com</span></span><br><span class="line">PING www.a.shifen.com (220.181.38.149) 56(84) bytes of data.</span><br><span class="line">64 bytes from 220.181.38.149 (220.181.38.149): icmp_seq=1 ttl=127 time=36.9 ms</span><br><span class="line">64 bytes from 220.181.38.149 (220.181.38.149): icmp_seq=2 ttl=127 time=38.6 ms</span><br><span class="line">64 bytes from 220.181.38.149 (220.181.38.149): icmp_seq=3 ttl=127 time=35.4 ms</span><br><span class="line">64 bytes from 220.181.38.149 (220.181.38.149): icmp_seq=4 ttl=127 time=35.3 ms</span><br><span class="line">64 bytes from 220.181.38.149 (220.181.38.149): icmp_seq=5 ttl=127 time=35.4 ms</span><br><span class="line">^C</span><br><span class="line">--- www.a.shifen.com ping statistics ---</span><br><span class="line">5 packets transmitted, 5 received, 0% packet loss, time 4008ms</span><br><span class="line">rtt min/avg/max/mdev = 35.335/36.325/38.631/1.290 ms</span><br></pre></td></tr></table></figure>

<p>Docker中的容器是直接连到虚拟网桥docker0上面的，我们查看一下<strong>主机上的网卡信息</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mucao@mucao-vm:~$ ifconfig</span><br><span class="line">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        inet6 fe80::42:22ff:fedc:b681  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 02:42:22:dc:b6:81  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 10  bytes 667 (667.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 43  bytes 5565 (5.5 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.42.101  netmask 255.255.255.0  broadcast 192.168.42.255</span><br><span class="line">        inet6 fe80::1bde:af17:bc0b:11fb  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 00:0c:29:d9:79:39  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 947  bytes 97617 (97.6 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 603  bytes 66960 (66.9 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 204  bytes 17150 (17.1 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 204  bytes 17150 (17.1 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">vethae4af8f: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet6 fe80::944f:87ff:fe8a:1761  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 96:4f:87:8a:17:61  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 10  bytes 807 (807.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 73  bytes 9019 (9.0 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>

<p>可以看到主机上面的网卡有虚拟网桥docker0、物理网卡ens33、虚拟网卡vethae4af8f。不管主机和docker的网络到底是怎么样的，一个TCP&#x2F;IP数据包最后能够发送出去，肯定是通过主机上唯一的物理网卡ens33的。</p>
<p>容器里面发送的网络数据包肯定是会到达docker0，然后肯定是从物理网卡ens33发送到互联网。那么docker0和ens33之间的数据报文是怎么传递的呢？经过查证，答案就是iptables。</p>
<p>我们先来了解点儿iptables的预备知识。</p>
<p>1、iptables的工作流程</p>
<p>① 防火墙是一层一层过滤的。实际是按照配置规则的顺序从上到下，从前到后进行过滤的；<br>② 如果匹配上规则，即明确表明阻止还是通过，此时数据包就不再向下匹配新规则了；<br>③ 如果所有规则中没有明确表明是阻止还是通过这个数据包，也就是没有匹配上规则，则按照默认策略进行处理；<br>④ 防火墙的默认规则是对应的链的所有的规则执行完成后才会执行的；</p>
<p>2、iptables四表五链</p>
<p>iptables实际上是由四张表和五条链组成的。</p>
<p>规则链包括如下五个：</p>
<table>
<thead>
<tr>
<th>链名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>INPUT</td>
<td>处理输入数据包</td>
</tr>
<tr>
<td>OUTPUT</td>
<td>处理输出数据包</td>
</tr>
<tr>
<td>FORWARD</td>
<td>处理转发数据包</td>
</tr>
<tr>
<td>PREROUTING</td>
<td>用于目标地址转换(DNAT)</td>
</tr>
<tr>
<td>POSTOUTING</td>
<td>用于源地址转换(SNAT)</td>
</tr>
</tbody></table>
<p>五张表里面最重要的是filter和nat表。下面逐一介绍：</p>
<p>filter表主要是和主机自身相关，真正负责主机防火墙功能（过滤流入流出主机的数据包）, filter表是iptables默认使用的表，这个表定义了三个链（chains）。</p>
<table>
<thead>
<tr>
<th>链名</th>
<th>filter表中作用</th>
</tr>
</thead>
<tbody><tr>
<td>INPUT</td>
<td>过滤进入主机的数据包</td>
</tr>
<tr>
<td>FORWARD</td>
<td>负责转发流经主机的数据包</td>
</tr>
<tr>
<td>OUTPUT</td>
<td>处理从主机发出去的数据包</td>
</tr>
</tbody></table>
<p>nat表负责网络地址转换，即来源与目的IP地址和port的转换。和主机本身无关，一般用于局域网共享上网或者特殊的端口转换服务相关。比如，用于企业路由或网关，共享上网。这个表定义了3个链，nat功能相当于网络的acl控制，和网络交换机acl类似。</p>
<table>
<thead>
<tr>
<th>链名</th>
<th>nat表中作用</th>
</tr>
</thead>
<tbody><tr>
<td>OUTPUT</td>
<td>改变主机发出数据包的目标地址</td>
</tr>
<tr>
<td>PREROUTING</td>
<td>在数据包到达防火墙时进行路由判断之前执行的规则；<br/>改写数据包的目的地址、目的端口</td>
</tr>
<tr>
<td>POSTROUTING</td>
<td>在数据包离开防火墙时进行路由判断之后执行的规则；<br/>改变数据包的源地址、源端口</td>
</tr>
</tbody></table>
<p>下面我们来看一下iptables是如何使用这四表五链工作的？</p>
<p><img src="/images/iptables%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpeg" alt="20200328205338"></p>
<p>下面我们来查看下主机上iptables的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># filter表信息</span></span><br><span class="line">mucao@mucao-vm:~$ sudo iptables -t filter -L -n -v --line-numbers</span><br><span class="line">Chain INPUT (policy ACCEPT 2508 packets, 199K bytes)</span><br><span class="line">num   pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy DROP 0 packets, 0 bytes)</span><br><span class="line">num   pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">1       16  1466 DOCKER-USER  all  --  *      *       0.0.0.0/0            0.0.0.0/0</span><br><span class="line">2       16  1466 DOCKER-ISOLATION-STAGE-1  all  --  *      *       0.0.0.0/0            0.0.0.0/0</span><br><span class="line">3        8   855 ACCEPT     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED</span><br><span class="line">4        0     0 DOCKER     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">5        8   611 ACCEPT     all  --  docker0 !docker0  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">6        0     0 ACCEPT     all  --  docker0 docker0  0.0.0.0/0            0.0.0.0/0</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 1860 packets, 252K bytes)</span><br><span class="line">num   pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain DOCKER (1 references)</span><br><span class="line">num   pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain DOCKER-ISOLATION-STAGE-1 (1 references)</span><br><span class="line">num   pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">1        8   611 DOCKER-ISOLATION-STAGE-2  all  --  docker0 !docker0  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">2       16  1466 RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0</span><br><span class="line"></span><br><span class="line">Chain DOCKER-ISOLATION-STAGE-2 (1 references)</span><br><span class="line">num   pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">1        0     0 DROP       all  --  *      docker0  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">2        8   611 RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0</span><br><span class="line"></span><br><span class="line">Chain DOCKER-USER (1 references)</span><br><span class="line">num   pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">1       16  1466 RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nat表信息</span></span><br><span class="line">mucao@mucao-vm:~$ sudo iptables -t nat -L -n -v --line-numbers</span><br><span class="line">Chain PREROUTING (policy ACCEPT 22 packets, 1821 bytes)</span><br><span class="line">num   pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">1        2   104 DOCKER     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT 19 packets, 1605 bytes)</span><br><span class="line">num   pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 235 packets, 18840 bytes)</span><br><span class="line">num   pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">1        0     0 DOCKER     all  --  *      *       0.0.0.0/0           !127.0.0.0/8          ADDRTYPE match dst-type LOCAL</span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT 235 packets, 18840 bytes)</span><br><span class="line">num   pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">1        3   216 MASQUER ADE  all  --  *      !docker0  172.17.0.0/16        0.0.0.0/0</span><br><span class="line"></span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line">num   pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">1        0     0 RETURN     all  --  docker0 *       0.0.0.0/0            0.0.0.0/0</span><br></pre></td></tr></table></figure>

<p>关键字 “Chain”也就是链的意思，大概就是一个组的意思，Chain下面就是规则，规则的模版都是一样。接下来介绍iptables信息的每一列是什么含义：</p>
<table>
<thead>
<tr>
<th>规则列名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>pkts</td>
<td>对应规则匹配到的报文的个数</td>
</tr>
<tr>
<td>bytes</td>
<td>对应匹配到的报文包的大小总和</td>
</tr>
<tr>
<td>target</td>
<td>触发操作。意思是规则生效之后，进行怎样的处理</td>
</tr>
<tr>
<td>prot</td>
<td>表示规则对应的协议，是否只针对某些协议应用此规则</td>
</tr>
<tr>
<td>opt</td>
<td>表示规则对应的选项</td>
</tr>
<tr>
<td>in</td>
<td>表示数据包由哪个接口(网卡)流入，我们可以设置通过哪块网卡流入的报文需要匹配当前规则</td>
</tr>
<tr>
<td>out</td>
<td>表示数据包由哪个接口(网卡)流出，我们可以设置通过哪块网卡流出的报文需要匹配当前规则</td>
</tr>
<tr>
<td>source</td>
<td>表示规则对应的源头地址，可以是一个IP，也可以是一个网段</td>
</tr>
<tr>
<td>destination</td>
<td>表示规则对应的目标地址。可以是一个IP，也可以是一个网段</td>
</tr>
</tbody></table>
<p>target代表匹配到规则后的操作，有下面这些常用的操作类型：</p>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ACCEPT</td>
<td>允许数据包通过</td>
</tr>
<tr>
<td>DROP</td>
<td>直接丢弃数据包，不给任何回应信息</td>
</tr>
<tr>
<td>REJECT</td>
<td>拒绝数据包通过，必要时会给数据发送端一个响应的信息，客户端刚请求就会收到拒绝的信息</td>
</tr>
<tr>
<td>SNAT</td>
<td>源地址转换，解决内网用户用同一个公网地址上网的问题。</td>
</tr>
<tr>
<td>MASQUERADE</td>
<td>是SNAT的一种特殊形式，适用于动态的、临时会变的ip上</td>
</tr>
<tr>
<td>DNAT</td>
<td>目标地址转换</td>
</tr>
<tr>
<td>REDIRECT</td>
<td>在本机做端口映射</td>
</tr>
<tr>
<td>LOG</td>
<td>在&#x2F;var&#x2F;log&#x2F;messages文件中记录日志信息，然后将数据包传递给下一条规则</td>
</tr>
<tr>
<td>RETURN</td>
<td>停止匹配后续策略，如果是主链则跳到默认策略，如果是子链则跳到主链的下一条规则</td>
</tr>
</tbody></table>
<p>下面我就可以愉快的分析查出来的iptables信息了。先看filter表中关键的FORWARD链信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...... <span class="comment"># 省略INPIUT</span></span><br><span class="line">Chain FORWARD (policy DROP 0 packets, 0 bytes)</span><br><span class="line">num   pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">1       16  1466 DOCKER-USER  all  --  *      *       0.0.0.0/0            0.0.0.0/0</span><br><span class="line">2       16  1466 DOCKER-ISOLATION-STAGE-1  all  --  *      *       0.0.0.0/0            0.0.0.0/0</span><br><span class="line">3        8   855 ACCEPT     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED</span><br><span class="line">4        0     0 DOCKER     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">5        8   611 ACCEPT     all  --  docker0 !docker0  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">6        0     0 ACCEPT     all  --  docker0 docker0  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">...... <span class="comment"># 省略OUTPUT和自定义链</span></span><br></pre></td></tr></table></figure>

<p>规则2是作用是禁止docker0发送给docker0的数据。 docker -&gt; docker0  禁止</p>
<p>规则3表明其他网卡发送docker0的数据允许通过。   * -&gt; docker0  允许</p>
<p>队则5表明docker0发送给其他网卡的数据允许通过。docker0 -&gt; * 允许</p>
<p>规则6表明docker0发送给docker0的数据允许通过。  docker0 -&gt; docker0 允许</p>
<p>由于规则2是在规则6之前，所有可以看到规则6没有匹配到任何流量。</p>
<p>在nat表格中我们重点看下POSTROUTING链：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Chain POSTROUTING (policy ACCEPT 235 packets, 18840 bytes)</span><br><span class="line">num   pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">1        3   216 MASQUERADE  all  --  *      !docker0  172.17.0.0/16        0.0.0.0/0</span><br></pre></td></tr></table></figure>

<p>规则1的含义是只要不是传输给docker0网卡的数据包，并且源地址网段是172.17.0.0&#x2F;16，那么在完成过滤规则后都会进行源地址转换，然后才会将数据包发送出去。</p>
<p>可以看到在POSTROUTING链中有一个规则，它的target是MASQUERADE（伪装），是动态SNAT（source networkaddress translation的缩写，即源地址目标转换），大概意思就是从这个主机上往外发出的网络数据报文源地址会被替换为ens33的IP地址，动态性体现在无论ens33通过DHCP获取到了任何IP地址都会被作为替换后的报文源地址。从外部互联网来看的话，从这台主机上出去的所有报文源地址都是ens33的IP地址，是看不见docker0以及容器IP地址的。</p>
<p>接下来看看SNAT在iptables工作流程中生效的位置：</p>
<img src="images/SNAT在iptables工作流程中生效位置.png" alt="PIC" style="zoom:50%;" />

<p>从这张图上我们可以清晰的看到，所有从主机发出的数据报文，不管是主机应用数据报文，还是转发的数据报文，都在POSTROUTING环境执行源地址替换操作（SNAT）。</p>
<p>从数据报文的视角我们来理解一下masquerade的工作过程：</p>
<p><img src="/images/docker%E7%BD%91%E7%BB%9C_%E6%BA%90%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png" alt="docker网络_源地址转换"></p>
<p>从Container1中出发的报文在经过ens33时，源地址被替换为ens33的ip地址。相应地，响应报文在经过ens33时，目的地址被替换为Container1中eth0的ip地址。</p>
<p>总结一下，我们现在基本知道了docker0与物理网卡ens33之间的数据传输机制。</p>
<p>（1）容器之间通信： container1 -&gt; docker0 -&gt; container2</p>
<p>（2）容器发送数据到宿主机： container1 -&gt; docker0 -&gt; ens33</p>
<p>（3）宿主机发送数据到容器：ens33 -&gt; docker0 -&gt; container1</p>
<p>（4）容器发送数据到互联网主机：container1 -&gt; docker0 -&gt; ens33（源地址替换） -&gt; network-host</p>
<p>（5）互联网主机发送数据到容器：失败。容器IP地址对于互联网主机是不可见的。</p>
<h2 id="实际的网络报文在这些网卡之间是如何流转的？"><a href="#实际的网络报文在这些网卡之间是如何流转的？" class="headerlink" title="实际的网络报文在这些网卡之间是如何流转的？"></a>实际的网络报文在这些网卡之间是如何流转的？</h2><p>上面通过网卡和iptables信息基本知道了容器网卡、docker0、物理网卡、虚拟网卡veth之间的关系。下面我们进行抓包来验证一下上面得出的关系，使用的抓包工具为tcpdump + wireshark。</p>
<p>从容器中ping百度：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@b18022430c6d:/<span class="comment"># ping www.baidu.com</span></span><br><span class="line">PING www.a.shifen.com (14.215.177.39) 56(84) bytes of data.</span><br><span class="line">64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=1 ttl=127 time=49.3 ms</span><br><span class="line">64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=2 ttl=127 time=49.3 ms</span><br><span class="line">64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=3 ttl=127 time=45.4 ms</span><br><span class="line">64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=4 ttl=127 time=49.2 ms</span><br><span class="line">64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=5 ttl=127 time=63.8 ms</span><br><span class="line">64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=6 ttl=127 time=51.9 ms</span><br><span class="line">64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=7 ttl=127 time=45.2 ms</span><br><span class="line">64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=8 ttl=127 time=45.6 ms</span><br><span class="line">64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=9 ttl=127 time=69.0 ms</span><br><span class="line">64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=10 ttl=127 time=47.3 ms</span><br><span class="line">64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=11 ttl=127 time=46.3 ms</span><br><span class="line">^C</span><br><span class="line">--- www.a.shifen.com ping statistics ---</span><br><span class="line">11 packets transmitted, 11 received, 0% packet loss, time 11043ms</span><br><span class="line">rtt min/avg/max/mdev = 45.179/51.119/68.982/7.549 ms</span><br></pre></td></tr></table></figure>

<p>下面是宿主机上物理网卡ens33的抓包数据：</p>
<p><img src="/images/image-20220714192738693.png" alt="image-20220714192738693"></p>
<p>从上面物理网卡ens33的报文数据得出，在<a href="http://www.baidu.com的互联网主机看来和它通信的其实是宿主机(192.168.42.101)./">www.baidu.com的互联网主机看来和它通信的其实是宿主机（192.168.42.101）。</a></p>
<p>下面是网桥docker0上面的报文数据：</p>
<p><img src="/images/image-20220714192930043.png" alt="image-20220714192930043"></p>
<p>上面的数据第一条是从DNS服务器解析到百度网址对应的IP地址。下面的报问就是容器中执行ping命令产生的。</p>
<p>我们来仔细看这些数据，发现报文是容器eth0的地址和百度地址在交互，也就是说在docker0这儿是能看到容器地址，并且还没有发生地址替换。</p>
<p>但是在物理网卡ens33上看到的报文都是宿主机(192.168.42.101)和百度地址的交互。和百度网址进行交互的地址发生了变化，肯定是iptables中规则完成的地址转换。</p>
<p>下面我们再来看看虚拟网卡veth。</p>
<p><img src="/images/image-20220714193031530.png" alt="image-20220714193031530"></p>
<p>从报文数据来看，和在docker0上的交互地址是一样的。</p>
<p>接下来我们在看看容器eth0的报文数据：</p>
<p><img src="/images/image-20220714193229132.png" alt="image-20220714193229132"></p>
<p>从容器的eth0网卡报文数据的地址交互来看，也是和docker0上的一样。</p>
<h2 id="Container中eth0和veth之间是怎么通信的？"><a href="#Container中eth0和veth之间是怎么通信的？" class="headerlink" title="Container中eth0和veth之间是怎么通信的？"></a>Container中eth0和veth之间是怎么通信的？</h2><p>我们先来看下虚拟网卡对veth之间的关联关系。首先看下这两个网卡的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 宿主机上</span></span><br><span class="line">mucao@mucao-vm:~$ ifconfig</span><br><span class="line">...... 省略其他网卡信息</span><br><span class="line">vethae4af8f: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet6 fe80::944f:87ff:fe8a:1761  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 96:4f:87:8a:17:61  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 28  bytes 2347 (2.3 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 124  bytes 13597 (13.5 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 容器中</span></span><br><span class="line">root@b18022430c6d:/<span class="comment"># ifconfig</span></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ether 02:42:ac:11:00:02  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 124  bytes 13597 (13.5 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 28  bytes 2347 (2.3 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">...... 省略本地环回</span><br></pre></td></tr></table></figure>

<p>介绍一下网卡信息中重要的两项：</p>
<p>RX packets ：网卡接收的数据包数量</p>
<p>TX packets ：网卡发送的数据包数量</p>
<p>现在我们站在容器里面eth0网卡的角度来看数据包关系。</p>
<p>（1）eth0 发送了28个数据包，共2347字节，刚好vethae4af8f接收了28个数据包，共2347字节。</p>
<p>（2）eth0 接收了124个数据包，共13597字节，刚好vethae4af8发送了124个数据包，共13597字节。</p>
<p>容器eth0和虚拟网卡vethae4af8f之间数据是怎么传输的呢？我们来看看这个虚拟网卡对相关的Docker代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bridge.go文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *driver)</span></span> CreateEndpoint(nid, eid <span class="type">string</span>, ifInfo driverapi.InterfaceInfo, epOptions <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line">&#123;</span><br><span class="line">    ...... <span class="comment">// 省略</span></span><br><span class="line"><span class="comment">// Generate a name for what will be the host side pipe interface</span></span><br><span class="line">	hostIfName, err := netutils.GenerateIfaceName(d.nlh, vethPrefix, vethLen)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Generate a name for what will be the sandbox side pipe interface</span></span><br><span class="line">	containerIfName, err := netutils.GenerateIfaceName(d.nlh, vethPrefix, vethLen)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Generate and add the interface pipe host &lt;-&gt; sandbox</span></span><br><span class="line">	veth := &amp;netlink.Veth&#123;</span><br><span class="line">		LinkAttrs: netlink.LinkAttrs&#123;Name: hostIfName, TxQLen: <span class="number">0</span>&#125;,</span><br><span class="line">		PeerName:  containerIfName&#125;</span><br><span class="line">	<span class="keyword">if</span> err = d.nlh.LinkAdd(veth); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> types.InternalErrorf(<span class="string">&quot;failed to add the host (%s) &lt;=&gt; sandbox (%s) pair interfaces: %v&quot;</span>, hostIfName, containerIfName, err)</span><br><span class="line">	&#125;</span><br><span class="line">     ...... <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码中可以知道容器eth0和虚拟网卡vethae4af8f其实是调用Linux内核创建出来的虚拟网卡对，用来完成不同网络命名空间通信的问题。</p>
<p>我们先来对veth pair有个大概认识：</p>
<p><img src="/images/Linux_veth_pair_%E7%BB%93%E6%9E%84.webp" alt="img"></p>
<p>veth结构体通过peer字段来连接另外一段，然后看看它的作用：</p>
<p><img src="/images/Linux_veth_pair_%E4%BD%9C%E7%94%A8.png" alt="img"></p>
<p>veth pair可以用来连通两个相互隔离的网络命名空间。接下来我们再看看它的工作流程：</p>
<p><img src="/images/Linux_veth_pair_%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="img"></p>
<p>veth pair 之间传递数据通过内核协议栈完成的，这样就不会破坏网络命名空间之间的隔离性。</p>
<p>下面是虚拟网卡对之间发送数据的Linux源代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers/net/veth.c文件</span></span><br><span class="line"><span class="type">static</span> <span class="type">netdev_tx_t</span> <span class="title function_">veth_xmit</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	rcv = rcu_dereference(priv-&gt;peer); <span class="comment">// 对端就是接收者</span></span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">	skb_tx_timestamp(skb);</span><br><span class="line">	<span class="keyword">if</span> (likely(veth_forward_skb(rcv, skb, rq, use_napi) == NET_RX_SUCCESS)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">queue</span>)</span><br><span class="line">			txq_trans_cond_update(<span class="built_in">queue</span>);</span><br><span class="line">		<span class="keyword">if</span> (!use_napi)</span><br><span class="line">			dev_lstats_add(dev, length);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">drop:</span><br><span class="line">		atomic64_inc(&amp;priv-&gt;dropped);</span><br><span class="line">	&#125;</span><br><span class="line">    	...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="keyword">return</span> NETDEV_TX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="虚拟网卡vethae4af8f与docker0之间如何传递数据的？"><a href="#虚拟网卡vethae4af8f与docker0之间如何传递数据的？" class="headerlink" title="虚拟网卡vethae4af8f与docker0之间如何传递数据的？"></a>虚拟网卡vethae4af8f与docker0之间如何传递数据的？</h2><p>最后我们再看看虚拟网卡vethae4af8f与docker0之间如何传递数据的？</p>
<p>先想一个场景，多个网络命名空间都要相互通信该怎么做呢？当然可以创建很多的veth pair来完成，但是很麻烦、非常浪费资源。Linux为了解决这个问题出现了网桥。网桥的作用如下：</p>
<p><img src="/images/Linux%E7%BD%91%E6%A1%A5.png" alt="Linux网桥"></p>
<p>由于网桥的存在，每个网络命名空间只需要一个veth就可以相互通信了。Docker0其实就是Linux网桥了，相当于现实世界的网络协议二层路交换机，完成数据报文转发工作。</p>
<p>网卡加入到网桥后，它的收发数据就会由网桥管理了。发送数据的时候，首先网桥会依据mac地址在网桥内广播，如果网桥内没找到目标设备，才会发送到下一跳；接收数据的时候，其实网桥是使用的加入的网卡地址，因此<strong>一个网卡加入到网桥后就不会有自己的IP地址了</strong>，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mucao@mucao-vm:~$ ifconfig</span><br><span class="line">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        inet6 fe80::42:22ff:fedc:b681  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 02:42:22:dc:b6:81  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 10  bytes 667 (667.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 43  bytes 5565 (5.5 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">...... // 省略其他网卡信息</span><br><span class="line">vethae4af8f: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet6 fe80::944f:87ff:fe8a:1761  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 96:4f:87:8a:17:61  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 10  bytes 807 (807.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 73  bytes 9019 (9.0 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>



<p>Linux网桥会将网络接口设备 MAC地址与网桥端口进行映射。实现网桥的数据结构：</p>
<img src="images/Linux网桥数据结构.png" alt="image" style="zoom: 50%;" />

<p>Linux网桥工作过程：</p>
<img src="images/Linux网桥工作流程.png" alt="11、网络--Linux Bridge（网桥基础）_linux_02"  />

<p>我们来瞄一眼网桥中最重要的函数br_handle_frame：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Linux：net/bridge/br_input.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return NULL if skb is handled</span></span><br><span class="line"><span class="comment"> * note: already called with rcu_read_lock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">rx_handler_result_t</span> <span class="title function_">br_handle_frame</span><span class="params">(<span class="keyword">struct</span> sk_buff **pskb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span> =</span> *pskb;</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *dest = eth_hdr(skb)-&gt;h_dest;  <span class="comment">// 获取目的地址</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(skb-&gt;pkt_type == PACKET_LOOPBACK))    <span class="comment">// 本地环回</span></span><br><span class="line">		<span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!is_valid_ether_addr(eth_hdr(skb)-&gt;h_source))  <span class="comment">// 检查无效来源地址</span></span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line"></span><br><span class="line">	skb = skb_share_check(skb, GFP_ATOMIC); <span class="comment">// 检查数据报文</span></span><br><span class="line">	<span class="keyword">if</span> (!skb)</span><br><span class="line">		<span class="keyword">return</span> RX_HANDLER_CONSUMED;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(skb-&gt;cb, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> br_input_skb_cb));</span><br><span class="line"></span><br><span class="line">	p = br_port_get_rcu(skb-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;flags &amp; BR_VLAN_TUNNEL)</span><br><span class="line">		br_handle_ingress_vlan_tunnel(skb, p, nbp_vlan_group_rcu(p));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(is_link_local_ether_addr(dest))) &#123;    <span class="comment">// 目的地址不是本地</span></span><br><span class="line">		u16 fwd_mask = p-&gt;br-&gt;group_fwd_mask_required;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * See IEEE 802.1D Table 7-10 Reserved addresses</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Assignment		 		Value</span></span><br><span class="line"><span class="comment">		 * Bridge Group Address		01-80-C2-00-00-00</span></span><br><span class="line"><span class="comment">		 * (MAC Control) 802.3		01-80-C2-00-00-01</span></span><br><span class="line"><span class="comment">		 * (Link Aggregation) 802.3	01-80-C2-00-00-02</span></span><br><span class="line"><span class="comment">		 * 802.1X PAE address		01-80-C2-00-00-03</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 802.1AB LLDP 		01-80-C2-00-00-0E</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Others reserved for future standardization</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		fwd_mask |= p-&gt;group_fwd_mask;</span><br><span class="line">		<span class="keyword">switch</span> (dest[<span class="number">5</span>]) &#123;                             <span class="comment">// 依据地址类型进行数据报文转发</span></span><br><span class="line">		<span class="keyword">case</span> <span class="number">0x00</span>:	<span class="comment">/* Bridge Group Address */</span></span><br><span class="line">			<span class="comment">/* If STP is turned off,</span></span><br><span class="line"><span class="comment">			   then must forward to keep loop detection */</span></span><br><span class="line">			<span class="keyword">if</span> (p-&gt;br-&gt;stp_enabled == BR_NO_STP ||</span><br><span class="line">			    fwd_mask &amp; (<span class="number">1u</span> &lt;&lt; dest[<span class="number">5</span>]))</span><br><span class="line">				<span class="keyword">goto</span> forward;</span><br><span class="line">			*pskb = skb;</span><br><span class="line">			__br_handle_local_finish(skb);</span><br><span class="line">			<span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">0x01</span>:	<span class="comment">/* IEEE MAC (Pause) */</span></span><br><span class="line">			<span class="keyword">goto</span> drop;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">0x0E</span>:	<span class="comment">/* 802.1AB LLDP */</span></span><br><span class="line">			fwd_mask |= p-&gt;br-&gt;group_fwd_mask;</span><br><span class="line">			<span class="keyword">if</span> (fwd_mask &amp; (<span class="number">1u</span> &lt;&lt; dest[<span class="number">5</span>]))</span><br><span class="line">				<span class="keyword">goto</span> forward;</span><br><span class="line">			*pskb = skb;</span><br><span class="line">			__br_handle_local_finish(skb);</span><br><span class="line">			<span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">/* Allow selective forwarding for most other protocols */</span></span><br><span class="line">			fwd_mask |= p-&gt;br-&gt;group_fwd_mask;</span><br><span class="line">			<span class="keyword">if</span> (fwd_mask &amp; (<span class="number">1u</span> &lt;&lt; dest[<span class="number">5</span>]))</span><br><span class="line">				<span class="keyword">goto</span> forward;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* The else clause should be hit when nf_hook():</span></span><br><span class="line"><span class="comment">		 *   - returns &lt; 0 (drop/error)</span></span><br><span class="line"><span class="comment">		 *   - returns = 0 (stolen/nf_queue)</span></span><br><span class="line"><span class="comment">		 * Thus return 1 from the okfn() to signal the skb is ok to pass</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN,</span><br><span class="line">			    dev_net(skb-&gt;dev), <span class="literal">NULL</span>, skb, skb-&gt;dev, <span class="literal">NULL</span>,</span><br><span class="line">			    br_handle_local_finish) == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> RX_HANDLER_CONSUMED;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(br_process_frame_type(p, skb)))</span><br><span class="line">		<span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line"></span><br><span class="line">forward:</span><br><span class="line">	<span class="keyword">if</span> (br_mst_is_enabled(p-&gt;br))</span><br><span class="line">		<span class="keyword">goto</span> defer_stp_filtering;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (p-&gt;state) &#123;</span><br><span class="line">	<span class="keyword">case</span> BR_STATE_FORWARDING:</span><br><span class="line">	<span class="keyword">case</span> BR_STATE_LEARNING:</span><br><span class="line">defer_stp_filtering:</span><br><span class="line">		<span class="keyword">if</span> (ether_addr_equal(p-&gt;br-&gt;dev-&gt;dev_addr, dest))</span><br><span class="line">			skb-&gt;pkt_type = PACKET_HOST;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> nf_hook_bridge_pre(skb, pskb);</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">drop:</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> RX_HANDLER_CONSUMED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们最后来总结一下。Docker网络使用到的核心技术有虚拟网卡对、虚拟网桥、iptables。容器和主机网络通信是通过虚拟网卡对完成的，虚拟网卡对的两端是通过内核协议栈完成通信的，所以不会破坏网络命名空间的隔离性。在主机中的虚拟网卡都attach到虚拟网桥docker0上面，这样容器之间就可以通信了。虚拟网桥docker0再通过iptables的过滤规则和转发规则与主机物理网卡相连，这样docker0上的数据报文就可以通过主机物理网卡发送到互联网主机上了。由于iptables转发规则的地址替换机制，可以将容器地址隐藏，不会暴露到互联网中。收工！</p>
<p>参考资料：</p>
<p>1、<a href="http://www.yunweipai.com/35061.html">运维派</a></p>
<p>2、<a href="https://blog.csdn.net/zeze_z/article/details/57919479">使用wireshark分析tcpdump出来的pcap文件</a></p>
<p>3、<a href="https://man7.org/linux/man-pages/man4/veth.4.html">veth(4) — Linux manual page</a></p>
<p>4、<a href="https://www.cnblogs.com/bakari/p/10613710.html">Linux虚拟网络设备 veth-pair详解</a></p>
<p>5、<a href="https://www.bilibili.com/read/cv16733012/">一文读懂Docker网络基础-虚拟网络设备对（veth）原理</a></p>
<p>6、<a href="https://blog.csdn.net/u014027051/article/details/53908878">linux bridge网桥的工作原理</a></p>
<p>7、<a href="http://billauer.co.il/ipmasq-html.html">IP Masquerading using iptables</a></p>
]]></content>
      <categories>
        <category>编程 - docker</category>
      </categories>
      <tags>
        <tag>docker网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Junit5设计分析（一）</title>
    <url>/2022/08/19/Junit5%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>代码仓库：<a href="https://github.com/junit-team/junit5/">https://github.com/junit-team/junit5/</a></p>
<p>提到Java的单元测试，其实自己很熟悉了，从开始工作的时候就被要求写单元测试，所用到的框架就是<code>Junit</code>了，它最新的版本已经来到了5。</p>
<p>在平时写Java单元测试的时候，大致流程就是创建个测试类，在里面写个不要参数并且返回<code>void</code>的方法，然后在方法上面添加<code>@Test</code>注解。有了这三步，测试方法就能跑起来了，只不过啥用也没有。但是在测试方法里面写上调用业务的方法，然后再使用<code>assert</code>断言，就多增加了这两步，一个完整、有价值的单元测试就完成了。</p>
<p>在Junit5的帮助下，只需要上面这流畅的五步就可以写好单元测试了，反正我在平时根本不需要去注意Junit5的细节和其他知识就能完成单元测试的编写了。</p>
<p>现在仔细想象，这难道不是Junit5软件设计成功的地方吗？用户只需要知道必要的极少知识就能完成单元测试——Junit5软件的目标。</p>
<p>之前也听人说过Junit的代码写的非常好，再加之上面这些原因，我就来阅读一下Junit5的源码，希望有所收获。</p>
<span id="more"></span>


<h2 id="一、IDEA中Junit5测试执行过程"><a href="#一、IDEA中Junit5测试执行过程" class="headerlink" title="一、IDEA中Junit5测试执行过程"></a>一、IDEA中Junit5测试执行过程</h2><p>首先上一张执行过程总览图：</p>
<p><img src="/images/Junit5%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="执行过程总览图"></p>
<p>先是由IDEA的测试插件启动测试过程，然后JUnit解析执行参数并发现测试方法，最后以Java反射的方式执行测试方法。步骤细节已经放在图片中了，下面对一些重点过程在详细解析一下。</p>
<h2 id="二、任务对象NodeTestTask"><a href="#二、任务对象NodeTestTask" class="headerlink" title="二、任务对象NodeTestTask"></a>二、任务对象NodeTestTask</h2><p>在JUnit中将需要执行的任务抽成了<code>NodeTestTask</code>，从这个名字上可以看出来，其实这个类兼具了<strong>两个方面的抽象</strong>：</p>
<ul>
<li>需要执行的任务。我认为就是<code>NodeTestTask</code>中的<code>TestTask</code>。</li>
<li>任务层次结构。JUnit将任务按照<strong>测试引擎</strong>、<strong>测试类</strong>、<strong>测试方法</strong>这三个层次进行了组织，形成了树形结构。<code>NodeTestTask</code>中的<code>Node</code>就是这个方面的抽象。</li>
</ul>
<p>下面是这个类的字段信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 所在包：org.junit.platform.engine.support.hierarchical</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NodeTestTask</span>&lt;C <span class="keyword">extends</span> <span class="title class_">EngineExecutionContext</span>&gt; <span class="keyword">implements</span> <span class="title class_">TestTask</span> &#123;</span><br><span class="line">	<span class="comment">// 实际执行任务时需要用到的域对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> NodeTestTaskContext taskContext;</span><br><span class="line">    <span class="comment">// 该接口描述了一个需要执行的任务，不限于测试方法。</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> TestDescriptor testDescriptor;</span><br><span class="line">    <span class="comment">// 任务层次树中的节点</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Node&lt;C&gt; node;</span><br><span class="line">	<span class="comment">// 父节点的域对象</span></span><br><span class="line">	<span class="keyword">private</span> C parentContext;</span><br><span class="line">    <span class="comment">// 当前节点的域对象</span></span><br><span class="line">	<span class="keyword">private</span> C context;</span><br><span class="line">	<span class="comment">// 如果需要跳过测试执行方法，保存跳过的结果</span></span><br><span class="line">	<span class="keyword">private</span> SkipResult skipResult;</span><br><span class="line">    <span class="comment">// 标识是否开始</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> started;</span><br><span class="line">    <span class="comment">// 异常收集器</span></span><br><span class="line">	<span class="keyword">private</span> ThrowableCollector throwableCollector;</span><br><span class="line"></span><br><span class="line">	NodeTestTask(NodeTestTaskContext taskContext, TestDescriptor testDescriptor) &#123;</span><br><span class="line">		<span class="built_in">this</span>.taskContext = taskContext;</span><br><span class="line">		<span class="built_in">this</span>.testDescriptor = testDescriptor;</span><br><span class="line">		<span class="built_in">this</span>.node = NodeUtils.asNode(testDescriptor);</span><br><span class="line">	&#125;</span><br><span class="line">	...... 省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>NodeTestTask</code>字段中有两个重要的字段是<code>testDescriptor</code>和<code>node</code>，他们方便代表测试任务的描述和任务层次节点，这个在上面已经解释过了。然而JUnit5在这个两个变量上的处理有点儿巧妙，这两个字段都指向了同一个对象，这个对象实现了<code>TestDescriptor</code>和<code>Node</code>接口。显然<strong>在<code>NodeTestTask</code>中是想把一个对象的这两个方面分开来对待</strong>。</p>
<p>我觉得JUnit这么做的好处是，（1）可以将概念层次压平，（2）在使用时只暴露合适的功能，降低心智负担。下面就以<code>TestMethodTestDescriptor</code>类型示意一下。</p>
<p>先看一下该类的继承与实现关系：</p>
<img src="/images/TestMethodTestDescriptor类继承关系.png" alt="image-20220818234140159" style="zoom: 67%;" />

<p>下面我们来抽象一下<code>TestMethodTestDescriptor</code>类示例在<code>NodeTestTask</code>中被使用的情形：</p>
<p><img src="/images/NodeTestTask%E4%B8%AD%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E5%BC%95%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E6%9E%90.png" alt="NodeTestTask中两个变量引用同一个对象的分析"></p>
<p>在<code>NodeTestTask</code>当要使用测试描述方面的功能时，就会使用<code>TestDescriptor</code>类型<code>testDescriptor</code>成员变量，这样可以在实际使用时约束使用者确实想用的时测试描述方面的功能。同样的，在使用<code>Node</code>类型的<code>node</code>变量时也可以约束使用者确实想用的时任务层次节点的功能。</p>
<p>小结一下，我认为这个地方时JUnit5在降低复杂功能对象<code>TestMethodTestDescriptor</code>使用时的心智负担，并且使用Java类型系统来约束使用者的思考逻辑。</p>
<p>接下来我们在看看<code>NodeTestTask</code>中的方法细节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 所在包：org.junit.platform.engine.support.hierarchical</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NodeTestTask</span>&lt;C <span class="keyword">extends</span> <span class="title class_">EngineExecutionContext</span>&gt; <span class="keyword">implements</span> <span class="title class_">TestTask</span> &#123;</span><br><span class="line">	...... 省略</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123; <span class="comment">// 执行测试任务的主干流程</span></span><br><span class="line">		throwableCollector = taskContext.getThrowableCollectorFactory().create();</span><br><span class="line">        <span class="comment">// 1、开始准备工作</span></span><br><span class="line">		prepare();</span><br><span class="line">        <span class="comment">// 2、判断是否是跳过测试任务</span></span><br><span class="line">		<span class="keyword">if</span> (throwableCollector.isEmpty()) &#123;</span><br><span class="line">			checkWhetherSkipped();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 3、递归执行测试任务和子任务</span></span><br><span class="line">		<span class="keyword">if</span> (throwableCollector.isEmpty() &amp;&amp; !skipResult.isSkipped()) &#123;</span><br><span class="line">			executeRecursively();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 4、执行清理动作</span></span><br><span class="line">		<span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">			cleanUp();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 5、通知监听器测试任务执行完成</span></span><br><span class="line">		reportCompletion();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">executeRecursively</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1、通知监听器测试任务开始执行</span></span><br><span class="line">		taskContext.getListener().executionStarted(testDescriptor);</span><br><span class="line">        <span class="comment">// 2、设置开始标识为true</span></span><br><span class="line">		started = <span class="literal">true</span>;</span><br><span class="line">		<span class="comment">// 3、将任务执行流程封装成Lambda表达式，提交到异常收集器中执行。</span></span><br><span class="line">		throwableCollector.execute(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 3.1 获取子任务节点</span></span><br><span class="line">			<span class="comment">// @formatter:off</span></span><br><span class="line">			List&lt;NodeTestTask&lt;C&gt;&gt; children = testDescriptor.getChildren().stream()</span><br><span class="line">					.map(descriptor -&gt; <span class="keyword">new</span> <span class="title class_">NodeTestTask</span>&lt;C&gt;(taskContext, descriptor))</span><br><span class="line">					.collect(toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line">			<span class="comment">// @formatter:on</span></span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 3.2 执行任务开始前的动作</span></span><br><span class="line">			context = node.before(context); <span class="comment">// ref-3</span></span><br><span class="line">			<span class="comment">// 3.3 开始执行测试任务</span></span><br><span class="line">			<span class="type">DynamicTestExecutor</span> <span class="variable">dynamicTestExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultDynamicTestExecutor</span>();</span><br><span class="line">			context = node.execute(context, dynamicTestExecutor); <span class="comment">// ref-1</span></span><br><span class="line">			<span class="comment">// 3.4 调用子节点任务</span></span><br><span class="line">			<span class="keyword">if</span> (!children.isEmpty()) &#123;</span><br><span class="line">				children.forEach(child -&gt; child.setParentContext(context));</span><br><span class="line">				taskContext.getExecutorService().invokeAll(children); <span class="comment">// ref-2</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 3.5 等待当前节点任务执行完成</span></span><br><span class="line">			dynamicTestExecutor.awaitFinished();</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="comment">// 4、将任务执行完后的动作封装为lambda表达式，提交到异常收集器中执行</span></span><br><span class="line">		throwableCollector.execute(() -&gt; node.after(context)); <span class="comment">// ref-4</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reportCompletion</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1、跳过测试任务的情况</span></span><br><span class="line">		<span class="keyword">if</span> (throwableCollector.isEmpty() &amp;&amp; skipResult.isSkipped()) &#123;</span><br><span class="line">			taskContext.getListener().executionSkipped(testDescriptor, skipResult.getReason().orElse(<span class="string">&quot;&lt;unknown&gt;&quot;</span>));</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 2、还没有开始执行任务的情况</span></span><br><span class="line">		<span class="keyword">if</span> (!started) &#123;</span><br><span class="line">			<span class="comment">// Call executionStarted first to comply with the contract of EngineExecutionListener.</span></span><br><span class="line">			taskContext.getListener().executionStarted(testDescriptor);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 3、向监听器告知测试任务执行完成，并把结果发送给监听器</span></span><br><span class="line">		taskContext.getListener().executionFinished(testDescriptor, throwableCollector.toTestExecutionResult());</span><br><span class="line">		throwableCollector = <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    ...... 省略其他方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行测试任务的主干流程在<code>execute(...)</code>方法中，执行当前节点任务和递归执行子节点任务的逻辑在<code>executeRecursively(...)</code>方法中，详细的执行步骤已经用注释的方式写在上面的代码中了。</p>
<p>有两个重要的点需要关注，<code>ref-1</code>处的代码是当前节点任务的执行，<code>ref-2</code>处是调用子节点任务的逻辑，我们接下来一个一个的来看。</p>
<h2 id="三、当前节点任务的执行"><a href="#三、当前节点任务的执行" class="headerlink" title="三、当前节点任务的执行"></a>三、当前节点任务的执行</h2><p>其实在执行流程中，首先在<code>ref-1</code>处调用的节点任务是<code>JupiterEngineDescriptor</code>实例的<code>execute</code>方法，这个类的<code>execute</code>方法是一个空实现。由于递归执行的原因，然后在<code>ref-1</code>处调用的节点任务是<code>ClassTestDescriptor</code>实例的<code>execute</code>方法，这个类的<code>execute</code>方法也是一个空实现。最后在<code>ref-1</code>处调用的节点任务是<code>TestMethodTestDescriptor</code>实例，它的<code>execute</code>方法会执行我们写的单元测试方法。</p>
<p>下面我们先看下这三个<code>Node</code>实现类的层次关系：</p>
<img src="/images/三个Node实现类继承层次关系.png" alt="image-20220819105042375" style="zoom: 50%;" />

<p>可以看到这三个类既可以当作<code>Node</code>来看待，也可以当作<code>TestTask</code>来看待，所以他们才能被封装到<code>NodeTestTask</code>中。从概念上讲也是说的通的，就拿<code>TestMethodTestDescriptor</code>来说，它封装了执行测试方法的逻辑，所以可以看作是一个任务，同时它又在概念上属于测试类里面的范畴，所以也可以看作是任务层次树中的一个节点。</p>
<p>接下来我们具体看看单元测试方法的具体执行过程，也就是<code>TestMethodTestDescriptor</code>的<code>execute</code>方法：	</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.junit.jupiter.engine.descriptor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@API(status = INTERNAL, since = &quot;5.0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMethodTestDescriptor</span> <span class="keyword">extends</span> <span class="title class_">MethodBasedTestDescriptor</span> &#123;</span><br><span class="line">	<span class="comment">// 执行任务的调用器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutableInvoker</span> <span class="variable">executableInvoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExecutableInvoker</span>();</span><br><span class="line">	...... 省略其他</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该方法会在NodeTestTask的execute(...)方法中被调用</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> JupiterEngineExecutionContext <span class="title function_">prepare</span><span class="params">(JupiterEngineExecutionContext context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// 1、获取“扩展器”，相当于JUnit4的Rule</span></span><br><span class="line">		<span class="type">ExtensionRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> populateNewExtensionRegistry(context);</span><br><span class="line">        <span class="comment">// 2、获取测试类的实例对象</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">testInstance</span> <span class="operator">=</span> context.getTestInstanceProvider().getTestInstance(Optional.of(registry));</span><br><span class="line">		<span class="comment">// 3、创建异常收集器</span></span><br><span class="line">		<span class="type">ThrowableCollector</span> <span class="variable">throwableCollector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OpenTest4JAwareThrowableCollector</span>();</span><br><span class="line">		<span class="comment">// 4、创建扩展域对象</span></span><br><span class="line">        <span class="type">ExtensionContext</span> <span class="variable">extensionContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodExtensionContext</span>(context.getExtensionContext(),</span><br><span class="line">			context.getExecutionListener(), <span class="built_in">this</span>, context.getConfigurationParameters(), testInstance,</span><br><span class="line">			throwableCollector);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 5、将“扩展器”、扩展域对象、异常收集器封装到域对象中</span></span><br><span class="line">		<span class="comment">// @formatter:off</span></span><br><span class="line">		<span class="keyword">return</span> context.extend()</span><br><span class="line">				.withExtensionRegistry(registry)</span><br><span class="line">				.withExtensionContext(extensionContext)</span><br><span class="line">				.withThrowableCollector(throwableCollector)</span><br><span class="line">				.build();</span><br><span class="line">		<span class="comment">// @formatter:on</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> JupiterEngineExecutionContext <span class="title function_">execute</span><span class="params">(JupiterEngineExecutionContext context,</span></span><br><span class="line"><span class="params">			DynamicTestExecutor dynamicTestExecutor)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、获取异常收集器</span></span><br><span class="line">		<span class="type">ThrowableCollector</span> <span class="variable">throwableCollector</span> <span class="operator">=</span> context.getThrowableCollector();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 2、下面这段代码描述的就是我们测试方法的生命周期了</span></span><br><span class="line">		<span class="comment">// @formatter:off</span></span><br><span class="line">		invokeBeforeEachCallbacks(context); <span class="comment">//2.1 @RegisterExtention定义的每个测试方法**调用**前的动作</span></span><br><span class="line">			<span class="keyword">if</span> (throwableCollector.isEmpty()) &#123;</span><br><span class="line">				invokeBeforeEachMethods(context); <span class="comment">// 2.2 执行@BeforeEach标注的方法</span></span><br><span class="line">				<span class="keyword">if</span> (throwableCollector.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 2.3 @RegisterExtention定义的每个测试方法**执行**前的动作</span></span><br><span class="line">					invokeBeforeTestExecutionCallbacks(context);</span><br><span class="line">					<span class="keyword">if</span> (throwableCollector.isEmpty()) &#123;</span><br><span class="line">						invokeTestMethod(context, dynamicTestExecutor); <span class="comment">// 2.4 执行测试方法</span></span><br><span class="line">					&#125;</span><br><span class="line">                    <span class="comment">// 2.5 @RegisterExtention定义的每个测试方法**执行**后的动作</span></span><br><span class="line">					invokeAfterTestExecutionCallbacks(context);</span><br><span class="line">				&#125;</span><br><span class="line">				invokeAfterEachMethods(context); <span class="comment">// 2.2 执行@AfterEach标注的方法</span></span><br><span class="line">			&#125;</span><br><span class="line">		invokeAfterEachCallbacks(context); <span class="comment">//2.1 @RegisterExtention定义的每个测试方法**调用**后的动作</span></span><br><span class="line">		<span class="comment">// @formatter:on</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 3、判断是否有异常产生</span></span><br><span class="line">		throwableCollector.assertEmpty();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> context;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeTestMethod</span><span class="params">(JupiterEngineExecutionContext context, DynamicTestExecutor dynamicTestExecutor)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、获取扩展域对象</span></span><br><span class="line">		<span class="type">ExtensionContext</span> <span class="variable">extensionContext</span> <span class="operator">=</span> context.getExtensionContext();</span><br><span class="line">        <span class="comment">// 2、获取异常收集器</span></span><br><span class="line">		<span class="type">ThrowableCollector</span> <span class="variable">throwableCollector</span> <span class="operator">=</span> context.getThrowableCollector();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 3、在异常收集器中执行反射调用</span></span><br><span class="line">		throwableCollector.execute(() -&gt; &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 3.1、获取单元测试方法</span></span><br><span class="line">				<span class="type">Method</span> <span class="variable">testMethod</span> <span class="operator">=</span> getTestMethod();</span><br><span class="line">                <span class="comment">// 3.2 获取单元测试类实例</span></span><br><span class="line">				<span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> extensionContext.getRequiredTestInstance();</span><br><span class="line">                <span class="comment">// 3.3 使用调用器进行调用</span></span><br><span class="line">				executableInvoker.invoke(testMethod, instance, extensionContext, context.getExtensionRegistry()); <span class="comment">// ref-5</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">				invokeTestExecutionExceptionHandlers(context.getExtensionRegistry(), extensionContext, throwable);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	...... 省略其他方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>prepare(...)</code>方法就是在准备执行测试方法需要用到的测试类实例、异常收集器和域对象。<code>execute(...)</code>方法封装的是执行单元测试方法的主干流程，从代码中可以看出JUnit5是<code>@BeforeEach</code>和<code>@AfterEach</code>标注的方法看作是单元测试方法的一部分，然后在其上叠加扩展器的方法。下面用一个图展示一下它们的关系。</p>
<p><img src="/images/Junit5%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Junit5源码分析-测试方法生命周期"></p>
<p><code>TestMethodTestDescriptor</code>描述的是一个单元测试方法，所以和测试方法强相关的生命周期动作就在该类的<code>execute(...)</code>方法中执行了。<code>ClassTestDescriptor</code>描述的是一个单元测试类，所以像<code>@BeforeAll</code>和<code>@AfterAll</code>之类的生命周期动作就在该类的<code>before(...)</code>和<code>after(...)</code>方法中执行了，这两个方法分别在<code>NodeTestTask</code>的<code>ref-3</code>和<code>ref-4</code>处执行。</p>
<p>在<code>invokeTestMethod(...)</code>方法的<code>ref-5</code>处会使用调用器来调用单元测试方法，具体方式就是使用Java的反射机制。下面我们看看具体代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.junit.jupiter.engine.execution;</span><br><span class="line"></span><br><span class="line"><span class="meta">@API(status = INTERNAL, since = &quot;5.0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutableInvoker</span> &#123;</span><br><span class="line">    ...... 省略其他</span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Method method, Object target, ExtensionContext extensionContext,</span></span><br><span class="line"><span class="params">			ExtensionRegistry extensionRegistry)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">		Optional&lt;Object&gt; optionalTarget = (target <span class="keyword">instanceof</span> Optional ? (Optional&lt;Object&gt;) target</span><br><span class="line">				: Optional.ofNullable(target));</span><br><span class="line">        <span class="comment">// ref-6</span></span><br><span class="line">		<span class="keyword">return</span> ReflectionUtils.invokeMethod(method, target,</span><br><span class="line">			resolveParameters(method, optionalTarget, extensionContext, extensionRegistry));</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> Object[] resolveParameters(Executable executable, Optional&lt;Object&gt; target,</span><br><span class="line">			ExtensionContext extensionContext, ExtensionRegistry extensionRegistry) &#123;</span><br><span class="line">		<span class="comment">// ref-7</span></span><br><span class="line">		<span class="keyword">return</span> resolveParameters(executable, target, <span class="literal">null</span>, extensionContext, extensionRegistry);</span><br><span class="line">	&#125;</span><br><span class="line">    ...... 省略其他</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在<code>ExecutableInvoker</code>中做的<strong>主要的工作就是解析并获取测试方法需要的参数</strong>，然后就是使用反射工具调用单元测试方法。</p>
<h2 id="四、子节点任务的递归"><a href="#四、子节点任务的递归" class="headerlink" title="四、子节点任务的递归"></a>四、子节点任务的递归</h2><p>当前节点的任务执行完成了，就该递归执行子节点任务了，这个操作在<code>ref-2</code>处。我们先来回顾一下这个段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.junit.platform.engine.support.hierarchical</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NodeTestTask</span>&lt;C <span class="keyword">extends</span> <span class="title class_">EngineExecutionContext</span>&gt; <span class="keyword">implements</span> <span class="title class_">TestTask</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">executeRecursively</span><span class="params">()</span> &#123;</span><br><span class="line">        ...... 省略</span><br><span class="line">		throwableCollector.execute(() -&gt; &#123;</span><br><span class="line">			...... 省略</span><br><span class="line">			<span class="keyword">if</span> (!children.isEmpty()) &#123;</span><br><span class="line">				children.forEach(child -&gt; child.setParentContext(context));</span><br><span class="line">				taskContext.getExecutorService().invokeAll(children); <span class="comment">// ref-2</span></span><br><span class="line">			&#125;</span><br><span class="line">            ...... 省略</span><br><span class="line">		&#125;);</span><br><span class="line">        ...... 省略</span><br><span class="line">	&#125;</span><br><span class="line">    ...... 省略其他方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ref-2</code>处其实是两个动作，首先<code>taskContext.getExecutorService()</code>获取执行器服务，具体获取到的是<code>SameThreadHierarchicalTestExecutorService</code>实例。第二个动作就是调用执行器服务的<code>invokeAll(...)</code>函数了。</p>
<p><code>SameThreadHierarchicalTestExecutorService</code>的<code>invokeAll(...)</code>函数比较简单，下面我们看下具体的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.junit.platform.engine.support.hierarchical;</span><br><span class="line"></span><br><span class="line"><span class="meta">@API(status = EXPERIMENTAL, since = &quot;1.3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SameThreadHierarchicalTestExecutorService</span> <span class="keyword">implements</span> <span class="title class_">HierarchicalTestExecutorService</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Future&lt;Void&gt; <span class="title function_">submit</span><span class="params">(TestTask testTask)</span> &#123;</span><br><span class="line">		testTask.execute();</span><br><span class="line">		<span class="keyword">return</span> completedFuture(<span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeAll</span><span class="params">(List&lt;? extends TestTask&gt; tasks)</span> &#123;</span><br><span class="line">		tasks.forEach(TestTask::execute); </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// nothing to do</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>invokeAll(...)</code>方法中直接使用<code>forEach</code>语法遍历子任务并调用<code>execute(...)</code>方法。</p>
<p>其实还有和ForkJoinPoolHierarchicalTestExecutorService类型执行器服务，可以并行执行单元测试。下面我们看下这两种类型执行器的继承层次结构：</p>
<img src="/images/JUnit5源码分析-执行器服务类型继承层次.png" alt="image-20220819134925395" style="zoom:50%;" />

<p>在<code>HierarchicalTestExecutorService</code>接口中定义了<code>submit(...)</code>、<code>invokeAll(...)</code>、<code>close</code>方法。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1、idea插件源码：<a href="https://github.com/JetBrains/intellij-community">https://github.com/JetBrains/intellij-community</a></p>
]]></content>
      <categories>
        <category>Java - 测试</category>
      </categories>
      <tags>
        <tag>JUnit5</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker技术原理</title>
    <url>/2022/07/09/Docker%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="一、Docker架构"><a href="#一、Docker架构" class="headerlink" title="一、Docker架构"></a>一、Docker架构</h2><p>Docker包括三个基本概念：</p>
<ul>
<li><strong>镜像（Image）</strong>: Docker 镜像（Image），就相当于是一个 <a href="https://blog.csdn.net/LEON1741/article/details/78159754">root 文件系统</a>。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li>
<li><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li>
<li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</li>
</ul>
<p>Docker 容器通过 Docker 镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类。</p>
<p>Docker 使用<strong>客户端-服务器 (C&#x2F;S) 架构模式</strong>，使用远程API来管理和创建Docker容器。<strong>TestContainer</strong>就是通过Docker Engine的API来创建和操作容器的。Docker架构模式结构如下图所示：</p>
<p><img src="/images/Docker%E7%9A%84CS%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="img"></p>
<span id="more"></span>

<p>下表介绍了架构模式图中涉及到的概念：</p>
<table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Docker 镜像(Images)</td>
<td align="left">Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</td>
</tr>
<tr>
<td align="left">Docker 容器(Container)</td>
<td align="left">容器是独立运行的一个或一组应用，是镜像运行时的实体。</td>
</tr>
<tr>
<td align="left">Docker 客户端(Client)</td>
<td align="left">Docker 客户端通过命令行或者其他工具使用 Docker SDK (<a href="https://docs.docker.com/develop/sdk/">https://docs.docker.com/develop/sdk/</a>) 与 Docker 的守护进程通信。</td>
</tr>
<tr>
<td align="left">Docker 主机(Host)</td>
<td align="left">一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td>
</tr>
<tr>
<td align="left">Docker Registry</td>
<td align="left">Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(<a href="https://hub.docker.com/">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <strong>&lt;仓库名&gt;:&lt;标签&gt;</strong> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <strong>latest</strong> 作为默认标签。</td>
</tr>
<tr>
<td align="left">Docker Machine</td>
<td align="left">Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</td>
</tr>
</tbody></table>
<h2 id="二、Docker-镜像"><a href="#二、Docker-镜像" class="headerlink" title="二、Docker 镜像"></a>二、Docker 镜像</h2><p>我们都知道，操作系统分为 <strong>内核</strong> 和 <strong>用户空间</strong>。对于 <code>Linux</code> 而言，内核启动后，会挂载 <a href="https://blog.csdn.net/LEON1741/article/details/78159754">root文件系统</a>为其提供用户空间支持。而 <strong>Docker 镜像</strong>（<code>Image</code>），就相当于是一个 root文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p>
<p><strong>Docker 镜像</strong> 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变。</p>
<h3 id="rootfs-根文件系统"><a href="#rootfs-根文件系统" class="headerlink" title="rootfs 根文件系统"></a>rootfs 根文件系统</h3><h4 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h4><p>文件系统是os用来明确存储设备（常见的是磁盘，也有基于NAND Flash的固态硬盘）或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。 </p>
<p>文件系统由三部分组成：文件系统的接口，对对象操作和管理的软件集合，对象及属性。从系统角度来看，文件系统是对<a href="https://cloud.tencent.com/product/cfs?from=10680">文件存储</a>设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，当用户不再使用时撤销文件等。</p>
<p>尽管内核是linux的核心，但文件却是用户与操作系统交互所采用的主要工具。这对linux来说尤其如此，这是因为在UNIX传统中，它使用文件I&#x2F;O机制管理硬件设备和数据文件。</p>
<h4 id="根文件系统"><a href="#根文件系统" class="headerlink" title="根文件系统"></a>根文件系统</h4><p>根文件系统首先是内核启动时所mount的第一个文件系统，内核代码映像文件保存在根文件系统中，而系统引导启动程序会在根文件系统挂载之后从中把一些基本的初始化脚本和服务等加载到内存中去运行。</p>
<p>根文件系统首先是一种文件系统，该文件系统不仅具有普通文件系统的存储数据文件的功能，但相对于普通的文件系统，它是内核启动时挂载（mount）的第一个文件系统，内核代码的映像文件保存在根文件系统中，系统引导启动程序会在根文件系统挂载之后从中把一些初始化脚本（如rcS,inittab）和服务加载到内存中去运行。 文件系统和内核是完全独立的两个部分。在嵌入式中移植的内核下载到开发板上，是没有办法真正的启动Linux操作系统的，会出现无法加载文件系统的错误。</p>
<h4 id="根文件系统为什么重要？"><a href="#根文件系统为什么重要？" class="headerlink" title="根文件系统为什么重要？"></a>根文件系统为什么重要？</h4><p>根文件系统之所以在前面加一个”根“，说明它是加载其它文件系统的”根“，那么如果没有这个根，其它的文件系统也就没有办法进行加载的。</p>
<p>根文件系统包含系统启动时所必须的目录和关键性的文件，以及使其他文件系统得以挂载（mount）所必要的文件。例如：</p>
<ol>
<li>init进程的应用程序必须运行在根文件系统上；</li>
<li>根文件系统提供了根目录“&#x2F;”；</li>
<li>linux挂载分区时所依赖的信息存放于根文件系统&#x2F;etc&#x2F;fstab这个文件中；</li>
<li>shell命令程序必须运行在根文件系统上，譬如ls、cd等命令；</li>
</ol>
<p>总之：一套linux体系，只有内核本身是不能工作的，必须要rootfs（上的etc目录下的配置文件、&#x2F;bin &#x2F;sbin等目录下的shell命令，还有&#x2F;lib目录下的库文件等···）相配合才能工作。</p>
<p>Linux启动时，第一个必须挂载的是根文件系统；若系统不能从指定设备上挂载根文件系统，则系统会出错而退出启动。成功之后可以自动或手动挂载其他的文件系统。</p>
<h4 id="Linux内核是怎么挂载根文件系统的？"><a href="#Linux内核是怎么挂载根文件系统的？" class="headerlink" title="Linux内核是怎么挂载根文件系统的？"></a>Linux内核是怎么挂载根文件系统的？</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">init/main.c-&gt;</span><br><span class="line">　start_kernel()-&gt;vfs_caches_init(totalram_pages)–&gt;</span><br><span class="line">　　　mnt_init()–&gt;</span><br><span class="line">　　　　　<span class="comment">/* sysfs用来记录和展示linux驱动模型，sysfs先于rootfs挂载是为全面展示linux驱动模型做好准备 */</span></span><br><span class="line">　　　　　<span class="comment">/* mnt_init()调用sysfs_init()注册并挂载sysfs文件系统，然后调用kobject_create_and_add()创建fs目录 */</span></span><br><span class="line">　　　　　sysfs_init();</span><br><span class="line">　　　　　<span class="comment">/* init_rootfs()注册rootfs，然后调用init_mount_tree()挂载rootfs */</span></span><br><span class="line">　　　　　init_rootfs();</span><br><span class="line">　　　　　init_mount_tree();</span><br></pre></td></tr></table></figure>

<p>1、sysfs文件系统目前还没有挂载到rootfs的某个挂载点上，后续init程序会把sysfs挂载到rootfs的sys挂载点上；</p>
<p>2、rootfs是基于内存的文件系统，所有操作都在内存中完成；也没有实际的存储设备，所以不需要设备驱动程序的参与。基于以上原因，linux在启动阶段使用rootfs文件系统，当磁盘驱动程序和磁盘文件系统成功加载后，<strong>linux系统会将系统根目录从rootfs切换到磁盘文件系统</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">start_kernel</span><br><span class="line">　　vfs_caches_init</span><br><span class="line">　　　　mnt_init</span><br><span class="line">　　　　　　init_rootfs注册rootfs文件系统</span><br><span class="line">　　　　　　init_mount_tree 挂载rootfs文件系统</span><br><span class="line">　　　　　　　　vfs_kern_mount</span><br><span class="line">　　　　　　　　　　mount_fs</span><br><span class="line">　　　　　　　　　　　　type-&gt;mount其实是rootfs_mount</span><br><span class="line">　　　　　　　　　　　　　　mount_nodev</span><br><span class="line">　　　　　　　　　　　　　　　　fill_super 其实是ramfs_fill_super</span><br><span class="line">　　　　　　　　　　　　　　　　　　inode = ramfs_get_inode(sb, <span class="literal">NULL</span>, S_IFDIR | fsi-&gt;mount_opts.mode, <span class="number">0</span>);</span><br><span class="line">　　　　　　　　　　　　　　　　　　sb-&gt;s_root = d_make_root(inode);</span><br><span class="line">　　　　　　　　　　　　　　　　　　　　<span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">name</span> =</span> QSTR_INIT(“/”, <span class="number">1</span>);[<span class="number">1</span>*]</span><br><span class="line">　　　　　　　　　　　　　　　　　　　　__d_alloc(root_inode-&gt;i_sb, &amp;name);</span><br><span class="line">　　　　　　　　　　…</span><br><span class="line">　　　　　　　　　　mnt-&gt;mnt.mnt_root = root;[<span class="number">2</span>*]</span><br><span class="line">　　　　　　　　　　mnt-&gt;mnt.mnt_sb = root-&gt;d_sb;[<span class="number">3</span>*]</span><br><span class="line">　　　　　　　　　　mnt-&gt;mnt_mountpoint = mnt-&gt;mnt.mnt_root;[<span class="number">4</span>*]</span><br><span class="line">　　　　　　　　　　mnt-&gt;mnt_parent = mnt;[<span class="number">5</span>*]</span><br><span class="line">root.mnt = mnt;</span><br><span class="line">　　　　　　　　root.dentry = mnt-&gt;mnt_root;</span><br><span class="line">　　　　　　　　mnt-&gt;mnt_flags |= MNT_LOCKED;</span><br><span class="line">　　　　　　　　set_fs_pwd(current-&gt;fs, &amp;root);</span><br><span class="line">　　　　　　　　set_fs_root(current-&gt;fs, &amp;root);</span><br><span class="line">　　…</span><br><span class="line">　　rest_init</span><br><span class="line">　　<span class="title function_">kernel_thread</span><span class="params">(kernel_init, <span class="literal">NULL</span>, CLONE_FS)</span>;</span><br></pre></td></tr></table></figure>

<p>在执行kernel_init之前，会建立roofs文件系统。</p>
<p>[1*]处设置了根目录的名字为“&#x2F;”； </p>
<p>[2*]处设置了vfsmount中的root目录； </p>
<p>[3*]处设置了vfsmount中的超级块； </p>
<p>[4*]处设置了vfsmount中的文件挂载点，指向了自己； </p>
<p>[5*]处设置了vfsmount中的父文件系统的vfsmount为自己；</p>
<h4 id="根文件系统各个常用目录简介"><a href="#根文件系统各个常用目录简介" class="headerlink" title="根文件系统各个常用目录简介"></a>根文件系统各个常用目录简介</h4><p>正常来说，根文件系统至少包括以下目录：</p>
<ul>
<li>&#x2F;etc&#x2F;：存储重要的配置文件。 </li>
<li>&#x2F;bin&#x2F;：存储常用且开机时必须用到的执行文件。 </li>
<li>&#x2F;sbin&#x2F;：存储着开机过程中所需的系统执行文件。 </li>
<li>&#x2F;lib&#x2F;：存储&#x2F;bin&#x2F;及&#x2F;sbin&#x2F;的执行文件所需的链接库，以及Linux的内核模块。 </li>
<li>&#x2F;dev&#x2F;：存储设备文件。</li>
</ul>
<p>五大目录必须存储在根文件系统上，缺一不可。</p>
<h3 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h3><p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 <code>ISO</code> 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>
<p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<img src="images/Docker分层存储.jpg" alt="img" style="zoom: 67%;" />

<p>下面使用redis镜像来实际查看一下镜像分层存储。执行下面的镜像分析命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image inspect redis</span><br><span class="line">......</span><br><span class="line"><span class="string">&quot;RootFS&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;layers&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Layers&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;sha256:2edcec3590a4ec7f40cf0743c15d78fb39d8326bc029073b41ef9727da6c851f&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:9b24afeb7c2f21e50a686ead025823cd2c6e9730c013ca77ad5f115c079b57cb&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:4b8e2801e0f956a4220c32e2c8b0a590e6f9bd2420ec65453685246b82766ea1&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:529cdb636f61e95ab91a62a51526a84fd7314d6aab0d414040796150b4522372&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:9975392591f2777d6bf4d9919ad1b2c9afa12f9a9b4d260f45025ec3cc9b18ed&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:8e5669d8329116b8444b9bbb1663dda568ede12d3dbcce950199b582f6e94952&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure>

<p>可以看到Layers里面的内容就是具体包含的层。这些层数据存储的位置和其他信息就在上面输出的”GraphDriver”项里面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;GraphDriver&quot;</span>: &#123;</span><br><span class="line">           <span class="string">&quot;Data&quot;</span>: &#123;</span><br><span class="line">               <span class="string">&quot;LowerDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/6d1f6b0b1bedea3ba9db/diff&quot;</span>,</span><br><span class="line">               <span class="string">&quot;MergedDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/6d1f6b0b1bedea3ba9db/merged&quot;</span>,</span><br><span class="line">               <span class="string">&quot;UpperDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/6d1f6b0b1bedea3ba9db/diff&quot;</span>,</span><br><span class="line">               <span class="string">&quot;WorkDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/6d1f6b0b1bedea3ba9db/work&quot;</span></span><br><span class="line">           &#125;,</span><br><span class="line">           <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;overlay2&quot;</span></span><br><span class="line">       &#125;,</span><br></pre></td></tr></table></figure>

<p>我们可以看到这里面存储的就是联合文件系统相关项的信息了。</p>
<h3 id="Union-FS-（联合文件系统）"><a href="#Union-FS-（联合文件系统）" class="headerlink" title="Union FS （联合文件系统）"></a>Union FS （联合文件系统）</h3><p>联合文件系统（<a href="https://en.wikipedia.org/wiki/UnionFS">UnionFS</a>）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。</p>
<p>UnionFS的联合挂载技术可以在一个挂载点同时挂载多个文件系统，将挂载点的原目录与被挂载内容进行整合，使得最终可见的文件系统将会包含整合之后的各层的文件和目录。</p>
<p>联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p>另外，不同 Docker 容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。</p>
<p>Docker 中使用的 AUFS（Advanced Multi-Layered Unification Filesystem）就是一种联合文件系统。 <code>AUFS</code> 支持为每一个成员目录（类似 Git 的分支）设定只读（readonly）、读写（readwrite）和写出（whiteout-able）权限, 同时 <code>AUFS</code> 里有一个类似分层的概念, 对只读权限的分支可以逻辑上进行增量地修改(不影响只读部分的)。</p>
<p>Docker 目前支持的联合文件系统包括 <code>OverlayFS</code>, <code>AUFS</code>, <code>Btrfs</code>, <code>VFS</code>, <code>ZFS</code> 和 <code>Device Mapper</code>。</p>
<p>下面Centos发行版的overlayFS联合文件系统示意图:</p>
<p><img src="/images/overlay2.png" alt="img"></p>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p>
<p>Dockerfile 是一个文本文件，其内包含了一条条的 **指令(Instruction)**，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<p>下面以定制nginx镜像为例，演示Dockerfile使用过程：</p>
<p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> mynginx</span><br><span class="line">$ <span class="built_in">cd</span> mynginx</span><br><span class="line">$ <span class="built_in">touch</span> Dockerfile</span><br></pre></td></tr></table></figure>

<p>其内容为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>

<p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p>
<h2 id="三、Docker-容器"><a href="#三、Docker-容器" class="headerlink" title="三、Docker 容器"></a>三、Docker 容器</h2><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p>
<p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。</p>
<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>
<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <a href="">数据卷（Volume）</a>、或者 <a href="">绑定宿主目录</a>，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>
<p><strong>数据卷</strong>的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>Namespace（命名空间）是Linux内核的一项功能，该功能对内核资源进行分区，使一组进程看到一组资源，而另一组进程看到另一组资源，就好像运行在单独的操作系统中一样。Namespace有很多种，包括下表中列出的7种。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>隔离的资源</th>
</tr>
</thead>
<tbody><tr>
<td>IPC</td>
<td>SystemV IPC(信号量, 消息队列和共享内存) 和 POSIX message queues</td>
</tr>
<tr>
<td>Network</td>
<td>网络设备, 网络栈, 端口等</td>
</tr>
<tr>
<td>Mount</td>
<td>文件挂载点</td>
</tr>
<tr>
<td>PID</td>
<td>进程编号</td>
</tr>
<tr>
<td>User</td>
<td>User &amp; Group IDs</td>
</tr>
<tr>
<td>UTS</td>
<td>主机名和NIS域名</td>
</tr>
<tr>
<td>Cgroup</td>
<td>cgroup的根目录</td>
</tr>
</tbody></table>
<p>比较重要的是network，mount和PID namespace。</p>
<p>每个容器都有自己单独的命名空间，运行在其中的应用都像是在独立的操作系统中运行一样。命名空间保证了容器之间彼此互不影响。</p>
<h3 id="控制组"><a href="#控制组" class="headerlink" title="控制组"></a>控制组</h3><p>Cgroups 是 control groups 的缩写，是Linux内核提供的一种可以限制，记录，隔离进程组(process groups)所使用物理资源的机制。主要功能有：资源限制(Resource limiting)，优先级分配(Prioritization)，资源统计（Accounting)，进程控制（Control）等。只有能控制分配到容器的资源，才能避免当多个容器同时运行时的对系统资源的竞争。</p>
<ul>
<li>资源限制(Resource limiting): Cgroups可以对进程组使用的资源总额进行限制。如对特定的进程进行内存使用上限限制，当超出上限时，会触发OOM。</li>
<li>优先级分配(Prioritization): 通过分配的CPU时间片数量及硬盘IO带宽大小，实际上就相当于控制了进程运行的优先级。</li>
<li>资源统计（Accounting): Cgroups可以统计系统的资源使用量，如CPU使用时长、内存用量等等，这个功能非常适用于计费。</li>
<li>进程控制（Control）：Cgroups可以对进程组执行挂起、恢复等操作。</li>
</ul>
<h3 id="容器的存储组织方式"><a href="#容器的存储组织方式" class="headerlink" title="容器的存储组织方式"></a>容器的存储组织方式</h3><p>综合考虑镜像的层级结构，以及 volume、init-layer、可读写层这些概念，一个完整的、在运行的容器的所有文件系统结构可如下图所示：</p>
<p><img src="/images/%E5%AE%B9%E5%99%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.png" alt="容器文件系统结构"></p>
<p>从图中我们不难看到，除了 echo hello 进程所在的 cgroups 和 namespace 环境之外，容器文件系统其实是一个相对独立的组织。可读写部分(read-write layer 以及 volumes)、init-layer、只读层(read-only layer) 这 3 部分结构共同组成了一个容器所需的下层文件系统，它们通过联合挂载的方式巧妙地表现为一层，使得容器进程对这些层的存在一无所知。</p>
<p>rootfs 是 docker 容器在启动时<strong>内部进程可见的文件系统</strong>，即 docker 容器的根目录。当我们运行docker exec命令进入container的时候看到的文件系统就是rootfs。rootfs 通常包含一个操作系统运行所需的文件系统，例如可能包含典型的类 Unix 操作系统中的目录系统，如 &#x2F;dev、&#x2F;proc、&#x2F;bin、&#x2F;etc、&#x2F;lib、&#x2F;usr、&#x2F;tmp 及运行 docker 容器所需的配置文件、工具等。</p>
<p>就像Linux启动会先用只读模式挂载rootfs，运行完完整性检查之后，再切换成读写模式一样。Docker deamon为container挂载rootfs时，也会先挂载为只读模式，但是与Linux做法不同的是，在挂载完只读的rootfs之后，docker deamon会利用联合挂载技术（Union Mount）在已有的rootfs上再挂一个读写层。container在运行过程中文件系统发生的变化只会写到读写层，并通过whiteout技术隐藏只读层中的旧版本文件。</p>
<p>容器的rootfs分为三个部分:  读写层(rw)、init层(ro+wh)、只读层(ro+wh)</p>
<p><strong>只读层</strong>对于的docker的镜像层, 这部分不可被修改.</p>
<p><strong>init层</strong>它是一个以“-init”结尾的层，夹在只读层和读写层之间。Init 层是 Docker 项目单独生成的一个内部层，专门用来存放 &#x2F;etc&#x2F;hosts、&#x2F;etc&#x2F;resolv.conf 等信息.</p>
<p><strong>读写层</strong>是 rootfs 最上面的一层,它的挂载方式为：rw，即 read write。在没有写入文件之前，这个目录是空的。而一旦在容器里做了写操作，你修改产生的内容就会以增量的方式出现在这个层中。 删除文件的话 ,AuFS 会在可读写层创建一个 whiteout 文件，把只读层里的文件“遮挡”起来。比如，你要删除只读层里一个名叫 foo 的文件，那么这个删除操作实际上是在可读写层创建了一个名叫.wh.foo 的文件。这样，当这两个层被联合挂载之后，foo 文件就会被.wh.foo 文件“遮挡”起来，“消失”了。这个功能，就是“ro+wh”的挂载方式，即只读 +whiteout 的含义</p>
<p><strong>容器存储层</strong></p>
<p>容器存储层会存储容器运行过程中产生的所有改变，对应到上边讲的rootfs的读写层。因为这一层是运行中容器与源Docker镜像唯一的不同，因此由同一个镜像创建的任意数量容器都可以共享相同的底层镜像，并且同时可以维持他们自己的独立状态。</p>
<img src="/images/Docker容器层结构图.png" alt="Docker容器层结构图" style="zoom:50%;" />



<h3 id="数据卷的实现原理"><a href="#数据卷的实现原理" class="headerlink" title="数据卷的实现原理"></a>数据卷的实现原理</h3><h4 id="Volume-挂载"><a href="#Volume-挂载" class="headerlink" title="Volume 挂载"></a>Volume 挂载</h4><p>容器技术使用了 rootfs 机制和 Mount Namespace，构建出了一个同宿主机完全隔离开的文件系统环境。这时候，我们就需要考虑这样两个问题：</p>
<ol>
<li>容器里进程新建的文件，怎么才能让宿主机获取到？</li>
<li>宿主机上的文件和目录，怎么才能让容器里的进程访问到？</li>
</ol>
<p>这正是 Docker Volume 要解决的问题：Volume 机制，允许你将宿主机上指定的目录或者文件，挂载到容器里面进行读取和修改操作。</p>
<p>在 Docker 项目里，它支持两种 Volume 声明方式，可以把宿主机目录挂载进容器的 &#x2F;test 目录当中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -v /test ...</span><br><span class="line">$ docker run -v /home:/test ...</span><br></pre></td></tr></table></figure>

<p>而这两种声明方式的本质，实际上是相同的：都是把一个宿主机的目录挂载进了容器的 &#x2F;test 目录。<br>只不过，在第一种情况下，由于你并没有显示声明宿主机目录，那么 Docker 就会默认在宿主机上创建一个临时目录 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;[VOLUME_ID]&#x2F;_data，然后把它挂载到容器的 &#x2F;test 目录上。而在第二种情况下，Docker 就直接把宿主机的 &#x2F;home 目录挂载到容器的 &#x2F;test 目录上.</p>
<h4 id="绑定挂载"><a href="#绑定挂载" class="headerlink" title="绑定挂载"></a>绑定挂载</h4><p>那么，Docker 又是如何做到把一个宿主机上的目录或者文件，挂载到容器里面去呢？</p>
<p>当容器进程被创建之后，尽管开启了 Mount Namespace，但是在它执行 chroot（或者 pivot_root）之前，容器进程一直可以看到宿主机上的整个文件系统。</p>
<p>而宿主机上的文件系统，也自然包括了我们要使用的容器镜像。这个镜像的各个层，保存在 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;diff 目录下，在容器进程启动后，它们会被联合挂载在 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;mnt&#x2F; 目录中，这样容器所需的 rootfs 就准备好了。<br>所以，我们只需要在 rootfs 准备好之后，在执行 chroot 之前，把 Volume 指定的宿主机目录（比如 &#x2F;home 目录），挂载到指定的容器目录（比如 &#x2F;test 目录）在宿主机上对应的目录（即 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;mnt&#x2F;[可读写层 ID]&#x2F;test）上，这个 Volume 的挂载工作就完成了。</p>
<p>更重要的是，由于执行这个挂载操作时，“容器进程”已经创建了，也就意味着此时 Mount Namespace 已经开启了。所以，这个挂载事件只在这个容器里可见。你在宿主机上，是看不见容器内部的这个挂载点的。这就保证了容器的隔离性不会被 Volume 打破。</p>
<p>注意：这里提到的 “ 容器进程 “，是 Docker 创建的一个容器初始化进程 (dockerinit)，而不是应用进程 (ENTRYPOINT + CMD)。dockerinit 会负责完成根目录的准备、挂载设备和目录、配置 hostname 等一系列需要在容器内进行的初始化操作。最后，它通过 execv() 系统调用，让应用进程取代自己，成为容器里的 PID&#x3D;1 的进程。</p>
<p>而这里要使用到的挂载技术，就是 Linux 的<strong>绑定挂载（bind mount）机制</strong>，对应的Linux命令为<code>mount --bind olddir newdir</code>。它的主要作用就是，允许你将一个目录或者文件，而不是整个设备，挂载到一个指定的目录上。并且，这时你在该挂载点上进行的任何操作，只是发生在被挂载的目录或者文件上，而原挂载点的内容则会被隐藏起来且不受影响。</p>
<p>其实，如果你了解 Linux 内核的话，就会明白，<strong>绑定挂载实际上是一个 inode 替换的过程</strong>。在 Linux 操作系统中，inode 可以理解为存放文件内容的“对象”，而 dentry，也叫目录项，就是访问这个 inode 所使用的“指针”。</p>
<p><img src="/images/Docker%E7%BB%91%E5%AE%9A%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Docker volume 的实现原理(36)_linux"></p>
<p>正如上图所示，mount –bind &#x2F;home &#x2F;test，会将 &#x2F;home 挂载到 &#x2F;test 上。其实相当于将 &#x2F;test 的 dentry，重定向到了 &#x2F;home 的 inode。这样当我们修改 &#x2F;test 目录时，实际修改的是 &#x2F;home 目录的 inode。这也就是为何，一旦执行 umount 命令，&#x2F;test 目录原先的内容就会恢复：因为修改真正发生在的，是 &#x2F;home 目录里。</p>
<p>所以，在一个正确的时机，进行一次绑定挂载，Docker 就可以成功地将一个宿主机上的目录或文件，不动声色地挂载到容器中。</p>
<p>这样，进程在容器里对这个 &#x2F;test 目录进行的所有操作，都实际发生在宿主机的对应目录（比如，&#x2F;home，或者 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;[VOLUME_ID]&#x2F;_data）里，而不会影响容器镜像的内容。</p>
<p>那么，这个 &#x2F;test 目录里的内容，既然挂载在容器 rootfs 的可读写层，它会不会被 docker commit 提交掉呢？<br>也不会。因为容器的镜像操作，比如 docker commit，都是发生在宿主机空间的，而由于 Mount Namespace 的隔离作用，宿主机并不知道这个绑定挂载的存在。所以，在宿主机看来，容器中可读写层的 &#x2F;test 目录（&#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;mnt&#x2F;[可读写层 ID]&#x2F;test），始终是空的。</p>
<p>不过，由于 Docker 一开始还是要创建 &#x2F;test 这个目录作为挂载点，所以执行了 docker commit 之后，你会发现新产生的镜像里，会多出来一个空的 &#x2F;test 目录。毕竟，新建目录操作，又不是挂载操作，Mount Namespace 对它可起不到“障眼法”的作用。</p>
<h3 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h3><p>Docker在安装后自动提供4种网络，可以使用<code>Docker network ls</code>命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">0cfebacda74b   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">322c4224124b   host      host      <span class="built_in">local</span></span><br><span class="line">c69dc8eed0ec   none      null      <span class="built_in">local</span></span><br></pre></td></tr></table></figure>

<p>Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。</p>
<h4 id="docker的4种网络模式"><a href="#docker的4种网络模式" class="headerlink" title="docker的4种网络模式"></a>docker的4种网络模式</h4><table>
<thead>
<tr>
<th>网络模式</th>
<th>配置</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>host</td>
<td>–network host</td>
<td>容器和宿主机共享Network namespace</td>
</tr>
<tr>
<td>container</td>
<td>–network container:NAME_OR_ID</td>
<td>容器和另外一个容器共享Network namespace</td>
</tr>
<tr>
<td>none</td>
<td>–network none</td>
<td>容器有独立的Network<br/>namespace，<br/>namespace，<br/>但并没有对其进行任何网络设置，<br/>如分配veth pair 和网桥连接，</td>
</tr>
<tr>
<td>bridge</td>
<td>–network bridge</td>
<td>默认模式</td>
</tr>
</tbody></table>
<p>下面是4种网络模式的示意图：</p>
<p>​		<img src="/images/Docker%E5%9B%9B%E7%A7%8D%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="在这里插入图片描述"></p>
<h4 id="bridge模式"><a href="#bridge模式" class="headerlink" title="bridge模式"></a>bridge模式</h4><p>当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。</p>
<p>从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。在主机上创建一对虚拟网卡veth pair设备，Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到docker0网桥中。可以通过brctl show命令查看。</p>
<p>bridge模式是docker的默认网络模式，不写–network参数，就是bridge模式。使用docker run -p时，docker实际是在iptables做了DNAT规则，实现端口转发功能。可以使用iptables -t nat -vnL查看。</p>
<p>bridge模式如下图所示：</p>
<p><img src="/images/Docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C-bridge%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="在这里插入图片描述"></p>
<p>假设上图的docker2中运行了一个nginx，大家来想几个问题：</p>
<ul>
<li>同主机间两个容器间是否可以直接通信？比如在docker1上能不能直接访问到docker2的nginx站点？答：可以。</li>
<li>在宿主机上能否直接访问到docker2的nginx站点？答：不能直接访问，需要端口映射或者配置iptables转发规则。</li>
<li>在另一台主机上如何访问node1上的这个nginx站点呢？DNAT发布？答：为node1上的nginx容器配置端口映射。</li>
</ul>
<p>Docker网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法通过直接Container-IP访问到容器。如果容器希望外部访问能够访问到，可以通过映射容器端口到宿主主机（端口映射），即docker run创建容器时候通过 -p 或 -P 参数来启用，访问容器的时候就通过[宿主机IP]:[容器端口]访问容器。</p>
<h5 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h5><p>在上文中提到了，在Docker网桥模式下，虚拟网桥Docker0不是一个实际的物理网卡，所以外部网络是访问不到容器IP地址的，外部网络要想访问到容器里面就得做端口映射。端口映射实际是在iptables做了DNAT规则，实现端口转发功能。下面我们就详细看下端口映射的细节。</p>
<p>端口映射结构示意图：</p>
<p><img src="/images/Docker%E7%BD%91%E6%A1%A5%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="img"></p>
<p>Iptables是一个复杂的存在，它里面有表（tables）、链（chains）和规则（rules）构成，我们就简单把它理解成网络数据包路由。在端口映射的时候，它负责把容器网络数据包的源地址转换为宿主机地址。</p>
<h5 id="iptables简述"><a href="#iptables简述" class="headerlink" title="iptables简述"></a>iptables简述</h5><p><a href="https://en.wikipedia.org/wiki/iptables">iptables</a>是Linux内核自带的包过滤防火墙，支持<a href="https://en.wikipedia.org/wiki/Network_address_translation">NAT</a>等诸多功能。iptables由表和规则chain概念组成，Docker中所 用的表包括filter表和nat表（参见上述命令输出结果），这也是iptables中最常用的两个表。iptables是一个复杂的存在，曾 有一本书《<a href="http://book.douban.com/subject/2148593/">linux firewalls</a>》 专门讲解iptables，这里先借用本书 中的一幅图来描述一下ip packets在各个表和chain之间的流转过程：</p>
<p><img src="/images/docker-single-host-networking-iptables.jpg" alt="img{500x165}"></p>
<p>网卡收到的数据包进入到iptables后，做路由选择，本地的包通过INPUT链送往user层应用；转发到其他网口的包通过FORWARD chain；本地产生的数据包在路由选择后，通过OUTPUT chain；最后POSTROUTING chain多用于source nat转换。</p>
<p>iptables在容器网络中最重要的两个功能：</p>
<p>1、限制container间的通信<br>2、将container到外部网络包的源地址换成宿主主机地址(MASQUERADE)</p>
<h5 id="Docker0的“双重身份”"><a href="#Docker0的“双重身份”" class="headerlink" title="Docker0的“双重身份”"></a>Docker0的“双重身份”</h5><p>如何理解Docker0？下图中给出了Docker0的双重身份，并对比物理交换机，来理解一下Docker0这个软网桥。</p>
<p><img src="/images/docker-single-host-networking-docker0.jpg" alt="img{500x165}"></p>
<p><strong>1、从容器视角，网桥（交换机）身份</strong></p>
<p>docker0对于通过veth pair“插在”网桥上的container1和container2来说，首先就是一个二层的交换机的角色：泛洪、维护cam表，在二层转发数据包；同 时由于docker0自身也具有mac地址（这个与纯二层交换机不同），并且绑定了ip(这里是172.17.0.1)，因此在 container中还作为container default路由的默认Gateway而存在。</p>
<p><strong>2、从宿主机视角，网卡身份</strong></p>
<p>物理交换机提供了由硬件实现的高效的背板通道，供连接在交换机上的主机高效实现二层通信；对于开启了三层协议的物理交换机而言，其ip路由的处理 也是由物理交换机管理程序提供的。对于docker0而言，其负责处理二层交换机逻辑以及三层的处理程序其实就是宿主机上的Linux内核 tcp&#x2F;ip协议栈程序。而从宿主机来看，所有docker0从veth（只是个二层的存在，没有绑定ipv4地址）接收到的数据包都会被宿主机 看成从docker0这块网卡（第二个身份，绑定172.17.0.1)接收进来的数据包，尤其是在进入三层时，宿主机上的iptables就会对docker0进来的数据包按照rules进行相应处理（通过一些内核网络设置也可以忽略docker0 brigde数据的处理）。</p>
<h4 id="container模式"><a href="#container模式" class="headerlink" title="container模式"></a>container模式</h4><p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p>
<p>container模式如下图所示：</p>
<p><img src="/images/Docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C-container%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="在这里插入图片描述"></p>
<h4 id="host模式"><a href="#host模式" class="headerlink" title="host模式"></a>host模式</h4><p>如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p>
<p>使用host模式的容器可以直接使用宿主机的IP地址与外界通信，容器内部的服务端口也可以使用宿主机的端口，不需要进行NAT，host最大的优势就是网络性能比较好，但是docker host上已经使用的端口就不能再用了，网络的隔离性不好。<br><img src="/images/Docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C-host%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="在这里插入图片描述"></p>
<h4 id="none模式"><a href="#none模式" class="headerlink" title="none模式"></a>none模式</h4><p>使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。</p>
<p>这种网络模式下容器只有lo回环网络，没有其他网卡。none模式可以在容器创建时通过–network none来指定。这种类型的网络没有办法联网，封闭的网络能很好的保证容器的安全性。</p>
<p>应用场景：</p>
<ul>
<li><p>启动一个容器处理数据，比如转换数据格式</p>
</li>
<li><p>一些后台的计算和处理任务</p>
</li>
</ul>
<p>none模式如下图所示：</p>
<p><img src="/images/Docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C-none%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="在这里插入图片描述"></p>
<h2 id="四、Docker-仓库"><a href="#四、Docker-仓库" class="headerlink" title="四、Docker 仓库"></a>四、Docker 仓库</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href="">Docker Registry</a> 就是这样的服务。</p>
<p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p>
<p>以 <a href="https://hub.docker.com/_/ubuntu">Ubuntu 镜像</a> 为例，<code>ubuntu</code> 是仓库的名字，其内包含有不同的版本标签，如，<code>16.04</code>, <code>18.04</code>。我们可以通过 <code>ubuntu:16.04</code>，或者 <code>ubuntu:18.04</code> 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 <code>ubuntu</code>，那将视为 <code>ubuntu:latest</code>。</p>
<p>仓库名经常以 <em>两段式路径</em> 形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p>
<h3 id="Docker-Registry-公开服务"><a href="#Docker-Registry-公开服务" class="headerlink" title="Docker Registry 公开服务"></a>Docker Registry 公开服务</h3><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>
<h3 id="私有-Docker-Registry"><a href="#私有-Docker-Registry" class="headerlink" title="私有 Docker Registry"></a>私有 Docker Registry</h3><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a href="https://hub.docker.com/_/registry/">Docker Registry</a> 镜像，可以直接使用做为私有 Registry 服务。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>上文中我们已经对Docker镜像、容器、仓库有了大致的了解，下面就让我们回顾一下Docker创建容器的完整过程，方便把所有的知识串起来。</p>
<p>docker创建容器过程如下图所示：<br><img src="/images/Docker%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8%E8%BF%87%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="https://ithelp.ithome.com.tw/upload/images/20200912/20025481WAftFZXMHY.png"></p>
<p>要创建Docker容器，首先得通过Docker客户端命令（一般情况）向Docker守护进程下发请求，然后守护进程会在本地检索镜像，如果没有检索到就会去远端镜像仓库拉取镜像，获得镜像后就会启动初始进程准备容器运行的文件系统、网络、可读写层等，最后启动容器应用进程替代初始化进程自身。</p>
<h2 id="参考资料与资源汇总"><a href="#参考资料与资源汇总" class="headerlink" title="参考资料与资源汇总"></a>参考资料与资源汇总</h2><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://tonybai.com/2016/01/15/understanding-container-networking-on-single-host/">理解Docker单机容器网络</a></li>
<li><a href="https://www.docker.org.cn/docker/205.html">Docker源码分析之整体架构图</a></li>
</ul>
<h3 id="菜鸟教程"><a href="#菜鸟教程" class="headerlink" title="菜鸟教程"></a>菜鸟教程</h3><ul>
<li>Docker教程： <a href="https://www.runoob.com/docker/docker-tutorial.html">https://www.runoob.com/docker/docker-tutorial.html</a></li>
</ul>
<h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><p>《Docker源码分析》</p>
<h3 id="Docker资源"><a href="#Docker资源" class="headerlink" title="Docker资源"></a>Docker资源</h3><ul>
<li>Docker 官方主页: <a href="https://www.docker.com/">https://www.docker.com</a></li>
<li>Docker 中文官网: <a href="https://www.docker.org.cn/index.html">https://www.docker.org.cn/index.html</a></li>
<li>Docker 官方博客: <a href="https://blog.docker.com/">https://blog.docker.com/</a></li>
<li>Docker 官方文档: <a href="https://docs.docker.com/">https://docs.docker.com/</a></li>
<li>Docker Store: <a href="https://store.docker.com/">https://store.docker.com</a></li>
<li>Docker Cloud: <a href="https://cloud.docker.com/">https://cloud.docker.com</a></li>
<li>Docker Hub: <a href="https://hub.docker.com/">https://hub.docker.com</a></li>
<li>Docker 的源代码仓库: <a href="https://github.com/moby/moby">https://github.com/moby/moby</a></li>
<li>Docker 发布版本历史: <a href="https://docs.docker.com/release-notes/">https://docs.docker.com/release-notes/</a></li>
<li>Docker 常见问题: <a href="https://docs.docker.com/engine/faq/">https://docs.docker.com/engine/faq/</a></li>
<li>Docker 远端应用 API: <a href="https://docs.docker.com/develop/sdk/">https://docs.docker.com/develop/sdk/</a></li>
</ul>
<h3 id="Docker国内镜像"><a href="#Docker国内镜像" class="headerlink" title="Docker国内镜像"></a>Docker国内镜像</h3><ul>
<li>阿里云的加速器：<a href="https://help.aliyun.com/document_detail/60750.html">https://help.aliyun.com/document_detail/60750.html</a></li>
<li>网易加速器：<a href="http://hub-mirror.c.163.com/">http://hub-mirror.c.163.com</a></li>
<li>官方中国加速器：<a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></li>
<li>ustc 的镜像：<a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></li>
<li>daocloud：<a href="https://www.daocloud.io/mirror#accelerator-doc%EF%BC%88%E6%B3%A8%E5%86%8C%E5%90%8E%E4%BD%BF%E7%94%A8%EF%BC%89">https://www.daocloud.io/mirror#accelerator-doc（注册后使用）</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟化 - 容器</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>基础知识</title>
    <url>/2022/07/03/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="一、基本数据类型及其封装类型"><a href="#一、基本数据类型及其封装类型" class="headerlink" title="一、基本数据类型及其封装类型"></a>一、基本数据类型及其封装类型</h2><p>Java基本类型共有八种，基本类型可以分为三类，字符类型char，布尔类型boolean以及数值类型byte、short、int、long、float、double。数值类型又可以分为整数类型byte、short、int、long和浮点数类型float、double。JAVA中的数值类型不存在无符号的，它们的取值范围是固定的，不会随着机器硬件环境或者<a href="http://lib.csdn.net/base/operatingsystem">操作系统</a>的改变而改变。实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。</p>
<span id="more"></span>

<p>8种类型表示范围如下：</p>
<table>
<thead>
<tr>
<th>简单类型</th>
<th>二进制位数</th>
<th>封装器类型</th>
<th>最大存储数据量</th>
<th>存储范围</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>1</td>
<td>Boolean</td>
<td></td>
<td>true或者false</td>
</tr>
<tr>
<td>byte</td>
<td>8</td>
<td>Byte</td>
<td>255</td>
<td>-128~127</td>
</tr>
<tr>
<td>char</td>
<td>16</td>
<td>Character</td>
<td></td>
<td></td>
</tr>
<tr>
<td>short</td>
<td>16</td>
<td>Short</td>
<td>65536</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>Int</td>
<td>32</td>
<td>Integer</td>
<td>32次方减1</td>
<td>负的2的31次方到正的2的31次方减1</td>
</tr>
<tr>
<td>long</td>
<td>64</td>
<td>Long</td>
<td>2的64次方减1</td>
<td>负的2的63次方到正的2的63次方减1</td>
</tr>
<tr>
<td>float</td>
<td>32</td>
<td>Float</td>
<td>——</td>
<td>3.4e-45~1.4e38</td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>Double</td>
<td>——</td>
<td>4.9e-324~1.8e308</td>
</tr>
<tr>
<td>void</td>
<td>——</td>
<td>Void</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Java决定了每种简单类型的大小。这些大小并不随着机器结构的变化而变化。这种大小的不可更改正是Java程序具有很强移植能力的原因之一。下表列出了Java中定义的简单类型、占用二进制位数及对应的封装器类。</p>
<p>对于数值类型的基本类型的取值范围，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了。如：</p>
<p>基本类型byte 二进制位数：Byte.SIZE 最小值：Byte.MIN_VALUE 最大值：Byte.MAX_VALUE</p>
<p>基本类型short二进制位数：Short.SIZE 最小值：Short.MIN_VALUE 最大值：Short.MAX_VALUE</p>
<p>基本类型char二进制位数：Character.SIZE 最小值：Character.MIN_VALUE 最大值：Character.MAX_VALUE</p>
<p>基本类型double 二进制位数：Double.SIZE 最小值：Double.MIN_VALUE 最大值：Double.MAX_VALUE</p>
<p><strong>注意</strong>：float、double两种类型的最小值与Float.MIN_VALUE、 Double.MIN_VALUE的值并不相同，实际上Float.MIN_VALUE和Double.MIN_VALUE分别指的是 float和double类型所能表示的最小正数。也就是说存在这样一种情况，0到±Float.MIN_VALUE之间的值float类型无法表示，0 到±Double.MIN_VALUE之间的值double类型无法表示。这并没有什么好奇怪的，因为这些范围内的数值超出了它们的精度范围。</p>
<p>Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的”E+数字”表示E之前的数字要乘以10的多少倍。比如3.14E3就是3.14×1000&#x3D;3140，3.14E-3就是3.14&#x2F;1000&#x3D;0.00314。</p>
<p>Java基本类型存储在栈中，因此它们的存取速度要快于存储在堆中的对应包装类的实例对象。从Java5.0（1.5）开始，JAVA虚拟机（Java Virtual Machine）可以完成基本类型和它们对应包装类之间的自动转换。因此我们在赋值、参数传递以及数学运算的时候像使用基本类型一样使用它们的包装类，但这并不意味着你可以通过基本类型调用它们的包装类才具有的方法。另外，所有基本类型（包括void）的包装类都使用了final修饰，因此我们无法继承它们扩展新的类，也无法重写它们的任何方法。</p>
<p>基本类型的优势：数据存储相对简单，运算效率比较高</p>
<p>包装类型的优势：有的地方必须使用包装器类型，比如集合的元素必须是对象类型，满足了java一切皆是对象的思想</p>
<h2 id="二、自动装箱与拆箱"><a href="#二、自动装箱与拆箱" class="headerlink" title="二、自动装箱与拆箱"></a>二、自动装箱与拆箱</h2><p>简单一点说，装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。</p>
<h2 id="三、运算符"><a href="#三、运算符" class="headerlink" title="三、运算符"></a>三、运算符</h2><p>Java运算符按功能可分为：算数运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和条件运算符。</p>
<h3 id="3-1-算数运算符"><a href="#3-1-算数运算符" class="headerlink" title="3.1 算数运算符"></a>3.1 算数运算符</h3><p>算术运算符包括通常的加（+）、减（-）、乘（*）、除（&#x2F;）、取模（%），完成整数型和浮点型数据的算术运算。</p>
<p>许多语言中的取模运算只能用于整数型，Java对此做了扩展，它允许对浮点数进行取模操作。例如，3%2 的结果是 1, 15.2%5 的结果是 0.2。取模操作还可以用于负数，结果的符号与第一个操作数的符号相同，例如，5%-3 的结果是 2，-5%3 的结果是-2。</p>
<p>此外，算术运算符还有“++”和“–”两种，分别称为加1和减1运算符。这两种运算符有前缀形式和后缀形式，含有有所不同。例如，i++ 和 ++i 的执行顺序是不一样的，i++ 在 i 使用之后再 +1，++i 在 i 使用之前先 +1。i– 和 –i 的情况于此类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">System.out.println(i++); <span class="comment">// i++, 使用之后 +1, 此处输出1</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">System.out.println(++i); <span class="comment">// ++i, 先+1再使用，此处输出2</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">System.out.println(i--); <span class="comment">// i--, 使用之后-1, 此处输出1</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">System.out.println(--i); <span class="comment">// --i, 先-1再使用，此处输出0</span></span><br></pre></td></tr></table></figure>



<h3 id="3-2-关系运算符"><a href="#3-2-关系运算符" class="headerlink" title="3.2 关系运算符"></a>3.2 关系运算符</h3><p>关系运算符用来比较两个值，包括大于（&gt;）、小于（&lt;）、大于等于（&gt;&#x3D;）、小于等于（&lt;&#x3D;）、等于（&#x3D;&#x3D;）和不等于（!&#x3D;）6种。关系运算符都是二元运算符，也就是每个运算符都带有两个操作数，运算的结果是一个逻辑值。Java允许“&#x3D;&#x3D;”和“!&#x3D;”两种运算符用于任何数据类型。例如，既可以判断两个数的值是否相等，也可以判断对象或数组的实例是否相等。判断实例时比较的是两个对象在内存中的引用地址是否相等。</p>
<h3 id="3-3-逻辑运算符"><a href="#3-3-逻辑运算符" class="headerlink" title="3.3 逻辑运算符"></a>3.3 逻辑运算符</h3><p>逻辑运算符包括逻辑与（&amp;&amp;）、逻辑或（||）和逻辑非（!）。前两个是二元运算符，后一个是一元运算符。Java对逻辑与和逻辑或提供“短路”功能，也就是在进行运算时，先计算运算符左侧的表达式的值，如果使用该值能得到整个表达式的值，则跳过运算符右侧表达式的计算，否则计算运算符右侧表达式，并得到整个表达式的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 逻辑与 &amp;&amp;， 有一个表达式的结果是false，整体结果就是false</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (str != <span class="literal">null</span> &amp;&amp; str.length() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// str是null, &amp;&amp;左侧表达式的结果是false, 不会计算&amp;&amp;右侧表达式，直接整体返回false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (str != <span class="literal">null</span> &amp;&amp; str.length() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="comment">// &amp;&amp;左侧表达式的结果是true, 会接着计算&amp;&amp;右侧的表达式，右侧表达式的值是false, 整个if中的表达式的结果就是返回false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逻辑或 ||， 有一个表达式的结果是true，整体就返回true。</span></span><br><span class="line">str = <span class="string">&quot;qq&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// || 左侧的表达式的结果是false, 会接着计算 || 右侧的表达式，右侧结果是true，则整体返回true。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str != <span class="literal">null</span> || str.length() == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// || 左侧的表达式的结果是true, 不会计算 || 右侧的表达式，直接整体返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逻辑非!, 表达式结果是true, 就返回false; 表达式结果是false，就返回true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">System.out.println(!flag); <span class="comment">// 输出false</span></span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line">System.out.println(!flag); <span class="comment">// 输出true;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-位运算符"><a href="#3-4-位运算符" class="headerlink" title="3.4 位运算符"></a>3.4 位运算符</h3><p>位运算符用来对二进制位进行操作，包括按位取反（~）、按位与（&amp;）、按位或（|）、异或（^）、右移（&gt;&gt;）、左移（&lt;&lt;）和无符号右移（&gt;&gt;&gt;）。位运算符只能对整数型和字符型数据进行操作。</p>
<p><strong>取反（~）</strong></p>
<p>参加运算的一个数据，按二进制位进行“取反”运算。</p>
<p>运算规则：~1&#x3D;0； ~0&#x3D;1；</p>
<p>即：对一个二进制数按位取反，即将0变1，1变0。</p>
<p><strong>按位与（&amp;）</strong></p>
<p>参加运算的两个数据，按二进制位进行“与”运算。</p>
<p>运算规则：0&amp;0&#x3D;0; 0&amp;1&#x3D;0; 1&amp;0&#x3D;0; 1&amp;1&#x3D;1；即：两位同时为“1，结果才为“1，否则为0。</p>
<p>例如：3&amp;5 即 0000 0011 &amp; 0000 0101 &#x3D; 0000 0001 因此，3 &amp; 5的值得1。</p>
<p><strong>按位或（|）</strong></p>
<p>参加运算的两个对象，按二进制位进行“或”运算。</p>
<p>运算规则：0 | 0&#x3D;0； 0 | 1&#x3D;1； 1 | 0&#x3D;1； 1 | 1&#x3D;1；</p>
<p>即 ：参加运算的两个对象只要有一个为1，其值为1。</p>
<p>例如：3 | 5，即 0000 0011 | 0000 0101 &#x3D; 0000 0111 因此，3 | 5的值得7。</p>
<p><strong>异或（^）</strong></p>
<p>参加运算的两个数据，按二进制位进行“异或”运算。</p>
<p>运算规则：0^0&#x3D;0； 0^1&#x3D;1； 1^0&#x3D;1； 1^1&#x3D;0；</p>
<p>即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。</p>
<p><strong>左移（&lt;&lt;）</strong></p>
<p>运算规则：按二进制形式把所有的数字向左移动对应的位数，高位移出（舍弃），低位的空位补零。例如： 12345 &lt;&lt; 1，则是将数字12345左移1位：</p>
<p><img src="/images/1ad5ad6eddc451da078a1edf5b646c60d0163221.jpeg" alt="img"></p>
<p>位移后十进制数值变成：24690，刚好是12345的二倍，所以有些人会用左位移运算符代替乘2的操作，但是这并不代表是真的就是乘以2，很多时候，我们可以这样使用，但是一定要知道，位移运算符很多时候可以代替乘2操作，但是这个并不代表两者是一样的。</p>
<p>思考一下：如果任意一个十进制的数左位移32位，右边补位32个0，十进制岂不是都是0了？当然不是！！！ 当int 类型的数据进行左移的时候，当左移的位数大于等于32位的时候，位数会先求余数，然后再进行左移，也就是说，如果真的左移32位 12345 &lt;&lt; 32 的时候，会先进行位数求余数，即为 12345&lt;&lt;(32%32) 相当于 12345&lt;&lt; 0 ，所以12345&lt;&lt; 33 的值和12345&lt;&lt;1 是一样的，都是 24690。</p>
<p><strong>右移（&gt;&gt;）</strong></p>
<p>同样，还是以12345这个数值为例，12345右移1位： 12345&gt;&gt;1。</p>
<p><img src="/images/d6ca7bcb0a46f21f19ec19641bbd55660d33ae49.jpeg" alt="img"></p>
<p>右移后得到的值为 6172 和int 类型的数据12345除以2取整所得的值一样，所以有些时候也会被用来替代除2操作。另外，对于超过32位的位移，和左移运算符一样，，会先进行位数求余数。</p>
<p><strong>无符号右移（&gt;&gt;&gt;）</strong></p>
<p>无符号右移运算符和右移运算符是一样的，不过无符号右移运算符在右移的时候是补0的，而右移运算符是补符号位的。以下是-12345二进制表示：</p>
<p><img src="/images/21a4462309f790522f7425fafd6ae9cc7acbd52f.jpeg" alt="img"></p>
<p>对于源码、反码、补码不熟悉的同学，请自行学习，这里就不再进行补充了讲解了，这里提醒一下，在右移运算符中，右移后补0，是由于正数 12345 符号位为0 ，如果为1，则应补1。</p>
<p><img src="/images/b17eca8065380cd7f23c4b284ddd933258828171.jpeg" alt="img"></p>
<p><strong>原码、反码和补码说明：</strong></p>
<p>一个数可以分成符号位（0正1负）+ 真值，原码是我们正常想法写出来的二进制。由于计算机只能做加法，负数用单纯的二进制原码书写会出错，于是大家发明了反码（正数不变，负数符号位不变，真值部分取反）；再后来由于+0， -0的争端，于是改进反码，变成补码（正数不变，负数符号位不变，真值部分取反，然后+1）。二进制前面的0都可以省略，所以总结来说：计算机里的负数都是用补码（符号位1，真值部分取反+1）表示的。</p>
<p><strong>位运算符和2的关系</strong></p>
<p>位运算符和乘2、除2在大多数时候是很相似的，可以进行替代，同时效率也会高的多，但是两者切记不能混淆 ；很多时候有人会把两者的概念混淆，尤其是数据刚好是 2、4、6、8、100等偶数的时候，看起来就更相似了，但是对于奇数，如本文使用的12345 ，右移之后结果为6172 ，这个结果就和数学意义上的除以2不同了，不过对于int 类型的数据，除2 会对结果进行取整，所以结果也是6172 ，这就更有迷惑性了。</p>
<h3 id="3-5-赋值运算符"><a href="#3-5-赋值运算符" class="headerlink" title="3.5 赋值运算符"></a>3.5 赋值运算符</h3><p>赋值运算符的作用就是将常量、变量或表达式的值赋给某一个变量。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>运算</th>
<th>范例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>赋值</td>
<td>a&#x3D;3;b&#x3D;3</td>
<td>a&#x3D;3;b&#x3D;2;</td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>加等于</td>
<td>a&#x3D;3;b&#x3D;2;a+&#x3D;b;</td>
<td>a&#x3D;5;b&#x3D;2;</td>
</tr>
<tr>
<td>-&#x3D;</td>
<td>减等于</td>
<td>a&#x3D;3;b&#x3D;2;a-&#x3D;b;</td>
<td>a&#x3D;1;b&#x3D;2;</td>
</tr>
<tr>
<td>*&#x3D;</td>
<td>乘等于</td>
<td>a&#x3D;3;b&#x3D;2;a*&#x3D;b;</td>
<td>a&#x3D;6;b&#x3D;2;</td>
</tr>
<tr>
<td>&#x2F;&#x3D;</td>
<td>除等于</td>
<td>a&#x3D;3;b&#x3D;2;a&#x2F;&#x3D;b;</td>
<td>a&#x3D;1;b&#x3D;2;</td>
</tr>
<tr>
<td>%&#x3D;</td>
<td>模等于</td>
<td>a&#x3D;3;b&#x3D;2;a%&#x3D;b;</td>
<td>a&#x3D;1;b&#x3D;2;</td>
</tr>
</tbody></table>
<p>除了“&#x3D;”，其它的都是特殊的赋值运算符，以“+&#x3D;”为例，x +&#x3D; 3就相当于x &#x3D; x + 3，首先会进行加法运算x+3，再将运算结果赋值给变量x。-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;赋值运算符都可依此类推。</p>
<h3 id="3-6-条件运算符"><a href="#3-6-条件运算符" class="headerlink" title="3.6 条件运算符"></a>3.6 条件运算符</h3><p>条件运算符（ ? : ）也称为 “三元运算符”或“三目运算符”。</p>
<p>语法形式：布尔表达式 ？ 表达式1 ：表达式2。</p>
<p>运算过程：如果布尔表达式的值为true，则返回表达式1的值，否则返回表达式2的值。</p>
<h3 id="3-7-运算符的优先次序"><a href="#3-7-运算符的优先次序" class="headerlink" title="3.7 运算符的优先次序"></a>3.7 运算符的优先次序</h3><p>在对一个表达式进行计算时，如果表达式中含有多种运算符，则要安运算符的优先次序一次从高向低进行。运算符的优先次序如下：</p>
<p><img src="/images/a2cc7cd98d1001e96323d451569745ea55e797f5.png" alt="img"></p>
<h2 id="四、控制执行流程"><a href="#四、控制执行流程" class="headerlink" title="四、控制执行流程"></a>四、控制执行流程</h2><h3 id="4-1-if-else"><a href="#4-1-if-else" class="headerlink" title="4.1 if else"></a>4.1 if else</h3><p>只有一个if</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>一个if 一个else</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个if N个else if 可能可无else</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-for循环"><a href="#4-2-for循环" class="headerlink" title="4.2 for循环"></a>4.2 for循环</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化; 布尔表达式; 运算) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次循环都会进行布尔表达式的判断，布尔表达式为true时，相应的也会执行一次运算，当布尔表达式为false时，循环终止。</p>
<h3 id="4-3-do-while循环"><a href="#4-3-do-while循环" class="headerlink" title="4.3 do while循环"></a>4.3 do while循环</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (布尔表达式) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与do while不同，while是先执行布尔表达式的判断，然后执行代码块，两者的选择就看布尔表达式的位置。</p>
<h3 id="4-4-while循环"><a href="#4-4-while循环" class="headerlink" title="4.4 while循环"></a>4.4 while循环</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (布尔表达式) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与do while不同，while是先执行布尔表达式的判断，然后执行代码块，两者的选择就看布尔表达式的位置。</p>
<h3 id="4-5-break-continue"><a href="#4-5-break-continue" class="headerlink" title="4.5 break continue"></a>4.5 break continue</h3><p>任何迭代语句的代码块部分，都可以用break和continue控制循环的流程</p>
<h3 id="4-5-1-break-终止并跳出循环"><a href="#4-5-1-break-终止并跳出循环" class="headerlink" title="4.5.1 break 终止并跳出循环"></a>4.5.1 break 终止并跳出循环</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] ints = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : ints) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h3 id="4-5-2-continue-结束当次循环，进入下次循环"><a href="#4-5-2-continue-结束当次循环，进入下次循环" class="headerlink" title="4.5.2 continue 结束当次循环，进入下次循环"></a>4.5.2 continue 结束当次循环，进入下次循环</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] ints = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : ints) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//1 3</span></span><br></pre></td></tr></table></figure>

<p>当有多层循环时，break和continue只对当前循环生效。这时候可以用另一种语法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">out:</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : ints) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j : ints) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//1 1 1</span></span><br></pre></td></tr></table></figure>

<p>跳到外层循环继续执行，break的用法也是类似。</p>
<h3 id="4-6-return语句"><a href="#4-6-return语句" class="headerlink" title="4.6 return语句"></a>4.6 return语句</h3><p>方法直接返回，不再执行</p>
<h3 id="4-7-switch语句"><a href="#4-7-switch语句" class="headerlink" title="4.7 switch语句"></a>4.7 switch语句</h3><p>根据值来选择执行的代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (key) &#123;	<span class="comment">//	值</span></span><br><span class="line">    <span class="keyword">case</span> value:	<span class="comment">//	多个case下的value都是唯一的 case块也没有  key与值相等则执行代码块</span></span><br><span class="line">        <span class="keyword">break</span>;	<span class="comment">//	可有可无 有的话直接跳出 没有的话 继续往下执行</span></span><br><span class="line">    <span class="keyword">default</span>:	<span class="comment">//	如果前面都没有执行break 则执行</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、数组"><a href="#五、数组" class="headerlink" title="五、数组"></a>五、数组</h2><h3 id="5-1-数组的定义"><a href="#5-1-数组的定义" class="headerlink" title="5.1 数组的定义"></a>5.1 数组的定义</h3><p>数组是相同类型数据的有序集合。数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。其中，每一个数据称作一个元素，每个元素可以通过一个索引(下标)来访问它们。</p>
<h3 id="5-2-数组的基本特点"><a href="#5-2-数组的基本特点" class="headerlink" title="5.2 数组的基本特点"></a>5.2 数组的基本特点</h3><p>1）长度是确定的。数组一旦被创建，它的大小就是不可以改变的。<br>2）其元素必须是相同类型，不允许出现混合类型。元素的类型可以是java 支持的任意类型<br>3）数组类型可以是任何数据类型，包括基本类型和引用类型。<br>4）数组的元素在堆内存中被分配空间，并且是连续分配的<br>5）使用new 关键字对数组进行 内存的分配。每个元素都会被jvm 赋予默认值。默认规则：整数：0 浮点数：0.0 字符：\u0000 布尔：false 引用数据类型：null。<br>6）数组的元素都是有序号的，序号从0开始，0序的。称作数组的下标、索引、角标</p>
<h3 id="5-3-数组的声明"><a href="#5-3-数组的声明" class="headerlink" title="5.3 数组的声明"></a>5.3 数组的声明</h3><p>1）声明的时候并没有实例化任何对象，只有在实例化数组对象时，JVM才分配空间，这时才与长度有关。<br>2）声明一个数组的时候并没有数组真正被创建。<br>3）构造一个数组，必须指定长度</p>
<h3 id="5-4-数组初始化"><a href="#5-4-数组初始化" class="headerlink" title="5.4  数组初始化"></a>5.4  数组初始化</h3><p>静态初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态初始化：<span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;; <span class="comment">// 静态初始化基本类型数组；</span></span><br></pre></td></tr></table></figure>

<p>动态初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>]; <span class="comment">// 动态初始化数组，先分配空间；</span></span><br><span class="line">arr[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">// 给数组元素赋值；</span></span><br><span class="line">arr[<span class="number">1</span>]=<span class="number">2</span>; <span class="comment">// 给数组元素赋值；</span></span><br></pre></td></tr></table></figure>

<p>默认初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>]; <span class="comment">// 默认值：0,0</span></span><br><span class="line"><span class="type">boolean</span>[] b = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2</span>]; <span class="comment">// 默认值：false,false</span></span><br><span class="line">String[] s = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2</span>]; <span class="comment">// 默认值：null, null</span></span><br></pre></td></tr></table></figure>



<p>例子：</p>
<p><img src="/images/1211462-20180901151338439-769400636.png" alt="img"></p>
<p><img src="/images/1211462-20180901151431717-277396520.png" alt="img"></p>
<h3 id="5-5-数组的遍历"><a href="#5-5-数组的遍历" class="headerlink" title="5.5 数组的遍历"></a>5.5 数组的遍历</h3><p>fo循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="comment">// 初始化数组元素的值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    a[i] = <span class="number">100</span> * i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取元素的值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for-each循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] ss = &#123;<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>, <span class="string">&quot;ddd&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (String temp : ss) &#123;</span><br><span class="line">    System.out.println(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-6-拷贝、删除、扩容操作"><a href="#5-6-拷贝、删除、扩容操作" class="headerlink" title="5.6 拷贝、删除、扩容操作"></a>5.6 拷贝、删除、扩容操作</h3><p>System类里也包含了一个<code>static void arraycopy(object src，int srcpos，object dest， int destpos，int length)</code>方法，该方法可以将src数组里的元素值赋给dest数组的元素，其中srcpos指定从src数组的第几个元素开始赋值，length参数指定将src数组的多少个元素赋给dest数组的元素。</p>
<p>函数原型如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src,  <span class="type">int</span>  srcPos,</span></span><br><span class="line"><span class="params">                                    Object dest, <span class="type">int</span> destPos,</span></span><br><span class="line"><span class="params">                                    <span class="type">int</span> length)</span>;</span><br></pre></td></tr></table></figure>

<p>使用<code>arraycopy</code>函数实现的数组拷贝、删除、扩容操作如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.boom.arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关于数组的操作:拷贝，删除，扩容</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayCopyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        arrayCopy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//        String[] str = &#123; &quot;Java&quot;, &quot;C&quot;, &quot;C++&quot;, &quot;Python&quot;, &quot;JScript&quot; &#125;;</span></span><br><span class="line">        <span class="comment">//        removeElement(str, 1);</span></span><br><span class="line">        <span class="comment">//        </span></span><br><span class="line">        <span class="comment">//        String[] str = &#123; &quot;Java&quot;, &quot;C&quot;, &quot;C++&quot;, &quot;Python&quot;, &quot;JScript&quot; &#125;;</span></span><br><span class="line">        <span class="comment">//        extendRange(str);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的拷贝</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">arrayCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] s1 = &#123; <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;dd&quot;</span>, <span class="string">&quot;ee&quot;</span>, &#125;;</span><br><span class="line">        String[] s2 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">7</span>];</span><br><span class="line">        <span class="comment">// 从s1 里下标为1的数组开始拷贝到s2,存放在s2里下标为2的位置开始，拷贝3个数组。</span></span><br><span class="line">        System.arraycopy(s1, <span class="number">1</span>, s2, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s2.length; i++) &#123;</span><br><span class="line">            System.out.print(s2[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除数组中指定索引的位置,并返回原数组.实则还是拷贝数组，再覆盖原来的数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] removeElement(String[] s, <span class="type">int</span> index) &#123;</span><br><span class="line">        System.arraycopy(s, index + <span class="number">1</span>, s, index, s.length - index - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 特殊处理最后一个数组</span></span><br><span class="line">        s[s.length - <span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">            System.out.print(s[i] + <span class="string">&quot; &quot;</span> + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的扩容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] extendRange(String[] s1)&#123;</span><br><span class="line">        <span class="comment">// 传入的数组基础上空间+3</span></span><br><span class="line">        String[] s2  = <span class="keyword">new</span> <span class="title class_">String</span>[s1.length+<span class="number">3</span>];</span><br><span class="line">        System.arraycopy(s1, <span class="number">0</span>, s2, <span class="number">0</span>, s1.length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;s2.length;i++)&#123;</span><br><span class="line">            System.out.println(s2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-7-java-util-Arrays类"><a href="#5-7-java-util-Arrays类" class="headerlink" title="5.7 java.util.Arrays类"></a>5.7 java.util.Arrays类</h3><p>JDK提供的java.util.Arrays类，包含了常用的数组操作，方便我们日常开发。Arrays类包含了：排序、查找、填充、打印内容等常见的操作。</p>
<p><strong>打印数组</strong><code>Arrays.toString(arr)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a= &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">System.out.println(a); <span class="comment">// 打印数组引用的值</span></span><br><span class="line">System.out.println(Arrays.toString(a)); <span class="comment">// 打印数组元素的值</span></span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[I@15db9742</span><br><span class="line">[1, 2]</span><br></pre></td></tr></table></figure>

<p><strong>数组元素的排序</strong><code>Arrays.toString(arr)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">323</span>, <span class="number">23</span>, <span class="number">543</span>, <span class="number">12</span>, <span class="number">59</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[1, 2, 323, 23, 543, 12, 59]</span><br><span class="line">[1, 2, 12, 23, 59, 323, 543]</span><br></pre></td></tr></table></figure>

<p><strong>二分查找</strong><code>Arrays.binarySearch(arr, key)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">323</span>, <span class="number">23</span>, <span class="number">543</span>, <span class="number">12</span>, <span class="number">59</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">Arrays.sort(arr);  <span class="comment">// 使用二分查找，必须先对数组进行排序</span></span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"><span class="comment">// 返回排序后新的索引位置，若未找到返回负数。</span></span><br><span class="line">System.out.println(<span class="string">&quot;该元素的索引：&quot;</span> + Arrays.binarySearch(arr, <span class="number">12</span>));</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">323</span>, <span class="number">23</span>, <span class="number">543</span>, <span class="number">12</span>, <span class="number">59</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">323</span>, <span class="number">543</span>]</span><br><span class="line">该元素的索引：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>数组填充</strong><code>Arrays.fill(...)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">323</span>, <span class="number">23</span>, <span class="number">543</span>, <span class="number">12</span>, <span class="number">59</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">Arrays.fill(arr, <span class="number">2</span>, <span class="number">4</span>, <span class="number">100</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[1, 2, 323, 23, 543, 12, 59]</span><br><span class="line">[1, 2, 100, 100, 543, 12, 59]</span><br></pre></td></tr></table></figure>

<h3 id="5-8-数组的排序"><a href="#5-8-数组的排序" class="headerlink" title="5.8 数组的排序"></a>5.8 数组的排序</h3><p>数组的排序算法有冒泡排序、选择排序、插入排序、归并排序、快速排序、基数排序、堆排序。</p>
<p><font color="red">TODO 补充上述算法的实现</font></p>
<h3 id="5-9-数组的查找"><a href="#5-9-数组的查找" class="headerlink" title="5.9 数组的查找"></a>5.9 数组的查找</h3><p>数组的查找有遍历搜索、二分查找。</p>
<p><font color="red">TODO 补充上述算法的实现</font></p>
<h3 id="5-10-数组的常见问题"><a href="#5-10-数组的常见问题" class="headerlink" title="5.10 数组的常见问题"></a>5.10 数组的常见问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> []arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">System.out.println(arr[<span class="number">3</span>]); <span class="comment">// ArrayIndexOutofBoundsException</span></span><br><span class="line"><span class="comment">// 当访问到数组中不存在的时下标时：下标越界</span></span><br><span class="line"></span><br><span class="line">arr = <span class="literal">null</span>;</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]); <span class="comment">// NullPointerException</span></span><br><span class="line"><span class="comment">// 当引用类型变量没有指向任何实体时，继续访问引用类型变量，发生空指针异常。</span></span><br><span class="line"></span><br><span class="line">System.out.println(arr); <span class="comment">// [I@3219ab8d:哈希值</span></span><br></pre></td></tr></table></figure>

<h3 id="5-11-数组的内存分析"><a href="#5-11-数组的内存分析" class="headerlink" title="5.11 数组的内存分析"></a>5.11 数组的内存分析</h3><p><img src="/images/20161030125110163.jpeg" alt="img"></p>
<p><img src="/images/20161030125422730.jpeg" alt="img"></p>
<p><img src="/images/1211462-20180901152037185-1093109634.png" alt="img"></p>
<h3 id="5-12-数组的优缺点"><a href="#5-12-数组的优缺点" class="headerlink" title="5.12 数组的优缺点"></a>5.12 数组的优缺点</h3><p><strong>优点</strong></p>
<p>1：可以保存若干个数据。</p>
<p>2：随机访问的效率很高。根据下标访问元素效率高的原因是，元素存放在连续分配的空间上。</p>
<p><strong>缺点</strong></p>
<p>1：数组的元素类型必须一致。</p>
<p>2：连续分配的空间在堆中，如果数组的元素很多，对内存的要求更加严格。</p>
<p>3：根据内容查找元素效率比较低，需要逐个比较个。</p>
<p>4：删除元素、插入元素效率比较低，需要移动大量的元素。</p>
<p>5：数组定长，不能自动扩容。</p>
<p>6：数组没有封装，数组对象只提供了一个数组长度的属性，但是没有提供方法用来操作元素。</p>
<p>java 提供了一整套的 针对不同需求的 对于容器的解决的方案。集合框架部分。不同的容器有不同的特点，满足不同的需求。数组的缺点都会被干掉。</p>
<h3 id="5-13-二维数组"><a href="#5-13-二维数组" class="headerlink" title="5.13 二维数组"></a>5.13 二维数组</h3><p>二维数组实质就是存储元素是一维数组的数组。</p>
<p><strong>二维数组定义：</strong></p>
<p>数组类型[][] 数组名 &#x3D; new 数组类型[一维数组的个数][每一个一维数组中元素的个数];</p>
<p><img src="/images/20161030125652145.jpeg" alt="img"></p>
<p>疑问： 为什么a.length &#x3D; 3, a[0].length &#x3D; 4?</p>
<p><img src="/images/20161030125751375.jpeg" alt="img"></p>
<p><strong>二维数组的初始化：</strong></p>
<p>静态初始化:  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> [][] a = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123; &#123;<span class="number">12</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">89</span>&#125;,&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">78</span>,<span class="number">10</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>动态初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>];   <span class="comment">// 长度为3*4=12</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j &lt; a[i].length; j++) &#123;</span><br><span class="line">        a[i][j] =  ++value; <span class="comment">// 例如：a[1][0] = 4;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="六、字符串"><a href="#六、字符串" class="headerlink" title="六、字符串"></a>六、字符串</h2><p>字符串是内存中连续排列的0个或多个字符。不变字符串是指字符串一旦创建，其内容就不能改变，Java中使用String类来处理不变字符串。</p>
<h3 id="6-1-常量字符串与变量字符串"><a href="#6-1-常量字符串与变量字符串" class="headerlink" title="6.1 常量字符串与变量字符串"></a>6.1 常量字符串与变量字符串</h3><p>Java程序中的字符串分为常量和变量两种，其中，字符串常量使用双引号括起来的一串字符，系统为程序中出现的字符串常量自动创建一个String对象。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这句代码将创建一个String对象，值为“hello world!”。</p>
<p>对于字符串变量，在使用之前要显式声明，并进行初始化。字符串的声明方式有三种：</p>
<p><strong>直接创建</strong>：<code>String str1 = &quot;Hello&quot;;</code></p>
<p>字符串是对象，虽然我们在这里没有用new创建对象，其实是编译器给我们做了这些操作。这种创建的字符串对象有一个特点，如果同样的对象如果存在了，就不会创建一个新的对象，而是指向了同样的对象。例如String str2 &#x3D; “Hello”;，则str1和str2是指向了字符串池中同样的内存地址，即 str1 &#x3D;&#x3D; str2 为true。</p>
<p><strong>使用字符串连接创建：</strong> <code>String str = &quot;Hello&quot; + &quot;World&quot;;</code></p>
<p>这种形式其实可以看做是第一种的形式的特殊形式。 “Hello” + “World”在编译期会被自动折叠为常量“HelloWorld”，所以，最后只会创建一个对象：String str &#x3D; “HelloWorld”;</p>
<p>JDK1.7开始，javac会进行常量折叠，全字面量字符串相加是可以折叠为一个字面常量，而且是进入常量池的。这个问题涉及到了<strong>字符串常量池</strong>和<strong>字符串拼接</strong>。<code>String a=&quot;a&quot;+&quot;b&quot;+&quot;c&quot;;</code>通过编译器优化后，得到的效果是：<code>String a=&quot;abc&quot;;</code></p>
<p><strong>new创建字符串</strong>： <code>String str1 = new String(&quot;Hello&quot;);</code></p>
<p>用new关键字创建的字符串每次都会创建一个新的对象。即使这时创建一个字符串<code>String str2 = new String(&quot;Hello&quot;);</code>，str1与str2是两个对象，str1 &#x3D;&#x3D; str2 为false。</p>
<p><img src="/images/v2-784dc6d3bd25910757178f70f0e67a06_1440w.jpg" alt="img"></p>
<p><strong>注意点：</strong> <code>String str = new String(&quot;Hello&quot;);</code> 会产生几个对象？<br>如果字符串池里面没有“Hello”对象，会在字符串池里面生成一个对象，然后再生成一个字符串对象，str指向这个对象；如果字符串池里面已经有了“Hello”对象，则只会生成一个对象，str指向这个对象。</p>
<h3 id="6-2-字符串不可变性的解释"><a href="#6-2-字符串不可变性的解释" class="headerlink" title="6.2 字符串不可变性的解释"></a>6.2 字符串不可变性的解释</h3><p>面试经常会碰到一个问题，就是String不可变，大部分答的时候会讲因为String的源码里面，它是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br></pre></td></tr></table></figure>

<p>它是被final修饰的，被final修饰的真正含义是什么呢？一定能讲出是不可变，那么到底是什么不可变啊？我们可以来试一试:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span>[] value = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">value = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Error:(<span class="number">33</span>, <span class="number">9</span>) java: 无法为最终变量value分配值</span><br></pre></td></tr></table></figure>

<p>这说明引用不可变，value不能再指向另一个变量，但是这能说明value的值不可变吗？我们再来试试看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span>[] value = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">value[<span class="number">1</span>]=<span class="number">4</span>;</span><br><span class="line">System.out.println(value[<span class="number">0</span>]+<span class="string">&quot; &quot;</span>+value[<span class="number">1</span>]+<span class="string">&quot; &quot;</span>+value[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<p>输出就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>因此，final不可变指的是引用对象不可变，而不是对象的值不可变，那么到底是什么让String对象不可变呢？再去源码看看，是不是还有个private，这个让value的值在外部是不可变的。</p>
<h3 id="6-3-字符串常量池"><a href="#6-3-字符串常量池" class="headerlink" title="6.3 字符串常量池"></a>6.3 字符串常量池</h3><p>作为最基础的引用数据类型，Java 设计者为 String 提供了字符串常量池以提高其性能，那么字符串常量池的具体原理是什么，我们带着以下三个问题，去理解字符串常量池：</p>
<ul>
<li><p>字符串常量池的设计意图是什么？</p>
</li>
<li><p>字符串常量池在哪里？</p>
</li>
<li><p>如何操作字符串常量池？</p>
</li>
</ul>
<h4 id="（1）字符串常量池的设计思想"><a href="#（1）字符串常量池的设计思想" class="headerlink" title="（1）字符串常量池的设计思想"></a>（1）字符串常量池的设计思想</h4><p>字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串使用的非常多。JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。由于String字符串的不可变性，常量池中一定不存在两个相同的字符串。</p>
<p>JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化：</p>
<ul>
<li>为字符串开辟一个字符串常量池，类似于缓存区</li>
<li>创建字符串常量时，首先检查字符串常量池是否存在该字符串</li>
<li>存在该字符串，返回引用实例；不存在，实例化该字符串并放入池中</li>
</ul>
<p>实现的基础如下：</p>
<ul>
<li>实现该优化的基础是因为字符串是不可变的，可以不用担心数据冲突进行共享</li>
<li>运行时实例创建的全局字符串常量池中有一个表，总是为池中每个唯一的字符串对象维护一个引用,这就意味着它们一直引用着字符串常量池中的对象，所以，在常量池中的这些字符串不会被垃圾收集器回收</li>
</ul>
<p>从字符串常量池中获取相应的字符串，代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> “hello”;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> “hello”;</span><br><span class="line"></span><br><span class="line">System.out.printl（<span class="string">&quot;str1 == str2&quot;</span> : str1 == str2 ) <span class="comment">//true </span></span><br></pre></td></tr></table></figure>

<h4 id="（2）字符串常量池在哪里"><a href="#（2）字符串常量池在哪里" class="headerlink" title="（2）字符串常量池在哪里"></a>（2）字符串常量池在哪里</h4><p>在分析字符串常量池的位置时，首先了解一下堆、栈、方法区：</p>
<p><img src="/images/java%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83.png" alt="820e4d34-b89d-33a6-a776-4c088a08d2a9.png"></p>
<p>堆区：</p>
<ul>
<li>存储的是对象，每个对象都包含一个与之对应的class</li>
<li>JVM只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身</li>
<li>对象的由垃圾回收器负责回收，因此大小和生命周期不需要确定</li>
</ul>
<p>栈区：</p>
<ul>
<li>每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)</li>
<li>每个栈中的数据(原始类型和对象引用)都是私有的</li>
<li>栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)</li>
<li>数据大小和生命周期是可以确定的，当没有引用指向数据时，这个数据就会自动消失</li>
</ul>
<p>方法区：</p>
<ul>
<li>静态区，跟堆一样，被所有的线程共享</li>
<li>方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。</li>
</ul>
<p><strong>字符串常量池内存区域</strong></p>
<p>在HotSpot VM中字符串常量池是通过一个StringTable类实现的，它是一个Hash表，默认值大小长度是1009；这个StringTable在每个HotSpot VM的实例中只有一份，被所有的类共享；字符串常量由一个一个字符组成，放在了StringTable上。要注意的是，如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降（因为要一个一个找）。</p>
<p>在JDK6及之前版本，字符串常量池是放在Perm Gen区(也就是方法区)中的，StringTable的长度是固定的1009；在JDK7版本中，字符串常量池被移到了堆中，StringTable的长度可以通过**-XX:StringTableSize&#x3D;66666**参数指定。至于JDK7为什么把常量池移动到堆上实现，原因可能是由于方法区的内存空间太小且不方便扩展，而堆的内存空间比较大且扩展方便。</p>
<p><strong>字符串常量池中存放的内容</strong></p>
<p>在JDK6及之前版本中，String Pool里放的都是字符串常量；在JDK7.0中，由于String.intern()发生了改变，因此String Pool中也可以存放放于堆内的字符串对象的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;AB&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;AB&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;AB&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">System.out.println(s1 == s3); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>由于常量池中不存在两个相同的对象，所以s1和s2都是指向JVM字符串常量池中的”AB”对象。new关键字一定会产生一个对象，并且这个对象存储在堆中。所以String s3 &#x3D; new String(“AB”);产生了两个对象：保存在栈中的s3和保存堆中的String对象。</p>
<p><img src="/images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%86%85%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.jpeg" alt="这里写图片描述"></p>
<p>当执行String s1 &#x3D; “AB”时，JVM首先会去字符串常量池中检查是否存在”AB”对象，如果不存在，则在字符串常量池中创建”AB”对象，并将”AB”对象的地址返回给s1；如果存在，则不创建任何对象，直接将字符串常量池中”AB”对象的地址返回给s1。</p>
<p><strong>字符串对象的创建</strong></p>
<p>面试题：String str4 &#x3D; new String(“abc”) 创建多少个对象？</p>
<p>step 1  在常量池中查找是否有“abc”对象，有则返回对应的引用实例，没有则创建对应的实例对象。</p>
<p>step 2  在堆中 new 一个 String(“abc”) 对象。</p>
<p>step 3  将对象地址赋值给str4,创建一个引用。</p>
<p>所以，常量池中没有“abc”字面量则创建两个对象，否则创建一个对象，以及创建一个引用</p>
<p><strong>延伸</strong></p>
<p>基础类型的变量和常量，变量和引用存储在栈中，常量存储在常量池中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a3</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">INT1</span> <span class="operator">=</span><span class="number">1</span> ;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">INT2</span> <span class="operator">=</span><span class="number">1</span> ;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">INT3</span> <span class="operator">=</span><span class="number">1</span> ;</span><br></pre></td></tr></table></figure>

<p><img src="/images/int%E7%B1%BB%E5%9E%8B%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="798b04f9ga8e2c6779148&amp;690"></p>
<h4 id="（3）字面量和常量池的关系"><a href="#（3）字面量和常量池的关系" class="headerlink" title="（3）字面量和常量池的关系"></a>（3）字面量和常量池的关系</h4><p>字符串对象内部是用字符数组存储的，那么看下面的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会分配一个11长度的char数组，并在常量池分配一个由这个char数组组成的字符串，然后由m去引用这个字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">m</span> <span class="operator">=</span> <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line"><span class="comment">// 用n去引用常量池里边的字符串，所以n和m引用的是同一个对象。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">n</span> <span class="operator">=</span> <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line"><span class="comment">// 生成一个新的字符串，但内部的字符数组引用着m内部的字符数组。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(m);</span><br><span class="line"><span class="comment">// 同样会生成一个新的字符串，但内部的字符数组引用常量池里边的字符串内部的字符数组，意思是和u是同样的字符数组。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello,world&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>使用图来表示的话，情况就大概是这样的(使用虚线只是表示两者其实没什么特别的关系)：</p>
<p><img src="/images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9B%E5%BB%BA%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="string1.png"></p>
<p>测试demo代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">m</span> <span class="operator">=</span> <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">n</span> <span class="operator">=</span> <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(m);</span><br><span class="line"><span class="type">String</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(m == n); <span class="comment">//true </span></span><br><span class="line">System.out.println(m == u); <span class="comment">//false</span></span><br><span class="line">System.out.println(m == v); <span class="comment">//false</span></span><br><span class="line">System.out.println(u == v); <span class="comment">//false </span></span><br></pre></td></tr></table></figure>

<p>通过上述代码得到的结论如下：</p>
<ul>
<li>m和n指向的是同一个对象。</li>
<li>m,u,v都是指向不同的对象。</li>
<li>m,u,v,n但都使用了同样的字符数组，并且用equal判断的话也会返回true。</li>
</ul>
<h3 id="6-4-intern-方法"><a href="#6-4-intern-方法" class="headerlink" title="6.4 intern()方法"></a>6.4 intern()方法</h3><p>直接使用双引号声明出来的String对象会直接存储在字符串常量池中，如果不是用双引号声明的String对象，可以使用String提供的intern方法。intern 方法是一个native方法，intern方法会从字符串常量池中查询当前字符串是否存在，如果存在，就直接返回当前字符串；如果不存在就会将当前字符串放入常量池中，之后再返回。</p>
<p>JDK1.7的改动：</p>
<ol>
<li>将String常量池 从 Perm 区移动到了 Java Heap区</li>
<li>String.intern() 方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象。</li>
</ol>
<p>下面是jdk中<code>intern()</code>方法的详细内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a canonical representation for the string object.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * A pool of strings, initially empty, is maintained privately by the</span></span><br><span class="line"><span class="comment"> * class &#123;<span class="doctag">@code</span> String&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * When the intern method is invoked, if the pool already contains a</span></span><br><span class="line"><span class="comment"> * string equal to this &#123;<span class="doctag">@code</span> String&#125; object as determined by</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> #equals(Object)&#125; method, then the string from the pool is</span></span><br><span class="line"><span class="comment"> * returned. Otherwise, this &#123;<span class="doctag">@code</span> String&#125; object is added to the</span></span><br><span class="line"><span class="comment"> * pool and a reference to this &#123;<span class="doctag">@code</span> String&#125; object is returned.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * It follows that for any two strings &#123;<span class="doctag">@code</span> s&#125; and &#123;<span class="doctag">@code</span> t&#125;,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> s.intern() == t.intern()&#125; is &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> * if and only if &#123;<span class="doctag">@code</span> s.equals(t)&#125; is &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * All literal strings and string-valued constant expressions are</span></span><br><span class="line"><span class="comment"> * interned. String literals are defined in section 3.10.5 of the</span></span><br><span class="line"><span class="comment"> * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  a string that has the same contents as this string, but is</span></span><br><span class="line"><span class="comment"> *          guaranteed to be from a pool of unique strings.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">intern</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>



<p><strong>intern() 的用法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Integer[] DB_DATA = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">10</span> * <span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; DB_DATA.length; i++) &#123;</span><br><span class="line">        DB_DATA[i] = random.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX; i++) &#123;</span><br><span class="line">        <span class="comment">//arr[i] = new String(String.valueOf(DB_DATA[i % DB_DATA.length]));</span></span><br><span class="line">         arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(DB_DATA[i % DB_DATA.length])).intern();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println((System.currentTimeMillis() - t) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行的参数是：-Xmx2g -Xms2g -Xmn1500M 上述代码是一个演示代码，其中有两条语句不一样，一条是未使用 intern，一条是使用 intern。结果如下图</p>
<p>未使用intern，耗时826ms：</p>
<p><img src="/images/%E6%9C%AA%E4%BD%BF%E7%94%A8intern%E8%80%97%E6%97%B6.jpeg" alt="这里写图片描述"></p>
<p>使用intern，耗时2160ms：</p>
<p><img src="/images/%E4%BD%BF%E7%94%A8intern%E8%80%97%E6%97%B6.jpeg" alt="这里写图片描述"></p>
<p>细心的同学会发现使用了 intern 方法后时间上有了一些增长。这是因为程序中每次都是用了 new String 后，然后又进行 intern 操作的耗时时间。</p>
<h3 id="6-5-“-”-连接符"><a href="#6-5-“-”-连接符" class="headerlink" title="6.5 “+” 连接符"></a>6.5 “+” 连接符</h3><h4 id="（1）”-”-链接符的实现原理"><a href="#（1）”-”-链接符的实现原理" class="headerlink" title="（1）”+” 链接符的实现原理"></a>（1）”+” 链接符的实现原理</h4><p>Java语言为“+”连接符以及对象转换为字符串提供了特殊的支持，字符串对象可以使用“+”连接其他对象。其中字符串连接是通过 StringBuilder（或 StringBuffer）类及其append 方法实现的，对象转换为字符串是通过 toString 方法实现的，该方法由 Object 类定义，并可被 Java 中的所有类继承。有关字符连接和转换的更多信息，可以参阅 Gosling、Joy 和 Steele 合著的 《The Java Language Specification》。</p>
<p>我们可以通过反编译验证一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(s + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译后的结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;    <span class="comment">//删除了默认构造函数和字节码</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">byte0</span> <span class="operator">=</span> <span class="number">10</span>;      </span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;      </span><br><span class="line">        System.out.println((<span class="keyword">new</span> <span class="title class_">StringBuilder</span>()).append(s).append(byte0).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上可以看出，Java中使用”+”连接字符串对象时，会创建一个StringBuilder()对象，并调用append()方法将数据拼接，最后调用toString()方法返回拼接好的字符串。由于append()方法的各种重载形式会调用String.valueOf方法，所以我们可以认为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下两者是等价的</span></span><br><span class="line">s = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">s = String.valueOf(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下两者也是等价的</span></span><br><span class="line">s = <span class="string">&quot;abc&quot;</span> + i;</span><br><span class="line">s = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;abc&quot;</span>).append(i).toString();</span><br></pre></td></tr></table></figure>

<h4 id="（2）“-”连接符的效率"><a href="#（2）“-”连接符的效率" class="headerlink" title="（2）“+”连接符的效率"></a>（2）“+”连接符的效率</h4><p>使用“+”连接符时，JVM会隐式创建StringBuilder对象，这种方式在大部分情况下并不会造成效率的损失，不过在进行大量循环拼接字符串时则需要注意。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">    s += <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反编译后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    s = (<span class="keyword">new</span> <span class="title class_">StringBuilder</span>()).append(s).append(<span class="string">&quot;abc&quot;</span>).toString();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样由于大量StringBuilder创建在堆内存中，肯定会造成效率的损失，所以在这种情况下建议在循环体外创建一个StringBuilder对象调用append()方法手动拼接（如上面例子如果使用手动拼接运行时间将缩小到1&#x2F;200左右）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 循环中使用StringBuilder代替“+”连接符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    sb.append(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">sb.toString();</span><br></pre></td></tr></table></figure>

<p>与此之外还有一种特殊情况，也就是当”+”两端均为编译期确定的字符串常量时，编译器会进行相应的优化，直接将两个字符串常量拼接好，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span> + <span class="string">&quot;World&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反编译后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编译期确定</span></span><br><span class="line"><span class="comment"> * 对于final修饰的变量，它在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中。</span></span><br><span class="line"><span class="comment"> * 所以此时的&quot;a&quot; + s1和&quot;a&quot; + &quot;b&quot;效果是一样的。故结果为true。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s0</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; </span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>; </span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + s1;  </span><br><span class="line">System.out.println((s0 == s2)); <span class="comment">//result = true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编译期无法确定</span></span><br><span class="line"><span class="comment"> * 这里面虽然将s1用final修饰了，但是由于其赋值是通过方法调用返回的，那么它的值只能在运行期间确定</span></span><br><span class="line"><span class="comment"> * 因此s0和s2指向的不是同一个对象，故程序执行结果为false。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s0</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; </span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> getS1(); </span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + s1; </span><br><span class="line">System.out.println((s0 == s2)); <span class="comment">//result = false </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getS1</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;b&quot;</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上，“+”连接符对于直接相加的字符串常量效率很高，因为在编译期间便确定了它的值，也就是说形如”I”+“love”+“java”; 的字符串相加，在编译期间便被优化成了”Ilovejava”。对于间接相加（即包含字符串引用，且编译期无法确定值的），形如s1+s2+s3; 效率要比直接相加低，因为在编译器不会对引用变量进行优化。</p>
<h3 id="6-6-字符串的操作"><a href="#6-6-字符串的操作" class="headerlink" title="6.6 字符串的操作"></a>6.6 字符串的操作</h3><p>字符串创建以后，可以使用字符串类中的方法对它进行操作。日常开发中常用的操作字符串的方法有：</p>
<h4 id="（1）String当中与获取相关的常用方法"><a href="#（1）String当中与获取相关的常用方法" class="headerlink" title="（1）String当中与获取相关的常用方法"></a>（1）String当中与获取相关的常用方法</h4><p><code>public int length()</code>：获取字符串当中含有的字符个数，拿到字符串长度。</p>
<p><code>public String concat(String str)</code>：将当前字符串和参数字符串<strong>拼接</strong>成为返回值新的字符串。</p>
<p><code>public char charAt(int index)</code>：获取指定索引位置的单个字符，索引从0开始。</p>
<p><code>public int indexOf(String str)</code>：查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回-1值。</p>
<h4 id="（2）字符串的截取方法"><a href="#（2）字符串的截取方法" class="headerlink" title="（2）字符串的截取方法"></a>（2）字符串的截取方法</h4><p><code>public String substring(int index)</code>：截取从参数位置一直到字符串末尾，返回新字符串。</p>
<p><code>public String substring(int begin, int end)</code>：截取从begin开始，一直到end结束，中间的字符串，不包括end。</p>
<h4 id="（3）字符串转换的方法"><a href="#（3）字符串转换的方法" class="headerlink" title="（3）字符串转换的方法"></a>（3）字符串转换的方法</h4><p><code>public char[] toCharArray()</code>：将当前字符串拆分成为字符数组作为返回值。</p>
<p><code>public byte[] getBytes()</code>：获得当前字符串底层的字节数组。</p>
<p><code>public String replace(CharSequence oldString, CharSequence newString)：</code>用<code>newString</code>替换所有的<code>oldString</code>。</p>
<h4 id="（4）分割字符串"><a href="#（4）分割字符串" class="headerlink" title="（4）分割字符串"></a>（4）分割字符串</h4><p><code>public String[] split(String regex)</code>：按照正则表达式参数的规则，将字符串切分成为若干部分。</p>
<h4 id="（5）字符串的比较"><a href="#（5）字符串的比较" class="headerlink" title="（5）字符串的比较"></a>（5）字符串的比较</h4><p>String字符串可以使用<code>==</code>和<code>equals()</code>方法比较。当两个字符串使用<code>==</code>进行比较时，比较的是两个字符串在内存中的地址。当两个字符串使用<code>equals</code>方法比较时，比较的是两个字符串的值是否相等。</p>
<h3 id="6-7-String、StringBuffer和StringBuilder的关系"><a href="#6-7-String、StringBuffer和StringBuilder的关系" class="headerlink" title="6.7 String、StringBuffer和StringBuilder的关系"></a>6.7 String、StringBuffer和StringBuilder的关系</h3><h4 id="（1）继承结构"><a href="#（1）继承结构" class="headerlink" title="（1）继承结构"></a>（1）继承结构</h4><p><img src="/images/String%E3%80%81StringBuilder%E5%92%8CStringBuffer%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.jpeg" alt="这里写图片描述"></p>
<h4 id="（2）主要区别"><a href="#（2）主要区别" class="headerlink" title="（2）主要区别"></a>（2）主要区别</h4><p>1）String是不可变字符序列，StringBuilder和StringBuffer是可变字符序列。<br>2）执行速度StringBuilder &gt; StringBuffer &gt; String。<br>3）StringBuilder是非线程安全的，StringBuffer是线程安全的。</p>
<h3 id="6-8-总结"><a href="#6-8-总结" class="headerlink" title="6.8 总结"></a>6.8 总结</h3><p>String类是我们使用频率最高的类之一，也是面试官经常考察的题目，下面是一个小测验。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;AB&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;AB&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;B&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;A&quot;</span> + <span class="string">&quot;B&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s3 + s4;</span><br><span class="line">    System.out.println(s1 == s2);</span><br><span class="line">    System.out.println(s1 == s5);</span><br><span class="line">    System.out.println(s1 == s6);</span><br><span class="line">    System.out.println(s1 == s6.intern());</span><br><span class="line">    System.out.println(s2 == s2.intern());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="/images/String%E9%9D%A2%E8%AF%95%E9%A2%98%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpeg" alt="这里写图片描述"></p>
<p>题目解析：真正理解此题目需要清楚以下三点<br>1）直接使用双引号声明出来的String对象会直接存储在常量池中；<br>2）String对象的intern方法会得到字符串对象在常量池中对应的引用，如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用；<br>3） 字符串的+操作其本质是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象用toString方法处理成String对象，这一点可以用javap -c命令获得class文件对应的JVM字节码指令就可以看出来。</p>
<p><img src="/images/String%E9%9D%A2%E8%AF%95%E9%A2%98%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90.jpeg" alt="这里写图片描述"></p>
<h3 id="6-9-参考资料"><a href="#6-9-参考资料" class="headerlink" title="6.9 参考资料"></a>6.9 参考资料</h3><p>​		<a href="https://docs.oracle.com/javase/8/docs/api/">https://docs.oracle.com/javase/8/docs/api/</a><br>​		<a href="https://blog.csdn.net/sinat_19425927/article/details/38663461">https://blog.csdn.net/sinat_19425927/article/details/38663461</a><br>​		<a href="https://www.cnblogs.com/xiaoxi/p/6036701.html">https://www.cnblogs.com/xiaoxi/p/6036701.html</a><br>​		<a href="https://tech.meituan.com/in_depth_understanding_string_intern.html">https://tech.meituan.com/in_depth_understanding_string_intern.html</a></p>
]]></content>
      <categories>
        <category>编程 - 基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>容器进程是怎么启动的？（runc源码分析）</title>
    <url>/2022/08/17/runc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>为了探究标题上的问题，我们先来看看runc启动容器的示例。</p>
<h2 id="一、runc启动容器示例"><a href="#一、runc启动容器示例" class="headerlink" title="一、runc启动容器示例"></a>一、runc启动容器示例</h2><p>依据runc的文档，可以知道启动一个容器有下面的步骤。</p>
<h3 id="1、创建OCI-容器启动包"><a href="#1、创建OCI-容器启动包" class="headerlink" title="1、创建OCI 容器启动包"></a>1、创建OCI 容器启动包</h3><p>使用下面的命令生成rootfs：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create the top most bundle directory</span></span><br><span class="line">$ <span class="built_in">mkdir</span> /mycontainer</span><br><span class="line">$ <span class="built_in">cd</span> /mycontainer</span><br><span class="line"></span><br><span class="line"><span class="comment"># create the rootfs directory</span></span><br><span class="line">$ <span class="built_in">mkdir</span> rootfs</span><br><span class="line"></span><br><span class="line"><span class="comment"># export busybox via Docker into the rootfs directory</span></span><br><span class="line">$ docker <span class="built_in">export</span> $(docker create busybox) | tar -C rootfs -xvf -</span><br></pre></td></tr></table></figure>

<p>roortfs生成之后，只需要在生成规格说明文件config.json，就完成了OCI容器启动包。使用下面的命令可以生成一个基本的config.json文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ runc spec</span><br></pre></td></tr></table></figure>

<span id="more"></span>


<h3 id="2、运行容器"><a href="#2、运行容器" class="headerlink" title="2、运行容器"></a>2、运行容器</h3><p>依据前面的步骤，你已经有了一个OCI容器包，现在你可以有两种方式执行容器。</p>
<p>第一种方式是你可以使用<code>runc</code>命令轻松的创建、开启、删除容器。下面的命令可以开启容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># run as root</span></span><br><span class="line"><span class="built_in">cd</span> /mycontainer</span><br><span class="line">runc run mycontainerid</span><br></pre></td></tr></table></figure>

<p>如果你使用的是没有修改的<code>runc spec</code>生成的config.json模板，那么你将会得到一个运行在容器中的sh会话。</p>
<p>下面是容器启动之后的截图：</p>
<p><img src="/images/runc%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8.png" alt="image-20220805090657093"></p>
<p>第二种开启容器的方式是使用spec声明周期操作，具体的就是修改config.json文件。这种方式可以有效的管理容器的创建和运行。如果移除了config.json中的<code>terminal</code>设置，那么容器就会在后台运行，下面是一个简单的例子。在config.json文件<code>process</code>字段设置<code>&quot;terminal&quot;: false</code> 和 <code>&quot;args&quot;: [&quot;sleep&quot;, &quot;10&quot;]</code>.</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;process&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;terminal&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;uid&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;gid&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;sleep&quot;</span><span class="punctuation">,</span> <span class="string">&quot;10&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;TERM=xterm&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;capabilities&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;bounding&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;CAP_AUDIT_WRITE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;CAP_KILL&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;CAP_NET_BIND_SERVICE&quot;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;effective&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;CAP_AUDIT_WRITE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;CAP_KILL&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;CAP_NET_BIND_SERVICE&quot;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;inheritable&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;CAP_AUDIT_WRITE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;CAP_KILL&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;CAP_NET_BIND_SERVICE&quot;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;permitted&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;CAP_AUDIT_WRITE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;CAP_KILL&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;CAP_NET_BIND_SERVICE&quot;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ambient&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;CAP_AUDIT_WRITE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;CAP_KILL&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;CAP_NET_BIND_SERVICE&quot;</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;rlimits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RLIMIT_NOFILE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;hard&quot;</span><span class="punctuation">:</span> <span class="number">1024</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;soft&quot;</span><span class="punctuation">:</span> <span class="number">1024</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;noNewPrivileges&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>现在我们就可以在shell中进行生命周期操作了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># run as root</span></span><br><span class="line"><span class="built_in">cd</span> /mycontainer</span><br><span class="line">runc create mycontainerid</span><br><span class="line"></span><br><span class="line"><span class="comment"># view the container is created and in the &quot;created&quot; state</span></span><br><span class="line">runc list</span><br><span class="line"></span><br><span class="line"><span class="comment"># start the process inside the container</span></span><br><span class="line">runc start mycontainerid</span><br><span class="line"></span><br><span class="line"><span class="comment"># after 5 seconds view that the container has exited and is now in the stopped state</span></span><br><span class="line">runc list</span><br><span class="line"></span><br><span class="line"><span class="comment"># now delete the container</span></span><br><span class="line">runc delete mycontainerid</span><br></pre></td></tr></table></figure>

<p>下面是执行容器生命周期操作的截图：</p>
<p><img src="/images/runc%E5%AE%B9%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C.png" alt="image-20220805100024378"></p>
<p>这种方式启动容器，可以运行更高层级的系统配置容器创建逻辑。例如，容器的网络栈一般就是在<code>create</code>之后<code>start</code>之前设置的。</p>
<p>接下来我们就看看runc代码中是怎么完成容器生命周期的，下文的源码分析基于runc源码release-1.1版本</p>
<h2 id="二、runc容器创建分析"><a href="#二、runc容器创建分析" class="headerlink" title="二、runc容器创建分析"></a>二、runc容器创建分析</h2><p>runc的命令行是使用urfave&#x2F;cli创建的。</p>
<p>首先在main函数中创建并注册了命令：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    	app := cli.NewApp()</span><br><span class="line">	app.Name = <span class="string">&quot;runc&quot;</span></span><br><span class="line">	app.Usage = usage</span><br><span class="line">    ...... <span class="comment">// 省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册命令</span></span><br><span class="line">    app.Commands = []cli.Command&#123;</span><br><span class="line">		checkpointCommand,</span><br><span class="line">		createCommand, <span class="comment">//  创建容器的命令  // ref-1</span></span><br><span class="line">		deleteCommand,</span><br><span class="line">		eventsCommand,</span><br><span class="line">		execCommand,</span><br><span class="line">		killCommand,</span><br><span class="line">		listCommand,</span><br><span class="line">		pauseCommand,</span><br><span class="line">		psCommand,</span><br><span class="line">		restoreCommand,</span><br><span class="line">		resumeCommand,</span><br><span class="line">		runCommand,</span><br><span class="line">		specCommand,</span><br><span class="line">		startCommand, <span class="comment">// 开启容器的命令  // ref-2</span></span><br><span class="line">		stateCommand,</span><br><span class="line">		updateCommand,</span><br><span class="line">		featuresCommand,</span><br><span class="line">	&#125;</span><br><span class="line">    ...... <span class="comment">// 省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行命令</span></span><br><span class="line">    <span class="keyword">if</span> err := app.Run(os.Args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接下来看看<code>ref-1</code>处的<code>createCommand</code>命令都干了些什么事情？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create.go 文件</span></span><br><span class="line"><span class="keyword">var</span> createCommand = cli.Command&#123;</span><br><span class="line">	Name:  <span class="string">&quot;create&quot;</span>,</span><br><span class="line">	Usage: <span class="string">&quot;create a container&quot;</span>,</span><br><span class="line">	ArgsUsage: <span class="string">`&lt;container-id&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Where &quot;&lt;container-id&gt;&quot; is your name for the instance of the container that you</span></span><br><span class="line"><span class="string">are starting. The name you provide for the container instance must be unique on</span></span><br><span class="line"><span class="string">your host.`</span>,</span><br><span class="line">	Description: <span class="string">`The create command creates an instance of a container for a bundle. The bundle</span></span><br><span class="line"><span class="string">is a directory with a specification file named &quot;`</span> + specConfig + <span class="string">`&quot; and a root</span></span><br><span class="line"><span class="string">filesystem.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The specification file includes an args parameter. The args parameter is used</span></span><br><span class="line"><span class="string">to specify command(s) that get run when the container is started. To change the</span></span><br><span class="line"><span class="string">command(s) that get executed on start, edit the args parameter of the spec. See</span></span><br><span class="line"><span class="string">&quot;runc spec --help&quot; for more explanation.`</span>,</span><br><span class="line">	Flags: []cli.Flag&#123;</span><br><span class="line">		...... <span class="comment">// 省略flag绑定</span></span><br><span class="line">	&#125;,</span><br><span class="line">	Action: <span class="function"><span class="keyword">func</span><span class="params">(context *cli.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := checkArgs(context, <span class="number">1</span>, exactArgs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"> 		<span class="comment">// 执行创建容器命令的函数</span></span><br><span class="line">		status, err := startContainer(context, CT_ACT_CREATE, <span class="literal">nil</span>) <span class="comment">// ref-3</span></span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// exit with the container&#x27;s exit status so any external supervisor</span></span><br><span class="line">			<span class="comment">// is notified of the exit with the correct exit status.</span></span><br><span class="line">			os.Exit(status)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;runc create failed: %w&quot;</span>, err)</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意<code>create</code>命令的<code>Description</code>部分，它指出了<code>runc</code>会依据由<code>rootfs</code>和<code>config.json</code>组成的bundle来创建容器，如果有什么定制化，那么就去修改<code>config.json</code>文件。</p>
<p>我们在<code>createCommand</code>的<code>Action</code>字段看见了处理容器创建命令的真实函数<code>startContainer(context, CT_ACT_CREATE, nil)</code>，也就是代码<code>ref-3</code>处。我们接着往下看。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utils_linux.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startContainer</span><span class="params">(context *cli.Context, action CtAct, criuOpts *libcontainer.CriuOpts)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    ...... <span class="comment">// 省略</span></span><br><span class="line">    <span class="comment">// 获取规格说明</span></span><br><span class="line">	spec, err := setupSpec(context)</span><br><span class="line">	<span class="comment">// 获取传入的容器id</span></span><br><span class="line">	id := context.Args().First()</span><br><span class="line">    ...... <span class="comment">// 省略</span></span><br><span class="line">    <span class="comment">// 加载factory，创建libcontainer.Container对象，实际上就是创建容器需要用到的目录</span></span><br><span class="line">	container, err := createContainer(context, id, spec)</span><br><span class="line">    ...... <span class="comment">// 省略</span></span><br><span class="line">	r := &amp;runner&#123;</span><br><span class="line">		enableSubreaper: !context.Bool(<span class="string">&quot;no-subreaper&quot;</span>),</span><br><span class="line">		shouldDestroy:   !context.Bool(<span class="string">&quot;keep&quot;</span>),</span><br><span class="line">		container:       container,</span><br><span class="line">		listenFDs:       listenFDs,</span><br><span class="line">		notifySocket:    notifySocket,</span><br><span class="line">		consoleSocket:   context.String(<span class="string">&quot;console-socket&quot;</span>),</span><br><span class="line">		detach:          context.Bool(<span class="string">&quot;detach&quot;</span>),</span><br><span class="line">		pidFile:         context.String(<span class="string">&quot;pid-file&quot;</span>),</span><br><span class="line">		preserveFDs:     context.Int(<span class="string">&quot;preserve-fds&quot;</span>),</span><br><span class="line">		action:          action,</span><br><span class="line">		criuOpts:        criuOpts,</span><br><span class="line">		init:            <span class="literal">true</span>,</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 执行容器指定的命令</span></span><br><span class="line">	<span class="keyword">return</span> r.run(spec.Process)  <span class="comment">// ref-4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看看<code>ref-4</code>处的<code>run</code>函数内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utils_linux.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *runner)</span></span> run(config *specs.Process) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">    <span class="comment">// 创建容器进程结构体libcontainer.Process对象</span></span><br><span class="line">	process, err := newProcess(*config) <span class="comment">// ref-5</span></span><br><span class="line">	process.LogLevel = strconv.Itoa(<span class="type">int</span>(logrus.GetLevel()))</span><br><span class="line">	<span class="comment">// Populate the fields that come from runner.</span></span><br><span class="line">	process.Init = r.init</span><br><span class="line">	process.SubCgroupPaths = r.subCgroupPaths</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(r.listenFDs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		process.Env = <span class="built_in">append</span>(process.Env, <span class="string">&quot;LISTEN_FDS=&quot;</span>+strconv.Itoa(<span class="built_in">len</span>(r.listenFDs)), <span class="string">&quot;LISTEN_PID=1&quot;</span>)</span><br><span class="line">		process.ExtraFiles = <span class="built_in">append</span>(process.ExtraFiles, r.listenFDs...)</span><br><span class="line">	&#125;</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="keyword">switch</span> r.action &#123;</span><br><span class="line">	<span class="keyword">case</span> CT_ACT_CREATE:</span><br><span class="line">		err = r.container.Start(process)  <span class="comment">// ref-6</span></span><br><span class="line">	<span class="keyword">case</span> CT_ACT_RESTORE:</span><br><span class="line">		err = r.container.Restore(process, r.criuOpts)</span><br><span class="line">	<span class="keyword">case</span> CT_ACT_RUN:</span><br><span class="line">		err = r.container.Run(process)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;Unknown action&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">    <span class="comment">// 处理信号</span></span><br><span class="line">	status, err := handler.forward(process, tty, detach)</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="keyword">return</span> status, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ref-5</code>处创建了一个代表容器进程的<code>process</code>对象，然后再<code>ref-6</code>处执行了启动，我们看看<code>r.container.Start(process) </code>又干了什么事情？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// libcontainer/container_linux.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *linuxContainer)</span></span> Start(process *Process) <span class="type">error</span> &#123;</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="keyword">if</span> process.Init &#123; <span class="comment">// ref-7</span></span><br><span class="line">        <span class="comment">// 创建用于和子进程通信的fifo文件</span></span><br><span class="line">		<span class="keyword">if</span> err := c.createExecFifo(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := c.start(process); err != <span class="literal">nil</span> &#123; <span class="comment">// ref-8</span></span><br><span class="line">		<span class="keyword">if</span> process.Init &#123;</span><br><span class="line">			c.deleteExecFifo()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ref-7</code>处会判断<code>process</code>是否为容器中的第一个进程，如果是的话，就会调用<code>c.createExecFifo()</code>创建后续与子进程通信的管道。</p>
<p>在<code>ref-8</code>处就会开启容器中的进程process，我们看看runc是怎么开启进程的？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// container_linux.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *linuxContainer)</span></span> start(process *Process) (retErr <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 创建父进程</span></span><br><span class="line">    parent, err := c.newParentProcess(process) <span class="comment">// ref-9</span></span><br><span class="line">	<span class="comment">// 设置同步子进程的日志</span></span><br><span class="line">	logsDone := parent.forwardChildLogs()</span><br><span class="line">	<span class="keyword">if</span> logsDone != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// Wait for log forwarder to finish. This depends on</span></span><br><span class="line">			<span class="comment">// runc init closing the _LIBCONTAINER_LOGPIPE log fd.</span></span><br><span class="line">			err := &lt;-logsDone</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; retErr == <span class="literal">nil</span> &#123;</span><br><span class="line">				retErr = fmt.Errorf(<span class="string">&quot;unable to forward init logs: %w&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := parent.start(); err != <span class="literal">nil</span> &#123; <span class="comment">// ref-10</span></span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to start container process: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ref-9</code>创建了一个父进程，这个可能后面需要好好看看，我们先看下<code>ref-10</code>处的父进程开启操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// process_linux.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *initProcess)</span></span> start() (retErr <span class="type">error</span>) &#123;</span><br><span class="line">	err := p.cmd.Start() <span class="comment">// ref-11 使用系统调用创建了子进程，但是和当前进程并不是父子进程关系</span></span><br><span class="line">	p.process.ops = p</span><br><span class="line">	<span class="comment">// close the write-side of the pipes (controlled by child)</span></span><br><span class="line">	_ = p.messageSockPair.child.Close()</span><br><span class="line">	_ = p.logFilePair.child.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		p.process.ops = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to start init: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">    <span class="comment">// 创建等待子进程完成任务的channel</span></span><br><span class="line">	waitInit := initWaiter(p.messageSockPair.parent)</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">    <span class="comment">// 将启动数据bootstrapData发送给子进程</span></span><br><span class="line">	<span class="keyword">if</span> _, err := io.Copy(p.messageSockPair.parent, p.bootstrapData); err != <span class="literal">nil</span> &#123; <span class="comment">// ref-16</span></span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;can&#x27;t copy bootstrap data to pipe: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	err = &lt;-waitInit <span class="comment">// 等待子进程完成工作</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	childPid, err := p.getChildPid()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;can&#x27;t get final child&#x27;s PID from pipe: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">    <span class="comment">// 创建网卡</span></span><br><span class="line">	<span class="keyword">if</span> err := p.createNetworkInterfaces(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error creating network interfaces: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 更新状态</span></span><br><span class="line">	<span class="keyword">if</span> err := p.updateSpecState(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error updating spec state: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 向子进程发送配置</span></span><br><span class="line">	<span class="keyword">if</span> err := p.sendConfig(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error sending config to init process: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		sentRun    <span class="type">bool</span></span><br><span class="line">		sentResume <span class="type">bool</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	ierr := parseSync(p.messageSockPair.parent, <span class="function"><span class="keyword">func</span><span class="params">(sync *syncT)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="comment">// 处理子进程消息的逻辑	</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 关闭和子进程通信的管道</span></span><br><span class="line">	<span class="keyword">if</span> err := unix.Shutdown(<span class="type">int</span>(p.messageSockPair.parent.Fd()), unix.SHUT_WR); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;os.PathError&#123;Op: <span class="string">&quot;shutdown&quot;</span>, Path: <span class="string">&quot;(init pipe)&quot;</span>, Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>ref-11</code>处的<code>cmd</code>其实是由下面的代码<code>ref-12</code>中指定的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// libcontainer/factory_linux.go 文件</span></span><br><span class="line"><span class="comment">// New returns a linux based container factory based in the root directory and</span></span><br><span class="line"><span class="comment">// configures the factory with the provided option funcs.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(root <span class="type">string</span>, options ...<span class="keyword">func</span>(*LinuxFactory)</span></span> <span class="type">error</span>) (Factory, <span class="type">error</span>) &#123;</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">	l := &amp;LinuxFactory&#123;</span><br><span class="line">		Root:      root,</span><br><span class="line">		InitPath:  <span class="string">&quot;/proc/self/exe&quot;</span>, <span class="comment">// ref-12 执行路径其实就是runc自己</span></span><br><span class="line">		InitArgs:  []<span class="type">string</span>&#123;os.Args[<span class="number">0</span>], <span class="string">&quot;init&quot;</span>&#125;,</span><br><span class="line">		Validator: validate.New(),</span><br><span class="line">		CriuPath:  <span class="string">&quot;criu&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="keyword">return</span> l, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在的重点是这个父进程<code>parentProcess</code>里面具体都有些什么？我们来看看<code>ref-9</code>处的<code>c.newParentProcess(process)</code>实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// libcontainer/container_linux.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *linuxContainer)</span></span> newParentProcess(p *Process) (parentProcess, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 创建用于父子进程传递消息的文件对</span></span><br><span class="line">    parentInitPipe, childInitPipe, err := utils.NewSockPair(<span class="string">&quot;init&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unable to create init pipe: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	messageSockPair := filePair&#123;parentInitPipe, childInitPipe&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 创建用于父子进程传输日志的文件对</span></span><br><span class="line">	parentLogPipe, childLogPipe, err := os.Pipe()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unable to create log pipe: %w&quot;</span>, err)</span><br><span class="line">	&#125;  </span><br><span class="line">	logFilePair := filePair&#123;parentLogPipe, childLogPipe&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依据模板创建命令</span></span><br><span class="line">	cmd := c.commandTemplate(p, childInitPipe, childLogPipe) <span class="comment">// ref-13</span></span><br><span class="line">	<span class="keyword">if</span> !p.Init &#123;</span><br><span class="line">        <span class="comment">// 如果不是容器的第一个进程就创建SetnsProcess</span></span><br><span class="line">		<span class="keyword">return</span> c.newSetnsProcess(p, cmd, messageSockPair, logFilePair) <span class="comment">// ref-14</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We only set up fifoFd if we&#x27;re not doing a `runc exec`. The historic</span></span><br><span class="line">	<span class="comment">// reason for this is that previously we would pass a dirfd that allowed</span></span><br><span class="line">	<span class="comment">// for container rootfs escape (and not doing it in `runc exec` avoided</span></span><br><span class="line">	<span class="comment">// that problem), but we no longer do that. However, there&#x27;s no need to do</span></span><br><span class="line">	<span class="comment">// this for `runc exec` so we just keep it this way to be safe.</span></span><br><span class="line">	<span class="keyword">if</span> err := c.includeExecFifo(cmd); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unable to setup exec fifo: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果是容器的第一个进程就创建InitProcess</span></span><br><span class="line">	<span class="keyword">return</span> c.newInitProcess(p, cmd, messageSockPair, logFilePair) <span class="comment">// ref-15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我接下来看看<code>ref-13</code>处的命令模板情况：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// libcontainer/container_linux.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *linuxContainer)</span></span> commandTemplate(p *Process, childInitPipe *os.File, childLogPipe *os.File) *exec.Cmd &#123;</span><br><span class="line">    <span class="comment">// 创建操作系统支持的command</span></span><br><span class="line">	cmd := exec.Command(c.initPath, c.initArgs[<span class="number">1</span>:]...)</span><br><span class="line">    <span class="comment">// 下面就是设置命令的参数和环境变量，其实就是在向子进程传递信息</span></span><br><span class="line">	cmd.Args[<span class="number">0</span>] = c.initArgs[<span class="number">0</span>]</span><br><span class="line">	cmd.Stdin = p.Stdin</span><br><span class="line">	cmd.Stdout = p.Stdout</span><br><span class="line">	cmd.Stderr = p.Stderr</span><br><span class="line">	cmd.Dir = c.config.Rootfs</span><br><span class="line">	<span class="keyword">if</span> cmd.SysProcAttr == <span class="literal">nil</span> &#123;</span><br><span class="line">		cmd.SysProcAttr = &amp;unix.SysProcAttr&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cmd.Env = <span class="built_in">append</span>(cmd.Env, <span class="string">&quot;GOMAXPROCS=&quot;</span>+os.Getenv(<span class="string">&quot;GOMAXPROCS&quot;</span>))</span><br><span class="line">	cmd.ExtraFiles = <span class="built_in">append</span>(cmd.ExtraFiles, p.ExtraFiles...)</span><br><span class="line">	<span class="keyword">if</span> p.ConsoleSocket != <span class="literal">nil</span> &#123;</span><br><span class="line">		cmd.ExtraFiles = <span class="built_in">append</span>(cmd.ExtraFiles, p.ConsoleSocket)</span><br><span class="line">		cmd.Env = <span class="built_in">append</span>(cmd.Env,</span><br><span class="line">			<span class="string">&quot;_LIBCONTAINER_CONSOLE=&quot;</span>+strconv.Itoa(stdioFdCount+<span class="built_in">len</span>(cmd.ExtraFiles)<span class="number">-1</span>),</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">	cmd.ExtraFiles = <span class="built_in">append</span>(cmd.ExtraFiles, childInitPipe)</span><br><span class="line">	cmd.Env = <span class="built_in">append</span>(cmd.Env,</span><br><span class="line">		<span class="string">&quot;_LIBCONTAINER_INITPIPE=&quot;</span>+strconv.Itoa(stdioFdCount+<span class="built_in">len</span>(cmd.ExtraFiles)<span class="number">-1</span>),</span><br><span class="line">		<span class="string">&quot;_LIBCONTAINER_STATEDIR=&quot;</span>+c.root,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	cmd.ExtraFiles = <span class="built_in">append</span>(cmd.ExtraFiles, childLogPipe)</span><br><span class="line">	cmd.Env = <span class="built_in">append</span>(cmd.Env,</span><br><span class="line">		<span class="string">&quot;_LIBCONTAINER_LOGPIPE=&quot;</span>+strconv.Itoa(stdioFdCount+<span class="built_in">len</span>(cmd.ExtraFiles)<span class="number">-1</span>),</span><br><span class="line">		<span class="string">&quot;_LIBCONTAINER_LOGLEVEL=&quot;</span>+p.LogLevel,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们看看<code>ref-15</code>处的<code>InitProcess</code>创建过程：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// libcontainer/container_linux.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *linuxContainer)</span></span> newInitProcess(p *Process, cmd *exec.Cmd, messageSockPair, logFilePair filePair) (*initProcess, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 追加环境变量</span></span><br><span class="line">	cmd.Env = <span class="built_in">append</span>(cmd.Env, <span class="string">&quot;_LIBCONTAINER_INITTYPE=&quot;</span>+<span class="type">string</span>(initStandard))</span><br><span class="line">    <span class="comment">// 设置namespace信息</span></span><br><span class="line">	nsMaps := <span class="built_in">make</span>(<span class="keyword">map</span>[configs.NamespaceType]<span class="type">string</span>)</span><br><span class="line">	<span class="keyword">for</span> _, ns := <span class="keyword">range</span> c.config.Namespaces &#123; <span class="comment">// ref-17</span></span><br><span class="line">		<span class="keyword">if</span> ns.Path != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			nsMaps[ns.Type] = ns.Path</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	_, sharePidns := nsMaps[configs.NEWPID]</span><br><span class="line">    <span class="comment">// 创建子进程的bootstrap数据</span></span><br><span class="line">	data, err := c.bootstrapData(c.config.Namespaces.CloneFlags(), nsMaps, initStandard)<span class="comment">// ref-23</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.shouldSendMountSources() &#123;</span><br><span class="line">		...... <span class="comment">// 省略创建挂载信息的代码</span></span><br><span class="line">		cmd.Env = <span class="built_in">append</span>(cmd.Env,</span><br><span class="line">			<span class="string">&quot;_LIBCONTAINER_MOUNT_FDS=&quot;</span>+<span class="type">string</span>(mountFdsJson),</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	init := &amp;initProcess&#123;</span><br><span class="line">		cmd:             cmd, <span class="comment">// 其实就是/proc/self/exe   runc命令自己的执行程序</span></span><br><span class="line">		messageSockPair: messageSockPair, <span class="comment">// 消息通信</span></span><br><span class="line">		logFilePair:     logFilePair, <span class="comment">// 日志通信</span></span><br><span class="line">		manager:         c.cgroupManager, <span class="comment">// cgroups管理</span></span><br><span class="line">		intelRdtManager: c.intelRdtManager,</span><br><span class="line">		config:          c.newInitConfig(p), <span class="comment">// 初始化配置</span></span><br><span class="line">		container:       c,  <span class="comment">// 容器对象</span></span><br><span class="line">		process:         p, <span class="comment">// 进程对象</span></span><br><span class="line">		bootstrapData:   data, <span class="comment">// 子进程引导数据</span></span><br><span class="line">		sharePidns:      sharePidns, <span class="comment">// 子进程要完成的pid命名空间切换</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.initProcess = init</span><br><span class="line">	<span class="keyword">return</span> init, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ref-17</code>在设置namespace信息组成的ma，,根据config.json中namespaces配置，生成一个namespace为key，path为value的map。这个namespace的map在构造bootstrapdata时，会判断每个namespace是否配置了path，如果配置了，则之后不再创建新的namespace，而是将这种类型的namespace  join 到这个path下。</p>
<p>我们再来看看<code>ref-23</code>处的代码都创建了哪些bootstrap参数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mapping etc.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *linuxContainer)</span></span> bootstrapData(cloneFlags <span class="type">uintptr</span>, nsMaps <span class="keyword">map</span>[configs.NamespaceType]<span class="type">string</span>, it initType) (_ io.Reader, Err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// create the netlink message</span></span><br><span class="line">	r := nl.NewNetlinkRequest(<span class="type">int</span>(InitMsg), <span class="number">0</span>)</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="comment">// write cloneFlags</span></span><br><span class="line">	r.AddData(&amp;Int32msg&#123;</span><br><span class="line">		Type:  CloneFlagsAttr,</span><br><span class="line">		Value: <span class="type">uint32</span>(cloneFlags),</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// write custom namespace paths</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nsMaps) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		nsPaths, err := c.orderNamespacePaths(nsMaps)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		r.AddData(&amp;Bytemsg&#123;</span><br><span class="line">			Type:  NsPathsAttr,</span><br><span class="line">			Value: []<span class="type">byte</span>(strings.Join(nsPaths, <span class="string">&quot;,&quot;</span>)),</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// write namespace paths only when we are not joining an existing user ns</span></span><br><span class="line">	_, joinExistingUser := nsMaps[configs.NEWUSER]</span><br><span class="line">	<span class="keyword">if</span> !joinExistingUser &#123;</span><br><span class="line">		<span class="comment">// write uid mappings</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(c.config.UidMappings) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            ...... <span class="comment">// 写入uid</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// write gid mappings</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(c.config.GidMappings) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			...... <span class="comment">// 写入gid</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.config.OomScoreAdj != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// write oom_score_adj</span></span><br><span class="line">		r.AddData(&amp;Bytemsg&#123;</span><br><span class="line">			Type:  OomScoreAdjAttr,</span><br><span class="line">			Value: []<span class="type">byte</span>(strconv.Itoa(*c.config.OomScoreAdj)),</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// write rootless</span></span><br><span class="line">	r.AddData(&amp;Boolmsg&#123;</span><br><span class="line">		Type:  RootlessEUIDAttr,</span><br><span class="line">		Value: c.config.RootlessEUID,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Bind mount source to open.</span></span><br><span class="line">	<span class="keyword">if</span> it == initStandard &amp;&amp; c.shouldSendMountSources() &#123;</span><br><span class="line">		...... <span class="comment">// 构建挂载信息</span></span><br><span class="line">		r.AddData(&amp;Bytemsg&#123;</span><br><span class="line">			Type:  MountSourcesAttr,</span><br><span class="line">			Value: mounts,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通过netlink消息格式封装</span></span><br><span class="line">	<span class="keyword">return</span> bytes.NewReader(r.Serialize()), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bootstrapData: 构造出 run init 阶段需要用到的启动参数。包括clone(2)的clone flag，uid&#x2F;gid映射, oom阈值，rootless相关的设置等等。这些配置都通过netlink消息格式封装。然后通过之前的那对unix socketpair将其发送给子进程。</p>
<p>现在就是有一个疑问了，子进程中是怎么处理这些信息的呢？子进程又给父进程发送了哪些信息呢？</p>
<p>这些疑问的答案都被runc隐藏在<code>init.go</code>文件中了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// init.go 文件</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/opencontainers/runc/libcontainer&quot;</span></span><br><span class="line">	_ <span class="string">&quot;github.com/opencontainers/runc/libcontainer/nsenter&quot;</span> <span class="comment">// ref-22</span></span><br><span class="line">	<span class="string">&quot;github.com/sirupsen/logrus&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &amp;&amp; os.Args[<span class="number">1</span>] == <span class="string">&quot;init&quot;</span> &#123; <span class="comment">// ref-18</span></span><br><span class="line">		<span class="comment">// This is the golang entry point for runc init, executed</span></span><br><span class="line">		<span class="comment">// before main() but after libcontainer/nsenter&#x27;s nsexec().</span></span><br><span class="line">		runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">		runtime.LockOSThread() <span class="comment">// ref-19</span></span><br><span class="line"></span><br><span class="line">		level, err := strconv.Atoi(os.Getenv(<span class="string">&quot;_LIBCONTAINER_LOGLEVEL&quot;</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		logPipeFd, err := strconv.Atoi(os.Getenv(<span class="string">&quot;_LIBCONTAINER_LOGPIPE&quot;</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		logrus.SetLevel(logrus.Level(level))</span><br><span class="line">		logrus.SetOutput(os.NewFile(<span class="type">uintptr</span>(logPipeFd), <span class="string">&quot;logpipe&quot;</span>))</span><br><span class="line">		logrus.SetFormatter(<span class="built_in">new</span>(logrus.JSONFormatter))</span><br><span class="line">		logrus.Debug(<span class="string">&quot;child process in init()&quot;</span>)</span><br><span class="line"></span><br><span class="line">		factory, _ := libcontainer.New(<span class="string">&quot;&quot;</span>) <span class="comment">// ref-20</span></span><br><span class="line">		<span class="keyword">if</span> err := factory.StartInitialization(); err != <span class="literal">nil</span> &#123; <span class="comment">// ref-21</span></span><br><span class="line">			<span class="comment">// as the error is sent back to the parent there is no need to log</span></span><br><span class="line">			<span class="comment">// or write it to stderr because the parent process will handle this</span></span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;libcontainer: container init failed to exec&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别注意<code>ref-18</code>处的注释，这个<code>init()</code>方法会<code>在main()</code>函数之前，<code>libcontainer/nsenter</code>的<code>nsexec()</code>之后，执行。这个<code>libcontainer/nsenter</code>是在<code>import</code>中导入的，在<code>ref-22</code>处代码。</p>
<p>我们得先看看<code>nsexec()</code>函数干了些什么事情？</p>
<p><code>nsexec()</code>是使用C代码实现的，具体的作用就是实现命名空间的切换。这段C代码我没有看懂，参考<a href="https://blog.csdn.net/weixin_39970689/article/details/112454983">mount 内核源码_runc源码分析</a>进行了理解。</p>
<p>我们就下来再回过头来看看<code>initProcess</code>的<code>start()</code>函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// libcontainer/process_linux.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *initProcess)</span></span> start() (retErr <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> p.messageSockPair.parent.Close() <span class="comment">//nolint: errcheck</span></span><br><span class="line">	err := p.cmd.Start() <span class="comment">// 开始执行 runc init  // ref-25</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向runc init 子进程发送bootstrap数据</span></span><br><span class="line">	<span class="keyword">if</span> _, err := io.Copy(p.messageSockPair.parent, p.bootstrapData); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;can&#x27;t copy bootstrap data to pipe: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">    ...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="comment">//  等待第一个子进程退出</span></span><br><span class="line">	<span class="keyword">if</span> err := p.waitForChildExit(childPid); err != <span class="literal">nil</span> &#123; <span class="comment">// ref-24</span></span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error waiting for our first child to exit: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//  设置网卡状态为up</span></span><br><span class="line">	<span class="keyword">if</span> err := p.createNetworkInterfaces(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error creating network interfaces: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//  更新当前状态到 state.json</span></span><br><span class="line">	<span class="keyword">if</span> err := p.updateSpecState(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error updating spec state: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//  向子进程runc init发送配置。子进程runc init在ref-24处已经退出了，这个其实是给子进程runc init的子进程发送数据, 也就是ref-25处start()子进程创建的子进程</span></span><br><span class="line">	<span class="keyword">if</span> err := p.sendConfig(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error sending config to init process: %w&quot;</span>, err)</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//  等待子进程发送回来的同步消息</span></span><br><span class="line">	ierr := parseSync(p.messageSockPair.parent, <span class="function"><span class="keyword">func</span><span class="params">(sync *syncT)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> sync.Type &#123;</span><br><span class="line">		<span class="keyword">case</span> procSeccomp:</span><br><span class="line">			...... <span class="comment">// 省略</span></span><br><span class="line">		<span class="keyword">case</span> procReady:</span><br><span class="line">			...... <span class="comment">// 省略</span></span><br><span class="line">		<span class="keyword">case</span> procHooks:</span><br><span class="line">			...... <span class="comment">// 省略</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> errors.New(<span class="string">&quot;invalid JSON payload from child&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">    ...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="comment">// 开始关闭自己</span></span><br><span class="line">	<span class="keyword">if</span> err := unix.Shutdown(<span class="type">int</span>(p.messageSockPair.parent.Fd()), unix.SHUT_WR); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;os.PathError&#123;Op: <span class="string">&quot;shutdown&quot;</span>, Path: <span class="string">&quot;(init pipe)&quot;</span>, Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Must be done after Shutdown so the child will exit and we can wait for it.</span></span><br><span class="line">	<span class="keyword">if</span> ierr != <span class="literal">nil</span> &#123;</span><br><span class="line">		_, _ = p.wait()</span><br><span class="line">		<span class="keyword">return</span> ierr</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了更清楚地理解目前几个进程之间的关系，按照进程出现的先后顺序，暂且将几个进程称为:</p>
<p><strong>runc:CREATE -&gt; runc:[0:PARENT] -&gt; runc:[1:CHILD] -&gt; runc:[2:INIT]</strong></p>
<p>其中，<strong>runc:[0:PARENT]</strong> clone时指定了<strong>CLONE_PARENT</strong>，后面三个进程在进程父子视图上并不是 父子关系，而是 兄弟关系。如下图所示：</p>
<p><img src="/images/runc%E4%B8%89%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="b59f16d2db630309761b51d4c6fa6b47.png"></p>
<p>下面我们通过一张图来理解<code>nsexec()</code>函数：</p>
<p><img src="/images/nsexec%E5%87%BD%E6%95%B0%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="9acc46b0cbac77817c9aa450545a37a5.png"></p>
<p>runc中实现切换新的namespace都是使用unshare()。</p>
<p>namespace切换发生在runc:[1:CHILD]。CLONE_NEWUSER首先需要单独做一次unshare()。CLONE_NEWUSER不能与CLONE_PARENT同时指定。具体细节读者可见：man 2 clone</p>
<p>runc:[1:CHILD]执行完unshare(cloneflags&amp;~CLONE_NEWGROUP),主要的namespaces已经改变了，但CLONE_NEWPID这个namespace并未发生切换，需要再次clone()。</p>
<p>一旦clone_parent(JUMP_INIT)开始执行，runc:[2:INIT]进程产生，pid namespae切换。runc:[1:CHILD]进程一只脚在容器内，一只脚在容器外；而runc:[2:INIT]是完全进入到容器的进程。</p>
<p>runc:[1:CHILD]，runc:[0:PARENT] 相继退出，runc:[2:INIT]中执行完nsexec()函数后，后续流程开始进入runc init剩下的go runtime部分。</p>
<p>当<code>nsexec()</code>函数执行完之后，就该执行<code>init.go</code>中的初始化函数了，下面我们一起看看：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// libcontainer/factory_linux.go 文件</span></span><br><span class="line"><span class="comment">// StartInitialization loads a container by opening the pipe fd from the parent to read the configuration and state</span></span><br><span class="line"><span class="comment">// This is a low level implementation detail of the reexec and should not be consumed externally</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LinuxFactory)</span></span> StartInitialization() (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// Get the INITPIPE.</span></span><br><span class="line">	envInitPipe := os.Getenv(<span class="string">&quot;_LIBCONTAINER_INITPIPE&quot;</span>)</span><br><span class="line">	pipefd, err := strconv.Atoi(envInitPipe)</span><br><span class="line">	pipe := os.NewFile(<span class="type">uintptr</span>(pipefd), <span class="string">&quot;pipe&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> pipe.Close()</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="comment">// Only init processes have FIFOFD.</span></span><br><span class="line">	fifofd := <span class="number">-1</span></span><br><span class="line">	envInitType := os.Getenv(<span class="string">&quot;_LIBCONTAINER_INITTYPE&quot;</span>)</span><br><span class="line">	it := initType(envInitType)</span><br><span class="line">	<span class="keyword">if</span> it == initStandard &#123;</span><br><span class="line">		envFifoFd := os.Getenv(<span class="string">&quot;_LIBCONTAINER_FIFOFD&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> fifofd, err = strconv.Atoi(envFifoFd); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to convert _LIBCONTAINER_FIFOFD: %w&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="comment">// Get mount files (O_PATH).</span></span><br><span class="line">	mountFds, err := parseMountFds()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// clear the current process&#x27;s environment to clean any libcontainer</span></span><br><span class="line">	<span class="comment">// specific env vars.</span></span><br><span class="line">	os.Clearenv()</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">    <span class="comment">// 创建容器初始化器</span></span><br><span class="line">	i, err := newContainerInit(it, pipe, consoleSocket, fifofd, logPipeFd, mountFds) <span class="comment">// ref-26</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If Init succeeds, syscall.Exec will not return, hence none of the defers will be called.</span></span><br><span class="line">	<span class="keyword">return</span> i.Init() <span class="comment">// ref-27</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来最后来看看容器初始化器做了什么？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// libcontainer/standard_init_linux.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *linuxStandardInit)</span></span> Init() <span class="type">error</span> &#123; <span class="comment">// 这个函数在子进程runc init的子进程中执行。</span></span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">    <span class="comment">// 设置网卡为up</span></span><br><span class="line">	<span class="keyword">if</span> err := setupNetwork(l.config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 设置路由表</span></span><br><span class="line">	<span class="keyword">if</span> err := setupRoute(l.config.Config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// initialises the labeling system</span></span><br><span class="line">	selinux.GetEnabled()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We don&#x27;t need the mountFds after prepareRootfs() nor if it fails.</span></span><br><span class="line">    <span class="comment">// 准备rootfs</span></span><br><span class="line">	err := prepareRootfs(l.pipe, l.config, l.mountFds)</span><br><span class="line">	<span class="keyword">for</span> _, m := <span class="keyword">range</span> l.mountFds &#123;</span><br><span class="line">		<span class="keyword">if</span> m == <span class="number">-1</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err := unix.Close(m); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;Unable to close mountFds fds: %w&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="comment">// Tell our parent that we&#x27;re ready to Execv. This must be done before the</span></span><br><span class="line">	<span class="comment">// Seccomp rules have been applied, because we need to be able to read and</span></span><br><span class="line">	<span class="comment">// write to a socket.</span></span><br><span class="line">    <span class="comment">// 告诉父进程，现在已经都准备好了，父进程(parentProcess)收到消息后就会退出</span></span><br><span class="line">	<span class="keyword">if</span> err := syncParentReady(l.pipe); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;sync ready: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">		...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="comment">// Wait for the FIFO to be opened on the other side before exec-ing the</span></span><br><span class="line">	<span class="comment">// user process. We open it through /proc/self/fd/$fd, because the fd that</span></span><br><span class="line">	<span class="comment">// was given to us was an O_PATH fd to the fifo itself. Linux allows us to</span></span><br><span class="line">	<span class="comment">// re-open an O_PATH fd through /proc.</span></span><br><span class="line">	fifoPath := <span class="string">&quot;/proc/self/fd/&quot;</span> + strconv.Itoa(l.fifoFd)</span><br><span class="line">    <span class="comment">// 这个open方法会导致阻塞，直到另外一端也打开</span></span><br><span class="line">	fd, err := unix.Open(fifoPath, unix.O_WRONLY|unix.O_CLOEXEC, <span class="number">0</span>) <span class="comment">// ref-27</span></span><br><span class="line">    <span class="comment">// 阻塞结束后，就真正的执行用户指定的容器中执行的命令了</span></span><br><span class="line">	<span class="comment">// 告诉父进程现在开始启动用户给容器指定的命令。</span></span><br><span class="line">	<span class="keyword">if</span> _, err := unix.Write(fd, []<span class="type">byte</span>(<span class="string">&quot;0&quot;</span>)); err != <span class="literal">nil</span> &#123; <span class="comment">// ref-28</span></span><br><span class="line">		<span class="keyword">return</span> &amp;os.PathError&#123;Op: <span class="string">&quot;write exec fifo&quot;</span>, Path: fifoPath, Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Close the O_PATH fifofd fd before exec because the kernel resets</span></span><br><span class="line">	<span class="comment">// dumpable in the wrong order. This has been fixed in newer kernels, but</span></span><br><span class="line">	<span class="comment">// we keep this to ensure CVE-2016-9962 doesn&#x27;t re-emerge on older kernels.</span></span><br><span class="line">	<span class="comment">// N.B. the core issue itself (passing dirfds to the host filesystem) has</span></span><br><span class="line">	<span class="comment">// since been resolved.</span></span><br><span class="line">	<span class="comment">// https://github.com/torvalds/linux/blob/v4.9/fs/exec.c#L1290-L1318</span></span><br><span class="line">	_ = unix.Close(l.fifoFd)</span><br><span class="line"></span><br><span class="line">	s := l.config.SpecState</span><br><span class="line">	s.Pid = unix.Getpid()</span><br><span class="line">	s.Status = specs.StateCreated</span><br><span class="line">	<span class="keyword">if</span> err := l.config.Config.Hooks[configs.StartContainer].RunHooks(s); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 使用系统调用执行用户指定的容器要执行的命令，伴随着的还有子进程runc init的子进程也就退出了。</span></span><br><span class="line">	<span class="keyword">return</span> system.Exec(name, l.config.Args[<span class="number">0</span>:], os.Environ())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、容器启动分析"><a href="#三、容器启动分析" class="headerlink" title="三、容器启动分析"></a>三、容器启动分析</h2><p>上面已经分析到<code>runc create</code>命令最后一步就是在等待一个消息，然后就开启用户指定的容器命令了。这个消息就是<code>runc start</code>发出的。接下来我们具体看看。</p>
<p>首先看看<code>runc start</code>命令的执行函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// start.go文件</span></span><br><span class="line"><span class="keyword">var</span> startCommand = cli.Command&#123;</span><br><span class="line">	Name:  <span class="string">&quot;start&quot;</span>,</span><br><span class="line">	Usage: <span class="string">&quot;executes the user defined process in a created container&quot;</span>,</span><br><span class="line">	ArgsUsage: <span class="string">`&lt;container-id&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Where &quot;&lt;container-id&gt;&quot; is your name for the instance of the container that you</span></span><br><span class="line"><span class="string">are starting. The name you provide for the container instance must be unique on</span></span><br><span class="line"><span class="string">your host.`</span>,</span><br><span class="line">	Description: <span class="string">`The start command executes the user defined process in a created container.`</span>,</span><br><span class="line">	Action: <span class="function"><span class="keyword">func</span><span class="params">(context *cli.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := checkArgs(context, <span class="number">1</span>, exactArgs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		container, err := getContainer(context)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		status, err := container.Status()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> status &#123;</span><br><span class="line">		<span class="keyword">case</span> libcontainer.Created: <span class="comment">// ref-29</span></span><br><span class="line">            <span class="comment">// ref-30</span></span><br><span class="line">			notifySocket, err := notifySocketStart(context, os.Getenv(<span class="string">&quot;NOTIFY_SOCKET&quot;</span>), container.ID())</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err := container.Exec(); err != <span class="literal">nil</span> &#123; <span class="comment">// ref-31</span></span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> notifySocket != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// ref-32</span></span><br><span class="line">				<span class="keyword">return</span> notifySocket.waitForContainer(container)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> libcontainer.Stopped:</span><br><span class="line">			<span class="keyword">return</span> errors.New(<span class="string">&quot;cannot start a container that has stopped&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> libcontainer.Running:</span><br><span class="line">			<span class="keyword">return</span> errors.New(<span class="string">&quot;cannot start an already running container&quot;</span>)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;cannot start a container in the %s state&quot;</span>, status)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ref-29</code>处在判断容器的当前状态，<code>ref-31</code>的<code>container.Exec()</code>，我们来看看里面具体干了啥：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// libcontainer/container_linux.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *linuxContainer)</span></span> exec() <span class="type">error</span> &#123; <span class="comment">// linux container 执行start任务的具体函数</span></span><br><span class="line">	path := filepath.Join(c.root, execFifoFilename) <span class="comment">// 获取用于子进程通信的文件路径</span></span><br><span class="line">	pid := c.initProcess.pid()</span><br><span class="line">    blockingFifoOpenCh := awaitFifoOpen(path) <span class="comment">// 打开文件，子进程(runc init的子进程)阻塞结束</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> result := &lt;-blockingFifoOpenCh: <span class="comment">// 收到子进程发送过来的数据</span></span><br><span class="line">			<span class="keyword">return</span> handleFifoResult(result) <span class="comment">// ref-32 读取数据就返回了，这儿就真的只是读取数据，啥也没干</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(time.Millisecond * <span class="number">100</span>): <span class="comment">// 超时控制</span></span><br><span class="line">			stat, err := system.Stat(pid)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> || stat.State == system.Zombie &#123;</span><br><span class="line">				<span class="comment">// could be because process started, ran, and completed between our 100ms timeout and our system.Stat() check.</span></span><br><span class="line">				<span class="comment">// see if the fifo exists and has data (with a non-blocking open, which will succeed if the writing process is complete).</span></span><br><span class="line">				<span class="keyword">if</span> err := handleFifoResult(fifoOpen(path, <span class="literal">false</span>)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> errors.New(<span class="string">&quot;container process is already dead&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们最后来看看<code>ref-32</code>的数据读取都做了什么操作？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// libcontainer/container_linux.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleFifoResult</span><span class="params">(result openResult)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> result.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> result.err</span><br><span class="line">	&#125;</span><br><span class="line">	f := result.file</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	<span class="keyword">if</span> err := readFromExecFifo(f); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> os.Remove(f.Name())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就是读取了一下文件管道中的数据，然后真的就啥也没干！</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFromExecFifo</span><span class="params">(execFifo io.Reader)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	data, err := io.ReadAll(execFifo)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(data) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;cannot start an already running container&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>到这儿，docker 容器进程启动分析就结束了。可以看到runc要想把容器中用户指定的命令进程完全与宿主机隔离，还是非常曲折的。</p>
<p>参考资料：</p>
<p>1、<a href="https://mkdev.me/posts/the-tool-that-really-runs-your-containers-deep-dive-into-runc-and-oci-specifications">https://mkdev.me/posts/the-tool-that-really-runs-your-containers-deep-dive-into-runc-and-oci-specifications</a></p>
<p>2、runc仓库地址：<a href="https://github.com/opencontainers/runc">https://github.com/opencontainers/runc</a></p>
<p>3、mount 内核源码_runc源码分析：<a href="https://blog.csdn.net/weixin_39970689/article/details/112454983">https://blog.csdn.net/weixin_39970689/article/details/112454983</a></p>
]]></content>
      <categories>
        <category>编程 - docker</category>
      </categories>
      <tags>
        <tag>runc</tag>
      </tags>
  </entry>
  <entry>
    <title>Junit5设计分析（二）</title>
    <url>/2022/09/03/Junit5%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>代码仓库：<a href="https://github.com/junit-team/junit5/">https://github.com/junit-team/junit5/</a></p>
<p>在<strong>Junit5设计分析（一）</strong>中分析了IDEA中执行单元测试的主流程和主要类的设计，但是还有两个小点没有分析到：</p>
<p>(1) TestEngine是怎么发现测试任务的？</p>
<p>(2) 单元测试方法的参数是怎么解析并获取的？</p>
<p>在这篇文章里面，就来探索这两个问题。</p>
<h2 id="一、TestEngine是怎么发现测试任务的？"><a href="#一、TestEngine是怎么发现测试任务的？" class="headerlink" title="一、TestEngine是怎么发现测试任务的？"></a>一、TestEngine是怎么发现测试任务的？</h2><p>我们还是用”Junit5设计分析（一）”中的例子来进行探索。先来回顾一下这个示例程序吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单计算器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单元测试方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CalculatorTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        assertEquals(<span class="number">2</span>, calculator.add(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>在IDEA中执行测试方法的主流程上，我们先看看测试任务在哪儿开始使用的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.junit.platform.engine.support.hierarchical;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HierarchicalTestExecutor</span>&lt;C <span class="keyword">extends</span> <span class="title class_">EngineExecutionContext</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ExecutionRequest request;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> C rootContext;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> HierarchicalTestExecutorService executorService;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ThrowableCollector.Factory throwableCollectorFactory;</span><br><span class="line"></span><br><span class="line">	HierarchicalTestExecutor(ExecutionRequest request, C rootContext, HierarchicalTestExecutorService executorService,</span><br><span class="line">			ThrowableCollector.Factory throwableCollectorFactory) &#123;</span><br><span class="line">		<span class="built_in">this</span>.request = request;</span><br><span class="line">		<span class="built_in">this</span>.rootContext = rootContext;</span><br><span class="line">		<span class="built_in">this</span>.executorService = executorService;</span><br><span class="line">		<span class="built_in">this</span>.throwableCollectorFactory = throwableCollectorFactory;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Future&lt;Void&gt; <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1、从request中获取根TestDescriptor</span></span><br><span class="line">		<span class="type">TestDescriptor</span> <span class="variable">rootTestDescriptor</span> <span class="operator">=</span> <span class="built_in">this</span>.request.getRootTestDescriptor(); <span class="comment">// ref-1</span></span><br><span class="line">        <span class="comment">// 2、从request中获取监听器</span></span><br><span class="line">		<span class="type">EngineExecutionListener</span> <span class="variable">executionListener</span> <span class="operator">=</span> <span class="built_in">this</span>.request.getEngineExecutionListener();</span><br><span class="line">        <span class="comment">// 3、创建节点访问器，使用这个访问器执行任务的时候可以保护互斥资源</span></span><br><span class="line">		<span class="type">NodeExecutionAdvisor</span> <span class="variable">executionAdvisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeTreeWalker</span>().walk(rootTestDescriptor);</span><br><span class="line">        <span class="comment">// 4、创建NodeTestTask的域对象</span></span><br><span class="line">		<span class="type">NodeTestTaskContext</span> <span class="variable">taskContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeTestTaskContext</span>(executionListener, <span class="built_in">this</span>.executorService, <span class="built_in">this</span>.throwableCollectorFactory, executionAdvisor);</span><br><span class="line">        <span class="comment">// 5、创建NodeTestTask对象</span></span><br><span class="line">		NodeTestTask&lt;C&gt; rootTestTask =<span class="keyword">new</span> <span class="title class_">NodeTestTask</span>&lt;&gt;(taskContext, rootTestDescriptor);<span class="comment">//ref-2</span></span><br><span class="line">		<span class="comment">// 6、把当前域对象设置为rootTestTask的父域对象</span></span><br><span class="line">        rootTestTask.setParentContext(<span class="built_in">this</span>.rootContext);</span><br><span class="line">        <span class="comment">// 7、向执行服务中提交任务。</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.executorService.submit(rootTestTask); <span class="comment">// ref-3</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ref-1</code>处代码获取到的<code>TestDescriptor</code>是<code>JupiterEngineDescriptor</code>实例，它里面包含着测试类的描述和测试方法的描述。<code>ref-2</code>处代码会会将<code>rootTestDescriptor</code>封装到<code>NodeTestTask</code>中，然后在<code>ref-3</code>代码处提交到执行服务中执行，具体执行过程已经”Junit5设计分析（一）”中详细描述了。</p>
<p>从上面这段代码可以得到，测试任务一直被<code>request</code>携带着，那么我们就来看看这个<code>request</code>又是从哪儿来的？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.junit.platform.launcher.core.DefaultLauncher#execute 方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Root root, ConfigurationParameters configurationParameters,</span></span><br><span class="line"><span class="params">                     TestExecutionListener... listeners)</span> &#123;</span><br><span class="line">    <span class="type">TestExecutionListenerRegistry</span> <span class="variable">listenerRegistry</span> <span class="operator">=</span> buildListenerRegistryForExecution(listeners);</span><br><span class="line">    withInterceptedStreams(configurationParameters, listenerRegistry, testExecutionListener -&gt; &#123;</span><br><span class="line">        <span class="type">TestPlan</span> <span class="variable">testPlan</span> <span class="operator">=</span> TestPlan.from(root.getEngineDescriptors());</span><br><span class="line">        testExecutionListener.testPlanExecutionStarted(testPlan);</span><br><span class="line">        <span class="type">ExecutionListenerAdapter</span> <span class="variable">engineExecutionListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExecutionListenerAdapter</span>(testPlan,</span><br><span class="line">                                                                                        testExecutionListener);</span><br><span class="line">        <span class="keyword">for</span> (TestEngine testEngine : root.getTestEngines()) &#123;</span><br><span class="line">            <span class="type">TestDescriptor</span> <span class="variable">testDescriptor</span> <span class="operator">=</span> root.getTestDescriptorFor(testEngine); <span class="comment">// ref-5</span></span><br><span class="line">            execute(testEngine, <span class="keyword">new</span> <span class="title class_">ExecutionRequest</span>(testDescriptor, engineExecutionListener, configurationParameters)); <span class="comment">// ref-4</span></span><br><span class="line">        &#125;</span><br><span class="line">        testExecutionListener.testPlanExecutionFinished(testPlan);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在上文看到的request是在<code>ref-4</code>代码处创建出来的，<code>testDescriptor</code>是在<code>ref-5</code>处从<code>root</code>中获取到的。</p>
<p>那么接下来就是要看看<code>root</code>对象是从哪儿来的了？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.junit.platform.launcher.core.DefaultLauncher#execute方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(LauncherDiscoveryRequest discoveryRequest, TestExecutionListener... listeners)</span> &#123;</span><br><span class="line">    Preconditions.notNull(discoveryRequest, <span class="string">&quot;LauncherDiscoveryRequest must not be null&quot;</span>);</span><br><span class="line">    Preconditions.notNull(listeners, <span class="string">&quot;TestExecutionListener array must not be null&quot;</span>);</span><br><span class="line">    Preconditions.containsNoNullElements(listeners, <span class="string">&quot;individual listeners must not be null&quot;</span>);</span><br><span class="line">    execute(discoverRoot(discoveryRequest, <span class="string">&quot;execution&quot;</span>), discoveryRequest.getConfigurationParameters(), listeners); <span class="comment">// ref-6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>root</code>对象是在<code>ref-6</code>处调用<code>discoverRoot</code>得到的。我们来详细看看<code>discoverRoot</code>方法的细节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.junit.platform.launcher.core.DefaultLauncher#discoverRoot方法</span></span><br><span class="line"><span class="keyword">private</span> Root <span class="title function_">discoverRoot</span><span class="params">(LauncherDiscoveryRequest discoveryRequest, String phase)</span> &#123;</span><br><span class="line">    <span class="comment">// 1、创建Root对象</span></span><br><span class="line">    <span class="type">Root</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Root</span>();</span><br><span class="line">	<span class="comment">// 2、从每一个TestEngine中发现TestDescriptor</span></span><br><span class="line">    <span class="keyword">for</span> (TestEngine testEngine : <span class="built_in">this</span>.testEngines) &#123;</span><br><span class="line">        <span class="comment">// @formatter:off</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">engineIsExcluded</span> <span class="operator">=</span> discoveryRequest.getEngineFilters().stream()</span><br><span class="line">            .map(engineFilter -&gt; engineFilter.apply(testEngine))</span><br><span class="line">            .anyMatch(FilterResult::excluded);</span><br><span class="line">        <span class="comment">// @formatter:on</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (engineIsExcluded) &#123;</span><br><span class="line">            logger.debug(() -&gt; String.format(</span><br><span class="line">                <span class="string">&quot;Test discovery for engine &#x27;%s&#x27; was skipped due to an EngineFilter in phase &#x27;%s&#x27;.&quot;</span>,</span><br><span class="line">                testEngine.getId(), phase));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.debug(() -&gt; String.format(<span class="string">&quot;Discovering tests during Launcher %s phase in engine &#x27;%s&#x27;.&quot;</span>, phase,</span><br><span class="line">                                         testEngine.getId()));</span><br><span class="line">		<span class="comment">// 2.1 发现TestDescriptor // ref-7</span></span><br><span class="line">        Optional&lt;TestDescriptor&gt; engineRoot = discoverEngineRoot(testEngine, discoveryRequest);</span><br><span class="line">        <span class="comment">// 2、2 将发现的发现TestDescriptor添加到root对象中</span></span><br><span class="line">        engineRoot.ifPresent(rootDescriptor -&gt; root.add(testEngine, rootDescriptor));</span><br><span class="line">    &#125;</span><br><span class="line">    root.applyPostDiscoveryFilters(discoveryRequest);</span><br><span class="line">    <span class="comment">// 3、删除掉没有测试任务的TestDescriptor</span></span><br><span class="line">    root.prune();</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ref-7</code>处调用<code>discoverEngineRoot</code>发现<code>TestDescriptor</code>时，可以看到每次调用的时候都会将<code>discoveryRequest</code>传递下去，一会儿我们会分析到该对象的。我们接下来先看看<code>discoverEngineRoot</code>函数的细节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.junit.platform.launcher.core.DefaultLauncher#discoverEngineRoot方法</span></span><br><span class="line"><span class="keyword">private</span> Optional&lt;TestDescriptor&gt; <span class="title function_">discoverEngineRoot</span><span class="params">(TestEngine testEngine,</span></span><br><span class="line"><span class="params">                                                    LauncherDiscoveryRequest discoveryRequest)</span> &#123;</span><br><span class="line">	<span class="comment">// 获取测试引擎第一无二的标识id</span></span><br><span class="line">    <span class="type">UniqueId</span> <span class="variable">uniqueEngineId</span> <span class="operator">=</span> UniqueId.forEngine(testEngine.getId());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ref-8</span></span><br><span class="line">        <span class="type">TestDescriptor</span> <span class="variable">engineRoot</span> <span class="operator">=</span> testEngine.discover(discoveryRequest, uniqueEngineId);</span><br><span class="line">        discoveryResultValidator.validate(testEngine, engineRoot);</span><br><span class="line">        <span class="keyword">return</span> Optional.of(engineRoot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        handleThrowable(testEngine, <span class="string">&quot;discover&quot;</span>, throwable);</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ref-8</code>处会将<code>discoveryRequest</code>传递给<code>testEngine</code>进行测试任务的发现，那么我们测试任务的发现细节应该就是在<code>TestEngine#discover</code>方法里面了。我们接着看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.junit.jupiter.engine.JupiterTestEngine#discover 方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> TestDescriptor <span class="title function_">discover</span><span class="params">(EngineDiscoveryRequest discoveryRequest, UniqueId uniqueId)</span> &#123;</span><br><span class="line">   	<span class="comment">// ref-9</span></span><br><span class="line">    <span class="type">JupiterEngineDescriptor</span> <span class="variable">engineDescriptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JupiterEngineDescriptor</span>(uniqueId);</span><br><span class="line">    <span class="comment">// ref-10</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">DiscoverySelectorResolver</span>().resolveSelectors(discoveryRequest, engineDescriptor);</span><br><span class="line">    <span class="keyword">return</span> engineDescriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ref-9</code>处会创建一个<code>TestDescriptor</code>的实现类<code>JupiterEngineDescriptor</code>的实例。在<code>ref-10</code>处会创建一个<code>DiscoverySelectorResolver</code>来从<code>discoveryRequest</code>发现测试任务，并把测试任务封装到<code>engineDescriptor</code>中。</p>
<p>接着继续跟<code>resolveSelectors</code>方法细节，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.junit.jupiter.engine.discovery.DiscoverySelectorResolver#resolveSelectors 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resolveSelectors</span><span class="params">(EngineDiscoveryRequest request, TestDescriptor engineDescriptor)</span> &#123;</span><br><span class="line">    <span class="comment">// 1、创建类型过滤器</span></span><br><span class="line">    <span class="type">ClassFilter</span> <span class="variable">classFilter</span> <span class="operator">=</span> buildClassFilter(request, isTestClassWithTests);</span><br><span class="line">    <span class="comment">// 2、开始解析测试任务</span></span><br><span class="line">    resolve(request, engineDescriptor, classFilter); <span class="comment">// ref-11</span></span><br><span class="line">    <span class="comment">// 3、用classFilter来过滤engineDescriptor中的测试任务</span></span><br><span class="line">    filter(engineDescriptor, classFilter);</span><br><span class="line">    <span class="comment">// 4、将不包含测试方法的任务去除掉</span></span><br><span class="line">    pruneTree(engineDescriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在的关键就是<code>ref-11</code>处代码底层时怎么解析测试任务的了。我们接着继续跟！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.junit.jupiter.engine.discovery.DiscoverySelectorResolver#resolve 方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resolve</span><span class="params">(EngineDiscoveryRequest request, TestDescriptor engineDescriptor, ClassFilter classFilter)</span> &#123;</span><br><span class="line"><span class="comment">// 1、创建Java元素解析器</span></span><br><span class="line">    <span class="type">JavaElementsResolver</span> <span class="variable">javaElementsResolver</span> <span class="operator">=</span> createJavaElementsResolver(request.getConfigurationParameters(), engineDescriptor, classFilter);</span><br><span class="line">    request.getSelectorsByType(ClasspathRootSelector.class).forEach(javaElementsResolver::resolveClasspathRoot);</span><br><span class="line">    request.getSelectorsByType(ModuleSelector.class).forEach(javaElementsResolver::resolveModule);</span><br><span class="line">    request.getSelectorsByType(PackageSelector.class).forEach(javaElementsResolver::resolvePackage);</span><br><span class="line"> </span><br><span class="line"> request.getSelectorsByType(ClassSelector.class).forEach(javaElementsResolver::resolveClass);</span><br><span class="line"> <span class="comment">// ref-12   request.getSelectorsByType(MethodSelector.class).forEach(javaElementsResolver::resolveMethod);</span></span><br><span class="line">    request.getSelectorsByType(UniqueIdSelector.class).forEach(javaElementsResolver::resolveUniqueId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>resolve</code>方法中首先创建了一个Java元素解析器，然后从<code>request</code>中获取所有可能的选择器，然后把获取到的选择器传递给元素解析器进行实际的解析。所有选择器的关系如下图所示：</p>
<p><img src="/images/%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB.png" alt="image-20220820230044639"></p>
<p>首先得说一点，<code>DiscoverySelector</code>接口中没有任何得方法，是一个标识接口，在它的实现类中都有不同的方法，但是这些方法都是为了选择出测试任务，这个<code>DiscoverySelector</code>就是标识出所有不同实现类拥有着相同的目标。学到了啊，这就是标识接口的标准用法。</p>
<p>在我们的使用的单元测试例子中，只会进入到<code>ref-12</code>处的方法选择器中。我们详细来看看<code>resolveMethod</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># org.junit.jupiter.engine.discovery.JavaElementsResolver#resolveMethod 方法</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">resolveMethod</span><span class="params">(MethodSelector selector)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1、从选择器中获取测试类信息</span></span><br><span class="line">        Class&lt;?&gt; testClass = selector.getJavaClass();</span><br><span class="line">        <span class="comment">// 2、从选择器中获取测试方法信息</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">testMethod</span> <span class="operator">=</span> selector.getJavaMethod();</span><br><span class="line">		<span class="comment">// 3、解析testClass相关的测试任务（TestDescriptor），并且挂载到engineDescriptor的Children上。</span></span><br><span class="line">        Set&lt;TestDescriptor&gt; potentialParents = resolveContainerWithParents(testClass); <span class="comment">// ref-13</span></span><br><span class="line">        <span class="comment">// 3、解析testMethod相关的测试任务，并且挂载到相应的testClass的TestDescriptor的Children上。</span></span><br><span class="line">        Set&lt;TestDescriptor&gt; resolvedDescriptors = resolveForAllParents(testMethod, potentialParents); <span class="comment">// ref-14</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resolvedDescriptors.isEmpty()) &#123;</span><br><span class="line">            logger.debug(() -&gt; format(<span class="string">&quot;Method &#x27;%s&#x27; could not be resolved.&quot;</span>, testMethod.toGenericString()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logMultipleTestDescriptorsForSingleElement(testMethod, resolvedDescriptors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        rethrowIfBlacklisted(t);</span><br><span class="line">        logger.debug(t, () -&gt; format(<span class="string">&quot;Method &#x27;%s&#x27; in class &#x27;%s&#x27; could not be resolved.&quot;</span>, selector.getMethodName(), selector.getClassName()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们已经跟到了测试类与测试方法的解析主流程了，<code>ref-13</code>处代码会从<code>testClass</code>上解析出来相关的<code>TestDescriptor</code>，<code>ref-14</code>处会从<code>testMethod</code>上解析出来相关的<code>TestDescriptor</code>。这两处代码应该就隐藏着解析测试任务的细节了，我们接着跟！</p>
<p>先看<code>ref-13</code>处的代码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.junit.jupiter.engine.discovery.JavaElementsResolver#resolveContainerWithParents 方法</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;TestDescriptor&gt; <span class="title function_">resolveContainerWithParents</span><span class="params">(Class&lt;?&gt; testClass)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isInnerClass.test(testClass)) &#123; <span class="comment">// 判断是否为内部类</span></span><br><span class="line">        Set&lt;TestDescriptor&gt; potentialParents =                      					resolveContainerWithParents(testClass.getDeclaringClass()); <span class="comment">// 获取外部类，进行递归调用</span></span><br><span class="line">        <span class="keyword">return</span> resolveForAllParents(testClass, potentialParents); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 为所有的父节点解析TestDescriptor          // ref-15</span></span><br><span class="line">        <span class="keyword">return</span> resolveForAllParents(testClass, Collections.singleton(<span class="built_in">this</span>.engineDescriptor)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管是否为内部类，最终都会调用到<code>resolveForAllParents</code>方法，特别注意<code>ref-15</code>处，会将<code>this.engineDescriptor</code>作为父节点传入到<code>resolveForAllParents</code>方法。下面我们具体看一下该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;TestDescriptor&gt; <span class="title function_">resolveForAllParents</span><span class="params">(AnnotatedElement element, Set&lt;TestDescriptor&gt; potentialParents)</span> &#123;</span><br><span class="line">   Set&lt;TestDescriptor&gt; resolvedDescriptors = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// ref-16</span></span><br><span class="line">   potentialParents.forEach(parent -&gt; resolvedDescriptors.addAll(resolve(element, parent)));</span><br><span class="line">   <span class="comment">// @formatter:off</span></span><br><span class="line">   resolvedDescriptors.stream()</span><br><span class="line">         .filter(Filterable.class::isInstance)</span><br><span class="line">         .map(Filterable.class::cast)  <span class="comment">// 完成类型转换</span></span><br><span class="line">         .forEach(testDescriptor -&gt; testDescriptor.getDynamicDescendantFilter().allowAll());<span class="comment">//过滤</span></span><br><span class="line">   <span class="comment">// @formatter:on</span></span><br><span class="line">   <span class="keyword">return</span> resolvedDescriptors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ref-16</code>处代码会调用<code>resolve</code>解析出来所有的<code>TestDescriptor</code>，并且将他们添加到<code>resolvedDescriptors</code>中，以便后续做类型转换和过滤。那么重点来了，就是这个<code>resolve</code>方法的细节了，我们接着跟！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.junit.jupiter.engine.discovery.JavaElementsResolver#resolve 方法</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;TestDescriptor&gt; <span class="title function_">resolve</span><span class="params">(AnnotatedElement element, TestDescriptor parent)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用解析器尝试解析element对象相关的测试任务（TestDescriptor）</span></span><br><span class="line">    Set&lt;TestDescriptor&gt; descriptors = <span class="built_in">this</span>.resolvers.stream()</span><br><span class="line">        .map(resolver -&gt; tryToResolveWithResolver(element, parent, resolver)) <span class="comment">// ref-17</span></span><br><span class="line">        .filter(testDescriptors -&gt; !testDescriptors.isEmpty())</span><br><span class="line">        .flatMap(Collection::stream)</span><br><span class="line">        .collect(toSet());</span><br><span class="line"></span><br><span class="line">    logMultipleTestDescriptorsForSingleElement(element, descriptors);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> descriptors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>resolve</code>方法使用所有解析器来尝试解析<code>element</code>元素相关的测试任务<code>TestDescriptor</code>，我们先来看看解析器都有哪些：</p>
<p><img src="/images/%E6%89%80%E6%9C%89%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A7%A3%E6%9E%90%E5%99%A8.png" alt="image-20220823201401694"></p>
<p>这些解析器都会在<code>ref-17</code>处的<code>tryToResolveWithResolver</code>方法中被调用，让我们来看看详细代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.junit.jupiter.engine.discovery.JavaElementsResolver#tryToResolveWithResolver 方法</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;TestDescriptor&gt; <span class="title function_">tryToResolveWithResolver</span><span class="params">(AnnotatedElement element, TestDescriptor parent, ElementResolver resolver)</span> &#123;</span><br><span class="line">	<span class="comment">// 1、调用解析器解析TestDescriptor</span></span><br><span class="line">    Set&lt;TestDescriptor&gt; resolvedDescriptors = resolver.resolveElement(element, parent); <span class="comment">// ref-18</span></span><br><span class="line">    Set&lt;TestDescriptor&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">	<span class="comment">// 2、将解析出来的TestDescriptor挂载到parent上，并且添加到结果集合result中。</span></span><br><span class="line">    resolvedDescriptors.forEach(testDescriptor -&gt; &#123;</span><br><span class="line">        <span class="comment">// 3、在当前的this.engineDescriptor中查找是否已经存在该testDescriptor</span></span><br><span class="line">        Optional&lt;TestDescriptor&gt; existingTestDescriptor = findTestDescriptorByUniqueId(</span><br><span class="line">            testDescriptor.getUniqueId());</span><br><span class="line">        <span class="keyword">if</span> (existingTestDescriptor.isPresent()) &#123; <span class="comment">// 如果存在，就只添加到结果集合result中</span></span><br><span class="line">            result.add(existingTestDescriptor.get());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 如果不存在，那么先将testDescriptor挂载到parent上，再添加到结果集合result中</span></span><br><span class="line">            parent.addChild(testDescriptor);</span><br><span class="line">            result.add(testDescriptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这儿的重点就是<code>ref-18</code>处代码的<code>resolveElement</code>方法了。通过debug发现<code>ref-13</code>处代码调用到<code>ref-18</code>处时，解析器为<code>TestContainerResolver</code>，<code>ref-14</code>处代码调用到<code>ref-18</code>处时，解析器为<code>TestMethodResolver</code>。</p>
<p>我们先来看看解析测试类的<code>TestContainerResolver</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.junit.jupiter.engine.discovery;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestContainerResolver</span> <span class="keyword">implements</span> <span class="title class_">ElementResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">IsPotentialTestContainer</span> <span class="variable">isPotentialTestContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IsPotentialTestContainer</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SEGMENT_TYPE</span> <span class="operator">=</span> <span class="string">&quot;class&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">final</span> ConfigurationParameters configurationParameters;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">TestContainerResolver</span><span class="params">(ConfigurationParameters configurationParameters)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.configurationParameters = configurationParameters;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Set&lt;TestDescriptor&gt; <span class="title function_">resolveElement</span><span class="params">(AnnotatedElement element, TestDescriptor parent)</span> &#123;</span><br><span class="line">		<span class="comment">// 1、判断是否为class类型的对象</span></span><br><span class="line">        <span class="keyword">if</span> (!(element <span class="keyword">instanceof</span> Class)) &#123;</span><br><span class="line">			<span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 2、判断是否为潜在的候选者，也就是判断是否为有效的测试类</span></span><br><span class="line">		Class&lt;?&gt; clazz = (Class&lt;?&gt;) element;</span><br><span class="line">		<span class="keyword">if</span> (!isPotentialCandidate(clazz)) &#123;</span><br><span class="line">			<span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 3、创建唯一标识</span></span><br><span class="line">		<span class="type">UniqueId</span> <span class="variable">uniqueId</span> <span class="operator">=</span> createUniqueId(clazz, parent);</span><br><span class="line">        <span class="comment">// 4、创建ClassTestDescriptor对象，并封装到集合中，然后返回</span></span><br><span class="line">		<span class="keyword">return</span> Collections.singleton(resolveClass(clazz, uniqueId));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isPotentialCandidate</span><span class="params">(Class&lt;?&gt; element)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> isPotentialTestContainer.test(element);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> UniqueId <span class="title function_">createUniqueId</span><span class="params">(Class&lt;?&gt; testClass, TestDescriptor parent)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> parent.getUniqueId().append(getSegmentType(), getSegmentValue(testClass));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> TestDescriptor <span class="title function_">resolveClass</span><span class="params">(Class&lt;?&gt; testClass, UniqueId uniqueId)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClassTestDescriptor</span>(uniqueId, testClass, <span class="built_in">this</span>.configurationParameters);</span><br><span class="line">	&#125;</span><br><span class="line">	...... 省略其他方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们再看看解析测试方法的<code>TestMethodResolver</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.junit.jupiter.engine.discovery;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestMethodResolver</span> <span class="keyword">extends</span> <span class="title class_">AbstractMethodResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Predicate&lt;Method&gt; isTestMethod = <span class="keyword">new</span> <span class="title class_">IsTestMethod</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SEGMENT_TYPE</span> <span class="operator">=</span> <span class="string">&quot;method&quot;</span>;</span><br><span class="line"></span><br><span class="line">	TestMethodResolver() &#123;</span><br><span class="line">		<span class="built_in">super</span>(SEGMENT_TYPE, isTestMethod);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span> <span class="comment">// ref-19</span></span><br><span class="line">	<span class="keyword">protected</span> TestDescriptor <span class="title function_">createTestDescriptor</span><span class="params">(UniqueId uniqueId, Class&lt;?&gt; testClass, Method method)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TestMethodTestDescriptor</span>(uniqueId, testClass, method);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>TestMethodResolver</code>中没有看见<code>resolveElement</code>方法，那么应该就在它的父类里面了，我们来详细看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.junit.jupiter.engine.discovery;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractMethodResolver</span> <span class="keyword">implements</span> <span class="title class_">ElementResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">MethodFinder</span> <span class="variable">methodFinder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodFinder</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String segmentType;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Predicate&lt;Method&gt; methodPredicate;</span><br><span class="line"></span><br><span class="line">	AbstractMethodResolver(String segmentType, Predicate&lt;Method&gt; methodPredicate) &#123;</span><br><span class="line">		<span class="built_in">this</span>.segmentType = segmentType;</span><br><span class="line">		<span class="built_in">this</span>.methodPredicate = methodPredicate;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Set&lt;TestDescriptor&gt; <span class="title function_">resolveElement</span><span class="params">(AnnotatedElement element, TestDescriptor parent)</span> &#123;</span><br><span class="line">		<span class="comment">// 1、判断element是否为方法</span></span><br><span class="line">        <span class="keyword">if</span> (!(element <span class="keyword">instanceof</span> Method)) &#123;</span><br><span class="line">			<span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 2、判断方法所在的类是否为测试类</span></span><br><span class="line">		<span class="keyword">if</span> (!(parent <span class="keyword">instanceof</span> ClassTestDescriptor)) &#123;</span><br><span class="line">			<span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 3、判断方法是否为有效的测试方法</span></span><br><span class="line">		<span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> (Method) element;</span><br><span class="line">		<span class="keyword">if</span> (!isRelevantMethod(method)) &#123;</span><br><span class="line">			<span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 4、创建TestMethodTestDescriptor实例对象</span></span><br><span class="line">		<span class="keyword">return</span> Collections.singleton(createTestDescriptor(parent, method));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isRelevantMethod</span><span class="params">(Method candidate)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> methodPredicate.test(candidate);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> UniqueId <span class="title function_">createUniqueId</span><span class="params">(Method method, TestDescriptor parent)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">methodId</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s(%s)&quot;</span>, method.getName(),</span><br><span class="line">			ClassUtils.nullSafeToString(method.getParameterTypes()));</span><br><span class="line">		<span class="keyword">return</span> parent.getUniqueId().append(<span class="built_in">this</span>.segmentType, methodId);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> TestDescriptor <span class="title function_">createTestDescriptor</span><span class="params">(TestDescriptor parent, Method method)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、创建唯一标识</span></span><br><span class="line">		<span class="type">UniqueId</span> <span class="variable">uniqueId</span> <span class="operator">=</span> createUniqueId(method, parent);</span><br><span class="line">        <span class="comment">// 2、获取测试方法对应的测试类</span></span><br><span class="line">		Class&lt;?&gt; testClass = ((ClassTestDescriptor) parent).getTestClass();</span><br><span class="line">        <span class="comment">// 3、调用子类的createTestDescriptor方法，创建实际的TestDescriptor实例。</span></span><br><span class="line">		<span class="keyword">return</span> createTestDescriptor(uniqueId, testClass, method);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">abstract</span> TestDescriptor <span class="title function_">createTestDescriptor</span><span class="params">(UniqueId uniqueId, Class&lt;?&gt; testClass, Method method)</span>;</span><br><span class="line">	...... 省略其他方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们已经了解JUint5发现测试任务的详细过程，那么现在还有一个疑问需要探索，那就是支撑整个测试任务发现过程的<code>MethodSelector</code>是哪儿来的呢？</p>
<p>初步来看，这个<code>request</code>是来自于<code>ref-12</code>处的<code>request</code>，<code>request</code>又是在<code>DefaultLauncher#execute</code>方法传入的，那么可以推断出<code>LauncherDiscoveryRequest</code>类型的实例<code>request</code>是从IDEA的测试插件传入的。让我们详细来看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// github仓库地址：https://github.com/JetBrains/intellij-community</span></span><br><span class="line"><span class="comment">// plugins/junit5_rt/src/com/intellij/junit5/JUnit5IdeaTestRunner.java 文件</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">startRunnerWithArgs</span><span class="params">(String[] args, String name, <span class="type">int</span> count, <span class="type">boolean</span> sendTree)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">JUnit5TestExecutionListener</span> <span class="variable">listener</span> <span class="operator">=</span> myExecutionListeners.get(<span class="number">0</span>);</span><br><span class="line">        listener.initializeIdSuffix(!sendTree);</span><br><span class="line">        <span class="keyword">final</span> String[] packageNameRef = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">1</span>]; <span class="comment">// ref-20</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">LauncherDiscoveryRequest</span> <span class="variable">discoveryRequest</span> <span class="operator">=</span> JUnit5TestRunnerUtil.buildRequest(args, packageNameRef); <span class="comment">// ref-21</span></span><br><span class="line">		...... 省略</span><br><span class="line">        myLauncher.execute(discoveryRequest, listeners.toArray(<span class="keyword">new</span> <span class="title class_">TestExecutionListener</span>[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> listener.wasSuccessful() ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Internal Error occurred.&quot;</span>);</span><br><span class="line">        e.printStackTrace(System.err);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) myExecutionListeners.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上文提到的<code>request</code>就是在<code>ref-21</code>处创建出来的，它的入参<code>packageNameRef</code>是长度为1的空白字符串数组，<code>args</code>是的值为<code>[&quot;com.mucao.CalculatorTest,add&quot;]</code>。</p>
<p>接下来我们看一下创建<code>MethodSelector</code>的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// github仓库地址：https://github.com/JetBrains/intellij-community</span></span><br><span class="line"><span class="comment">// plugins/junit5_rt/src/com/intellij/junit5/JUnit5TestRunnerUtil.java 文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LauncherDiscoveryRequest <span class="title function_">buildRequest</span><span class="params">(String[] suiteClassNames, String[] packageNameRef)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (suiteClassNames.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1、创建builder对象</span></span><br><span class="line">    <span class="type">LauncherDiscoveryRequestBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> LauncherDiscoveryRequestBuilder.request();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (suiteClassNames.length == <span class="number">1</span> &amp;&amp; suiteClassNames[<span class="number">0</span>].charAt(<span class="number">0</span>) == <span class="string">&#x27;@&#x27;</span>) &#123;</span><br><span class="line">        ...... 省略</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2、创建selector对象</span></span><br><span class="line">        <span class="type">DiscoverySelector</span> <span class="variable">selector</span> <span class="operator">=</span> createSelector(suiteClassNames[<span class="number">0</span>], packageNameRef); <span class="comment">//ref-22</span></span><br><span class="line">        <span class="keyword">if</span> (selector <span class="keyword">instanceof</span> MethodSelector &amp;&amp; !loadMethodByReflection((MethodSelector)selector)) &#123;</span><br><span class="line">            <span class="type">DiscoverySelector</span> <span class="variable">classSelector</span> <span class="operator">=</span> createClassSelector(((MethodSelector)selector).getClassName());</span><br><span class="line">            <span class="type">DiscoverySelector</span> <span class="variable">methodSelector</span> <span class="operator">=</span> classSelector <span class="keyword">instanceof</span> NestedClassSelector</span><br><span class="line">                ? DiscoverySelectors.selectMethod(((NestedClassSelector)classSelector).getNestedClassName(),</span><br><span class="line">                                                  ((MethodSelector)selector).getMethodName())</span><br><span class="line">                : selector;</span><br><span class="line">            builder.filters(createMethodFilter(Collections.singletonList(methodSelector)));</span><br><span class="line">            selector = classSelector;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> selector != <span class="literal">null</span> : <span class="string">&quot;selector by class name is never null&quot;</span>;</span><br><span class="line">        <span class="comment">// 3、封装selector对象到builder中，然后构建LauncherDiscoveryRequest</span></span><br><span class="line">        <span class="keyword">return</span> builder.selectors(selector).build(); <span class="comment">// ref-23</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ref-22</code>处创建了<code>DiscoverySelector</code>了，然后经过一系列的判断和处理，然后在<code>ref-23</code>处设置到<code>builder</code>中，最后构建出来一个<code>LauncherDiscoveryRequest</code>对象返回。由于IDEA的debug没有办法挂载到这段属于plugin的代码，所以没有办法跟踪细节，但是大体流程是对着的。</p>
<p>我们在看看<code>createSelector</code>方法的细节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// github仓库地址：https://github.com/JetBrains/intellij-community</span></span><br><span class="line"><span class="comment">// plugins/junit5_rt/src/com/intellij/junit5/JUnit5TestRunnerUtil.java文件</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> DiscoverySelector <span class="title function_">createSelector</span><span class="params">(String line, String[] packageNameRef)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (line.startsWith(<span class="string">&quot;\u001B&quot;</span>)) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">uniqueId</span> <span class="operator">=</span> line.substring(<span class="string">&quot;\u001B&quot;</span>.length());</span><br><span class="line">      <span class="keyword">return</span> DiscoverySelectors.selectUniqueId(uniqueId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (line.startsWith(<span class="string">&quot;\u002B&quot;</span>)) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">directory</span> <span class="operator">=</span> line.substring(<span class="string">&quot;\u002B&quot;</span>.length());</span><br><span class="line">      List&lt;ClasspathRootSelector&gt; selectors = DiscoverySelectors.selectClasspathRoots(Collections.singleton(Paths.get(directory)));</span><br><span class="line">      <span class="keyword">if</span> (selectors.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> selectors.iterator().next();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (line.contains(<span class="string">&quot;,&quot;</span>)) &#123; <span class="comment">// ref-23</span></span><br><span class="line">      <span class="type">MethodSelector</span> <span class="variable">selector</span> <span class="operator">=</span> DiscoverySelectors.selectMethod(line.replaceFirst(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;#&quot;</span>));</span><br><span class="line">      <span class="keyword">if</span> (packageNameRef != <span class="literal">null</span>) &#123;</span><br><span class="line">        packageNameRef[<span class="number">0</span>] = selector.getClassName();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> selector;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (packageNameRef != <span class="literal">null</span>) &#123;</span><br><span class="line">        packageNameRef[<span class="number">0</span>] = line;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> createClassSelector(line);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>args</code>参数的值，可以判断具体会从<code>ref-23</code>处创建<code>MethodSelector</code>，该处调用的代码已经是JUnit5的代码了，我们来详细看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.junit.platform.engine.discovery.DiscoverySelectors.java 文件</span></span><br><span class="line"><span class="meta">@API(status = STABLE, since = &quot;1.0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DiscoverySelectors</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MethodSelector <span class="title function_">selectMethod</span><span class="params">(String fullyQualifiedMethodName)</span> <span class="keyword">throws</span> PreconditionViolationException &#123;</span><br><span class="line">        <span class="comment">// 1、将className, methodName, methodParameters解析出来</span></span><br><span class="line">        String[] methodParts = ReflectionUtils.parseFullyQualifiedMethodName(fullyQualifiedMethodName);</span><br><span class="line">        <span class="comment">// 2、创建MethodSelector</span></span><br><span class="line">        <span class="keyword">return</span> selectMethod(methodParts[<span class="number">0</span>], methodParts[<span class="number">1</span>], methodParts[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MethodSelector <span class="title function_">selectMethod</span><span class="params">(String className, String methodName, String methodParameterTypes)</span> &#123;</span><br><span class="line">        Preconditions.notBlank(className, <span class="string">&quot;Class name must not be null or blank&quot;</span>);</span><br><span class="line">        Preconditions.notBlank(methodName, <span class="string">&quot;Method name must not be null or blank&quot;</span>);</span><br><span class="line">        Preconditions.notNull(methodParameterTypes, <span class="string">&quot;Parameter types must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MethodSelector</span>(className, methodName, methodParameterTypes.trim());</span><br><span class="line">    &#125;</span><br><span class="line">    ...... 省略其他方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟到这儿，我们已经清楚了<code>MethodSelector</code> 的创建和测试任务<code>TestDescriptor</code>的发现，下面由一张图来小总结一下：</p>
<p><img src="/images/Junit5%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%B5%8B%E8%AF%95%E4%BB%BB%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%B5%81%E7%A8%8B.png" alt="Junit5源码分析-测试任务发现流程"></p>
<p>在这个图里面重点注意三个：<code>LauncherDiscoveryRequest</code>、<code>EngineDiscoveryRequest</code>、<code>ExecutionRequest</code>，这三个请求分别对应JUnit5执行测试任务的阶段：启动阶段、引擎发现阶段、任务执行阶段。申明一下，没有在官网找到相关文档，这只是个人的理解。而且，从这儿看出来<strong>JUnit5是把自己当作一个独立运行的服务</strong>，而是被第三方嵌入的SDK，别人向它提交的都是一个个的请求。</p>
<h2 id="二、单元测试方法的参数是怎么解析并获取的？"><a href="#二、单元测试方法的参数是怎么解析并获取的？" class="headerlink" title="二、单元测试方法的参数是怎么解析并获取的？"></a>二、单元测试方法的参数是怎么解析并获取的？</h2><p>我们先来看看JUnit5中实际调用测试方法的地方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.junit.jupiter.engine.execution.ExecutableInvoker#invoke 方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Invoke the supplied method on the supplied target object with dynamic parameter</span></span><br><span class="line"><span class="comment">* resolution.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> method the method to invoke and resolve parameters for</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> target the object on which the method will be invoked; should be</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> null&#125; for static methods</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> extensionContext the current &#123;<span class="doctag">@code</span> ExtensionContext&#125;</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> extensionRegistry the &#123;<span class="doctag">@code</span> ExtensionRegistry&#125; to retrieve</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> ParameterResolvers&#125; from</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Method method, Object target, ExtensionContext extensionContext,</span></span><br><span class="line"><span class="params">                     ExtensionRegistry extensionRegistry)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Optional&lt;Object&gt; optionalTarget = (target <span class="keyword">instanceof</span> Optional ? (Optional&lt;Object&gt;) target</span><br><span class="line">                                       : Optional.ofNullable(target));</span><br><span class="line">    <span class="keyword">return</span> ReflectionUtils.invokeMethod(method, target,</span><br><span class="line">    	resolveParameters(method, optionalTarget, extensionContext, extensionRegistry)); <span class="comment">//ref-24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ref-24</code>处的代码就是解析测试方法参数的地方，我们先看看JUnit5是怎么解析出来参数的？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.junit.jupiter.engine.execution.ExecutableInvoker#resolveParameters 方法</span></span><br><span class="line"><span class="keyword">private</span> Object[] resolveParameters(Executable executable, Optional&lt;Object&gt; target,</span><br><span class="line">                ExtensionContext extensionContext, ExtensionRegistry extensionRegistry) &#123;</span><br><span class="line">    <span class="keyword">return</span> resolveParameters(executable, target, <span class="literal">null</span>, extensionContext, extensionRegistry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.junit.jupiter.engine.execution.ExecutableInvoker#resolveParameters 方法</span></span><br><span class="line"><span class="keyword">private</span> Object[] resolveParameters(Executable executable, Optional&lt;Object&gt; target, Object outerInstance, ExtensionContext extensionContext, ExtensionRegistry extensionRegistry) &#123;</span><br><span class="line"></span><br><span class="line">    Preconditions.notNull(target, <span class="string">&quot;target must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Parameter[] parameters = executable.getParameters();</span><br><span class="line">    Object[] values = <span class="keyword">new</span> <span class="title class_">Object</span>[parameters.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure that the outer instance is resolved as the first parameter if</span></span><br><span class="line">    <span class="comment">// the executable is a constructor for an inner class.</span></span><br><span class="line">    <span class="keyword">if</span> (outerInstance != <span class="literal">null</span>) &#123;</span><br><span class="line">        values[<span class="number">0</span>] = outerInstance;</span><br><span class="line">        start = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Resolve remaining parameters dynamically</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; parameters.length; i++) &#123;</span><br><span class="line">        <span class="type">ParameterContext</span> <span class="variable">parameterContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultParameterContext</span>(parameters[i], i, target);</span><br><span class="line">        values[i] = resolveParameter(parameterContext, executable, extensionContext, extensionRegistry); <span class="comment">// ref-25</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面贴出来的这两个方法，都是在做解析参数前的准备工作，会把方法的形式参数信息拿到，然后去一个一个解析具体参数值，<code>ref-25</code>处代码就是在解析单个具体参数的值。我们接着看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.junit.jupiter.engine.execution.ExecutableInvoker#resolveParameter 方法</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">resolveParameter</span><span class="params">(ParameterContext parameterContext, Executable executable,</span></span><br><span class="line"><span class="params">                ExtensionContext extensionContext, ExtensionRegistry extensionRegistry)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1、获取extensionRegistry中所有的参数解析器</span></span><br><span class="line">        <span class="comment">// @formatter:off</span></span><br><span class="line">        List&lt;ParameterResolver&gt; matchingResolvers = extensionRegistry.stream(ParameterResolver.class)</span><br><span class="line">            .filter(resolver -&gt; resolver.supportsParameter(parameterContext, extensionContext))</span><br><span class="line">            .collect(toList());</span><br><span class="line">        <span class="comment">// @formatter:on</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matchingResolvers.isEmpty()) &#123;</span><br><span class="line">            ...... 抛出异常</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matchingResolvers.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            ...... 抛出异常</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、获取唯一的参数解析器</span></span><br><span class="line">        <span class="type">ParameterResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> matchingResolvers.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 3、参数解析器开始解析参数</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> resolver.resolveParameter(parameterContext, extensionContext); <span class="comment">// ref-26</span></span><br><span class="line">        <span class="comment">// 4、对解析出来的参数验证类型</span></span><br><span class="line">        validateResolvedType(parameterContext.getParameter(), value, executable, resolver);</span><br><span class="line">        ...... 记录日志</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ParameterResolutionException ex) &#123;</span><br><span class="line">        ...... 处理异常</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ref-26</code>处调用唯一的那个参数解析器开始解析具体参数值，<code>resolver#resolveParameter</code>就封装了不同种类参数的具体解析逻辑。</p>
<p>我们看看都有哪些参数解析器实现？</p>
<p><img src="/images/%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB.png" alt="image-20220826121941564"></p>
<ul>
<li><code>RepetitionInfo</code>是解析重复测试的参数，也就是标注了<code>@RepeatedTest</code>的测试方法会用到这个参数解析器。</li>
<li><code>TestReporterParameterResolver</code>在解析参数的时候，会向执行监听器发送事件，并不会解析参数。</li>
<li><code>TestInfoParameterResolver</code>用于将测试信息转入到测试方法中，和<code>@TestInfo</code>注解有关。</li>
<li><code>ParameterizedTestParameterResolver</code>在参数化测试的时候会注入参数到测试方法，和<code>@ParameterizedTest</code>有关。</li>
</ul>
<p>现在还有一个疑问，这些参数解析器从哪儿来的呢？首先我们看看<code>extensionRegistry</code>是从哪儿来的？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.junit.jupiter.engine.descriptor.JupiterEngineDescriptor#prepare 方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> JupiterEngineExecutionContext <span class="title function_">prepare</span><span class="params">(JupiterEngineExecutionContext context)</span> &#123;</span><br><span class="line">    <span class="type">ExtensionRegistry</span> <span class="variable">extensionRegistry</span> <span class="operator">=</span> createRegistryWithDefaultExtensions(context.getConfigurationParameters()); <span class="comment">// ref-27</span></span><br><span class="line">    <span class="type">EngineExecutionListener</span> <span class="variable">executionListener</span> <span class="operator">=</span> context.getExecutionListener();</span><br><span class="line">    <span class="type">ExtensionContext</span> <span class="variable">extensionContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JupiterEngineExtensionContext</span>(executionListener, <span class="built_in">this</span>,</span><br><span class="line">                                                                          context.getConfigurationParameters());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @formatter:off</span></span><br><span class="line">    <span class="keyword">return</span> context.extend()</span><br><span class="line">        .withExtensionRegistry(extensionRegistry)</span><br><span class="line">        .withExtensionContext(extensionContext)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">// @formatter:on</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ExtensionRegistry</code>是在<code>ref-27</code>处创建出来的，我们接着看看创建的具体逻辑？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@API(status = INTERNAL, since = &quot;5.0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtensionRegistry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Extension&gt; DEFAULT_EXTENSIONS = Collections.unmodifiableList(Arrays.asList(<span class="comment">//</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DisabledCondition</span>(), <span class="comment">//</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ScriptExecutionCondition</span>(), <span class="comment">//</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RepeatedTestExtension</span>(), <span class="comment">//</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TestInfoParameterResolver</span>(), <span class="comment">// ref-28</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TestReporterParameterResolver</span>())); <span class="comment">// ref-29</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExtensionRegistry <span class="title function_">createRegistryWithDefaultExtensions</span><span class="params">(ConfigurationParameters configParams)</span> &#123;</span><br><span class="line">        <span class="type">ExtensionRegistry</span> <span class="variable">extensionRegistry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExtensionRegistry</span>(<span class="literal">null</span>);</span><br><span class="line">		...... 打印日志</span><br><span class="line">        <span class="comment">// 1、把默认的扩展器注入到extensionRegistry</span></span><br><span class="line">        DEFAULT_EXTENSIONS.forEach(extensionRegistry::registerDefaultExtension);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2、把自动探测到的扩展器注入到extensionRegistry</span></span><br><span class="line">        <span class="keyword">if</span> (configParams.getBoolean(EXTENSIONS_AUTODETECTION_ENABLED_PROPERTY_NAME).orElse(Boolean.FALSE)) &#123;</span><br><span class="line">            registerAutoDetectedExtensions(extensionRegistry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> extensionRegistry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerAutoDetectedExtensions</span><span class="params">(ExtensionRegistry extensionRegistry)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、使用SPI加载外部的的扩展器</span></span><br><span class="line">        Iterable&lt;Extension&gt; extensions = ServiceLoader.load(Extension.class, ClassLoaderUtils.getDefaultClassLoader());</span><br><span class="line">		...... 打印日志</span><br><span class="line">        <span class="comment">// 2、将加载到的扩展器注入到extensionRegistry</span></span><br><span class="line">        extensions.forEach(extensionRegistry::registerDefaultExtension);</span><br><span class="line">    &#125;</span><br><span class="line">	...... 省略其他方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来我们的参数解析器是以扩展器<code>Extension</code>的形式注入到<code>ExtensionRegistry</code>，<code>ref-28</code>和<code>ref-29</code>处就是<code>TestInfoParameterResolver</code>和<code>TestReporterParameterResolver</code>参数解析器。</p>
<p>我们最后在看下<code>extensionRegistry::registerDefaultExtension</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.junit.jupiter.engine.extension.ExtensionRegistry#registerDefaultExtension 方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerDefaultExtension</span><span class="params">(Extension extension)</span> &#123;</span><br><span class="line">    <span class="comment">// 1、添加扩展器</span></span><br><span class="line">    <span class="built_in">this</span>.registeredExtensions.add(extension);</span><br><span class="line">    <span class="comment">// 2、增加扩展器的类型</span></span><br><span class="line">    <span class="built_in">this</span>.registeredExtensionTypes.add(extension.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小总结，参数解析器就是以<code>Extention</code>的形式添加到<code>RegistryExtention</code>中，然后在执行测试方法之前，就可以拿出来进行调用，解析处需要的参数，传递给测试方法，就可以执行了。</p>
]]></content>
      <categories>
        <category>Java - 测试</category>
      </categories>
      <tags>
        <tag>JUnit5</tag>
      </tags>
  </entry>
  <entry>
    <title>DDocker探索之旅</title>
    <url>/2022/09/03/Docker%E6%8E%A2%E7%B4%A2%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<p>下面是对整个Docker知识的总览。</p>
<p><img src="/images/image-20220903220420627.png" alt="image-20220903220420627"></p>
<span id="more"></span>

<hr>
<p><img src="/images/image-20220903220514787.png" alt="image-20220903220514787"></p>
<hr>
<p><img src="/images/image-20220903220549127.png" alt="image-20220903220549127"></p>
<hr>
<p><img src="/images/image-20220903220614201.png" alt="image-20220903220614201"></p>
<hr>
<p><img src="/images/image-20220903220634394.png" alt="image-20220903220634394"></p>
<hr>
<p><img src="/images/image-20220903220657929.png" alt="image-20220903220657929"></p>
<hr>
<p><img src="/images/image-20220903220719107.png" alt="image-20220903220719107"></p>
<hr>
<p><img src="/images/image-20220903220739251.png" alt="image-20220903220739251"></p>
<hr>
<p><img src="/images/image-20220903220800556.png" alt="image-20220903220800556"></p>
<hr>
<p><img src="/images/image-20220903220852425.png" alt="image-20220903220852425"></p>
<hr>
<p><img src="/images/image-20220903220921107.png" alt="image-20220903220921107"></p>
<hr>
<p><img src="/images/image-20220903220940325.png" alt="image-20220903220940325"></p>
<hr>
<p><img src="/images/image-20220903220959806.png" alt="image-20220903220959806"></p>
<hr>
<p><img src="/images/image-20220903221018838.png" alt="image-20220903221018838"></p>
<hr>
<p><img src="/images/image-20220903221046629.png" alt="image-20220903221046629"></p>
<hr>
<p><img src="/images/image-20220903221119145.png" alt="image-20220903221119145"></p>
<hr>
<p><img src="/images/image-20220903221137967.png" alt="image-20220903221137967"></p>
<hr>
<p><img src="/images/image-20220903221158160.png" alt="image-20220903221158160"></p>
<hr>
<p><img src="/images/image-20220903221221106.png" alt="image-20220903221221106"></p>
]]></content>
      <categories>
        <category>虚拟化 - 容器</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty学习笔记</title>
    <url>/2022/09/03/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Netty 是一个 NIO 客户端服务器框架，可快速轻松地开发网络应用程序，例如协议服务器和客户端。它极大地简化和简化了网络编程，例如 TCP 和 UDP 套接字服务器。</p>
<p>“快速简便”并不意味着最终的应用程序将遭受可维护性或性能问题的困扰。Netty 经过精心设计，结合了许多协议（例如FTP，SMTP，HTTP 以及各种基于二进制和文本的旧式协议）的实施经验。结果，Netty 成功地找到了一种无需妥协即可轻松实现开发，性能，稳定性和灵活性的方法。</p>
<p><img src="/images/3031480eb2c5d3fa2ee10cd7c232a6a7.png" alt="img"></p>
<span id="more"></span>

<h2 id="二、Netty-执行流程"><a href="#二、Netty-执行流程" class="headerlink" title="二、Netty 执行流程"></a>二、Netty 执行流程</h2><p><img src="/images/a24e12f2282106f1accab91b88e2a5e3.png" alt="img"></p>
<h2 id="三、Netty-核心组件"><a href="#三、Netty-核心组件" class="headerlink" title="三、Netty 核心组件"></a>三、Netty 核心组件</h2><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>Channel是 Java NIO 的一个基本构造。可以看作是传入或传出数据的载体。因此，它可以被打开或关闭，连接或者断开连接。</p>
<h3 id="EventLoop-与-EventLoopGroup"><a href="#EventLoop-与-EventLoopGroup" class="headerlink" title="EventLoop 与 EventLoopGroup"></a>EventLoop 与 EventLoopGroup</h3><p>EventLoop 定义了Netty的核心抽象，用来处理连接的生命周期中所发生的事件，在内部，将会为每个Channel分配一个EventLoop。</p>
<p>EventLoopGroup 是一个 EventLoop 池，包含很多的 EventLoop。</p>
<p>Netty 为每个 Channel 分配了一个 EventLoop，用于处理用户连接请求、对用户请求的处理等所有事件。EventLoop 本身只是一个线程驱动，在其生命周期内只会绑定一个线程，让该线程处理一个 Channel 的所有 IO 事件。</p>
<p>一个 Channel 一旦与一个 EventLoop 相绑定，那么在 Channel 的整个生命周期内是不能改变的。一个 EventLoop 可以与多个 Channel 绑定。即 Channel 与 EventLoop 的关系是 n:1，而 EventLoop 与线程的关系是 1:1。</p>
<h3 id="ServerBootstrap-与-Bootstrap"><a href="#ServerBootstrap-与-Bootstrap" class="headerlink" title="ServerBootstrap 与 Bootstrap"></a>ServerBootstrap 与 Bootstrap</h3><p>Bootstarp 和 ServerBootstrap 被称为引导类，指对应用程序进行配置，并使他运行起来的过程。Netty处理引导的方式是使你的应用程序和网络层相隔离。<br>Bootstrap 是客户端的引导类，Bootstrap 在调用 bind()（连接UDP）和 connect()（连接TCP）方法时，会新创建一个 Channel，仅创建一个单独的、没有父 Channel 的 Channel 来实现所有的网络交换。</p>
<p>ServerBootstrap 是服务端的引导类，ServerBootstarp 在调用 bind() 方法时会创建一个 ServerChannel 来接受来自客户端的连接，并且该 ServerChannel 管理了多个子 Channel 用于同客户端之间的通信。</p>
<h3 id="ChannelHandler-与-ChannelPipeline"><a href="#ChannelHandler-与-ChannelPipeline" class="headerlink" title="ChannelHandler 与 ChannelPipeline"></a>ChannelHandler 与 ChannelPipeline</h3><p>ChannelHandler 是对 Channel 中数据的处理器，这些处理器可以是系统本身定义好的编解码器，也可以是用户自定义的。这些处理器会被统一添加到一个 ChannelPipeline 的对象中，然后按照添加的顺序对 Channel 中的数据进行依次处理。</p>
<h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><p>Netty 中所有的 I&#x2F;O 操作都是异步的，即操作不会立即得到返回结果，所以 Netty 中定义了一个 ChannelFuture 对象作为这个异步操作的“代言人”，表示异步操作本身。如果想获取到该异步操作的返回值，可以通过该异步操作对象的addListener() 方法为该异步操作添加监 NIO 网络编程框架 Netty 听器，为其注册回调：当结果出来后马上调用执行。</p>
<p>Netty 的异步编程模型都是建立在 Future 与回调概念之上的。</p>
<h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><h3 id="Netty-Server-代码"><a href="#Netty-Server-代码" class="headerlink" title="Netty - Server 代码"></a>Netty - Server 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">parentGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">childGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            bootstrap.group(parentGroup, childGroup)</span><br><span class="line">                     .channel(NioServerSocketChannel.class)</span><br><span class="line">                     .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">SomeSocketServerHandler</span>());</span><br><span class="line">                         &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.bind(<span class="number">8888</span>).sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器已启动。。。&quot;</span>);</span><br><span class="line"></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            parentGroup.shutdownGracefully();</span><br><span class="line">            childGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Server-端-Handler"><a href="#Server-端-Handler" class="headerlink" title="Server 端 Handler"></a>Server 端 Handler</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSocketServerHandler</span></span><br><span class="line">                       <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Client Address ====== &quot;</span> + ctx.channel().remoteAddress());</span><br><span class="line">        ctx.channel().writeAndFlush(<span class="string">&quot;from server:&quot;</span> + UUID.randomUUID());</span><br><span class="line">        ctx.fireChannelActive();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx,</span></span><br><span class="line"><span class="params">                                Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Netty-Client-代码"><a href="#Netty-Client-代码" class="headerlink" title="Netty - Client 代码"></a>Netty - Client 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">eventLoopGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.group(eventLoopGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>(CharsetUtil.UTF_8));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>(CharsetUtil.UTF_8));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">DemoSocketClientHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(eventLoopGroup != <span class="literal">null</span>) &#123;</span><br><span class="line">                eventLoopGroup.shutdownGracefully();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Client-端-Handler"><a href="#Client-端-Handler" class="headerlink" title="Client 端 Handler"></a>Client 端 Handler</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSocketClientHandler</span></span><br><span class="line">               <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        ctx.channel().writeAndFlush(<span class="string">&quot;from client: &quot;</span> + System.currentTimeMillis());</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Overrid</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.channel().writeAndFlush(<span class="string">&quot;from client：begin talking&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx,</span></span><br><span class="line"><span class="params">                                Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Reactor线程模型"><a href="#Reactor线程模型" class="headerlink" title="Reactor线程模型"></a>Reactor线程模型</h2><h4 id="单线程的-Reactor-模型"><a href="#单线程的-Reactor-模型" class="headerlink" title="单线程的 Reactor 模型"></a>单线程的 Reactor 模型</h4><p><img src="/images/2eb0dda03835704509aa0e7e128697f4.png" alt="img"></p>
<h4 id="多线程的-Reactor-模型"><a href="#多线程的-Reactor-模型" class="headerlink" title="多线程的 Reactor 模型"></a>多线程的 Reactor 模型</h4><p><img src="/images/e8dc2b8decb27544a1bf9d1d0e41210e.png" alt="img"></p>
<h4 id="多线程主从-Reactor-模型"><a href="#多线程主从-Reactor-模型" class="headerlink" title="多线程主从 Reactor 模型"></a>多线程主从 Reactor 模型</h4><p><img src="/images/e438aafa106af5b9fc5f1e54761eb5a1.png" alt="img"></p>
<h2 id="EventLoop-与-EventLoopGroup分析"><a href="#EventLoop-与-EventLoopGroup分析" class="headerlink" title="EventLoop 与 EventLoopGroup分析"></a>EventLoop 与 EventLoopGroup分析</h2><p><img src="/images/NioEventLoop%E6%B5%81%E7%A8%8B.webp" alt="img"></p>
<h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2><p>1、官网地址: <a href="https://netty.io/">https://netty.io/</a></p>
<p>2、Github地址：<a href="https://github.com/netty/netty">https://github.com/netty/netty</a></p>
<p>3、<a href="https://blog.csdn.net/qq_35190492/article/details/113174359">肝了一月的Netty知识点</a></p>
<p>4、<a href="https://waylau.gitbooks.io/essential-netty-in-action/content/">Essential Netty in Action 《Netty 实战(精髓)》</a></p>
<p>5、<a href="https://www.jianshu.com/p/0d0eece6d467">netty源码分析之揭开reactor线程的面纱（一）</a></p>
<p>6、<a href="https://www.jianshu.com/p/467a9b41833e">netty源码分析之揭开reactor线程的面纱（二）</a></p>
<p>7、<a href="https://www.jianshu.com/p/58fad8e42379">netty源码分析之揭开reactor线程的面纱（三）</a></p>
]]></content>
      <categories>
        <category>编程 - 框架</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis使用示例</title>
    <url>/2022/09/04/MyBatis%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<p>在这篇文档中将给出MyBatis的使用例子，让自己在例子中进行学习。</p>
<h2 id="一、准备MySQL"><a href="#一、准备MySQL" class="headerlink" title="一、准备MySQL"></a>一、准备MySQL</h2><p>直接使用Docker来创建一个MySQL容器使用了。创建容器的命令如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run --name my-mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=&lt;设置root密码&gt; -e MYSQL_USER=&lt;设置用户名&gt; -e MYSQL_PASSWORD=&lt;设置用户密码&gt; -e MYSQL_DATABASE=<span class="built_in">test</span>  -d mysql:oracle</span><br></pre></td></tr></table></figure>

<p>然后登录到MySQL容器中，使用下面的命令进入mysql:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysql -u &lt;用户名&gt; -p          <span class="comment"># 回车之后输入用户密码，就可以登录进入mysql了</span></span><br></pre></td></tr></table></figure>

<p>接下来需要创建表格并插入数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建表格</span><br><span class="line">CREATE TABLE IF NOT EXISTS `Blog`(</span><br><span class="line">   `id` INT UNSIGNED AUTO_INCREMENT,</span><br><span class="line">   `title` VARCHAR(100) NOT NULL,</span><br><span class="line">   `author` VARCHAR(40) NOT NULL,</span><br><span class="line">   PRIMARY KEY ( `id` )</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 插入数据</span><br><span class="line">INSERT INTO Blog (title, author) VALUES ( &#x27;人生困惑20讲&#x27;, &#x27;哈哈&#x27;);</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="二、编写MyBatis示例代码"><a href="#二、编写MyBatis示例代码" class="headerlink" title="二、编写MyBatis示例代码"></a>二、编写MyBatis示例代码</h2><p>先声明，使用maven构建的工程。我们首先看一下整个工程的文件目录结构：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">studyMyBatis/</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── java</span><br><span class="line">    │   │   └── org</span><br><span class="line">    │   │       └── mybatis</span><br><span class="line">    │   │           └── example</span><br><span class="line">    │   │               ├── Blog.java</span><br><span class="line">    │   │               ├── BlogMapper.java</span><br><span class="line">    │   │               └── Example.java</span><br><span class="line">    │   └── resources</span><br><span class="line">    │       └── org</span><br><span class="line">    │           └── mybatis</span><br><span class="line">    │               └── example</span><br><span class="line">    │                   ├── BlogMapper.xml</span><br><span class="line">    │                   └── mybatis-config.xml</span><br><span class="line">    └── <span class="built_in">test</span></span><br><span class="line">        └── java</span><br></pre></td></tr></table></figure>



<h3 id="1、添加MyBatis和其他需要使用的依赖。"><a href="#1、添加MyBatis和其他需要使用的依赖。" class="headerlink" title="1、添加MyBatis和其他需要使用的依赖。"></a>1、添加MyBatis和其他需要使用的依赖。</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MyBatis依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mysql驱动依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- lombok方便生成getter、setter方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="2、MyBatis配置文件"><a href="#2、MyBatis配置文件" class="headerlink" title="2、MyBatis配置文件"></a>2、MyBatis配置文件</h3><p>文件名：mybatis-config.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用MyBatis时的配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 配置事务类型 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span> <span class="comment">&lt;!-- 数据源 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&lt;用户名&gt;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&lt;用户密码&gt;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span> <span class="comment">&lt;!-- 指定Mapper的配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="3、映射器配置文件"><a href="#3、映射器配置文件" class="headerlink" title="3、映射器配置文件"></a>3、映射器配置文件</h3><p>文件名：BlogMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- BlogMapper映射器的配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.mybatis.example.BlogMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.mybatis.example.Blog&quot;</span>&gt;</span></span><br><span class="line">        select *</span><br><span class="line">        from Blog</span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="4、映射器接口和实体类"><a href="#4、映射器接口和实体类" class="headerlink" title="4、映射器接口和实体类"></a>4、映射器接口和实体类</h3><p>映射器接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mybatis.example;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用MyBatis时对于Blog类型的映射器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlogMapper</span> &#123;</span><br><span class="line">    Blog <span class="title function_">selectBlog</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mybatis.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述博客文章的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Blog</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5、示例程序"><a href="#5、示例程序" class="headerlink" title="5、示例程序"></a>5、示例程序</h3><p>所有的准备代码都有了，最后就该写我们的示例程序了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mybatis.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示MyBatis的基本使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;org/mybatis/example/mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">            <span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(BlogMapper.class);</span><br><span class="line">            <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> mapper.selectBlog(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;查询结果: &quot;</span> + blog);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">查询结果: Blog(<span class="built_in">id</span>=1, title=人生困惑20讲, author=哈哈)</span><br></pre></td></tr></table></figure>



<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>这个例子虽然简单，但是使用MyBatis时基本的知识都涉及到了。配置文件、映射器、SqlSessionFactoryBuilder、sqlSessionFactory、SqlSession都有体现。如果要深入了解某一个方面的话，阅读参考文档的相关章节就可以了。</p>
]]></content>
      <categories>
        <category>编程 - 框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis基础知识</title>
    <url>/2022/09/04/MyBatis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>官网地址：<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></p>
<h2 id="一、MyBatis是什么？"><a href="#一、MyBatis是什么？" class="headerlink" title="一、MyBatis是什么？"></a>一、MyBatis是什么？</h2><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><p>要使用 MyBatis， 只需将 <a href="https://github.com/mybatis/mybatis-3/releases">mybatis-x.x.x.jar</a> 文件置于类路径（classpath）中即可。</p>
<p>如果使用 Maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="三、从-XML-中构建-SqlSessionFactory"><a href="#三、从-XML-中构建-SqlSessionFactory" class="headerlink" title="三、从 XML 中构建 SqlSessionFactory"></a>三、从 XML 中构建 SqlSessionFactory</h2><p><strong>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的</strong>。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。</p>
<p>从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（InputStream）实例，比如用文件路径字符串或 file:&#x2F;&#x2F; URL 构造的输入流。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;org/mybatis/example/mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br></pre></td></tr></table></figure>

<p>XML 配置文件中包含了对 MyBatis 系统的核心设置，包括获取数据库连接实例的数据源（DataSource）以及决定事务作用域和控制方式的事务管理器（TransactionManager）。后面会再探讨 XML 配置文件的详细内容，这里先给出一个简单的示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然，还有很多可以在 XML 文件中配置的选项，上面的示例仅罗列了最关键的部分。 注意 XML 头部的声明，它用来验证 XML 文档的正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则包含了一组映射器（mapper），这些映射器的 XML 映射文件包含了 SQL 代码和映射定义信息。</p>
<h2 id="不使用-XML-构建-SqlSessionFactory"><a href="#不使用-XML-构建-SqlSessionFactory" class="headerlink" title="不使用 XML 构建 SqlSessionFactory"></a>不使用 XML 构建 SqlSessionFactory</h2><p>如果你更愿意直接从 Java 代码而不是 XML 文件中创建配置，或者想要创建你自己的配置构建器，MyBatis 也提供了完整的配置类，提供了所有与 XML 文件等价的配置项。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> BlogDataSourceFactory.getBlogDataSource();</span><br><span class="line"><span class="type">TransactionFactory</span> <span class="variable">transactionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTransactionFactory</span>();</span><br><span class="line"><span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Environment</span>(<span class="string">&quot;development&quot;</span>, transactionFactory, dataSource);</span><br><span class="line"><span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>(environment);</span><br><span class="line">configuration.addMapper(BlogMapper.class);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(configuration);</span><br></pre></td></tr></table></figure>

<p>注意该例中，configuration 添加了一个映射器类（mapper class）。映射器类是 Java 类，它们包含 SQL 映射注解从而避免依赖 XML 映射文件。不过，由于 Java 注解的一些限制以及某些 MyBatis 映射的复杂性，要使用大多数高级映射（比如：嵌套联合映射），仍然需要使用 XML 映射文件进行映射。有鉴于此，如果存在一个同名 XML 映射文件，MyBatis 会自动查找并加载它（在这个例子中，基于类路径和 BlogMapper.class 的类名，会加载 BlogMapper.xml）。具体细节稍后讨论。</p>
<h2 id="从-SqlSessionFactory-中获取-SqlSession"><a href="#从-SqlSessionFactory-中获取-SqlSession" class="headerlink" title="从 SqlSessionFactory 中获取 SqlSession"></a>从 SqlSessionFactory 中获取 SqlSession</h2><p>既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">    <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> (Blog) session.selectOne(<span class="string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>, <span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>诚然，这种方式能够正常工作，对使用旧版本 MyBatis 的用户来说也比较熟悉。但现在有了一种更简洁的方式——使用和指定语句的参数和返回值相匹配的接口（比如 BlogMapper.class），现在你的代码不仅更清晰，更加类型安全，还不用担心可能出错的字符串字面值以及强制类型转换。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">    <span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(BlogMapper.class);</span><br><span class="line">    <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> mapper.selectBlog(<span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们来探究一下这段代码究竟做了些什么。</p>
<h2 id="探究已映射的-SQL-语句"><a href="#探究已映射的-SQL-语句" class="headerlink" title="探究已映射的 SQL 语句"></a>探究已映射的 SQL 语句</h2><p>现在你可能很想知道 SqlSession 和 Mapper 到底具体执行了些什么操作，但 SQL 语句映射是个相当广泛的话题，可能会占去文档的大部分篇幅。 但为了让你能够了解个大概，这里先给出几个例子。</p>
<p>在上面提到的例子中，一个语句既可以通过 XML 定义，也可以通过注解定义。我们先看看 XML 定义语句的方式，事实上 MyBatis 提供的所有特性都可以利用基于 XML 的映射语言来实现，这使得 MyBatis 在过去的数年间得以流行。如果你用过旧版本的 MyBatis，你应该对这个概念比较熟悉。 但相比于之前的版本，新版本改进了许多 XML 的配置，后面我们会提到这些改进。这里给出一个基于 XML 映射语句的示例，它应该可以满足上个示例中 SqlSession 的调用。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.mybatis.example.BlogMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">        select * from Blog where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了这个简单的例子，我们似乎写了不少配置，但其实并不多。在一个 XML 映射文件中，可以定义无数个映射语句，这样一来，XML 头部和文档类型声明部分就显得微不足道了。文档的其它部分很直白，容易理解。 它在命名空间 “org.mybatis.example.BlogMapper” 中定义了一个名为 “selectBlog” 的映射语句，这样你就可以用全限定名 “org.mybatis.example.BlogMapper.selectBlog” 来调用映射语句了，就像上面例子中那样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> (Blog) session.selectOne(<span class="string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>, <span class="number">101</span>);</span><br></pre></td></tr></table></figure>

<p>你可能会注意到，<strong>这种方式和用全限定名调用 Java 对象的方法类似</strong>。这样，该命名就可以直接映射到在命名空间中同名的映射器类，并将已映射的 select 语句匹配到对应名称、参数和返回类型的方法。因此你就可以像上面那样，不费吹灰之力地在对应的映射器接口调用方法，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(BlogMapper.class);</span><br><span class="line"><span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> mapper.selectBlog(<span class="number">101</span>);</span><br></pre></td></tr></table></figure>

<p>第二种方法有很多优势，首先它不依赖于字符串字面值，会更安全一点；其次，如果你的 IDE 有代码补全功能，那么代码补全可以帮你快速选择到映射好的 SQL 语句。</p>
<blockquote>
<p><strong>对命名空间的一点补充</strong></p>
<p>在之前版本的 MyBatis 中，<strong>命名空间（Namespaces）</strong>的作用并不大，是可选的。 但现在，随着命名空间越发重要，你必须指定命名空间。</p>
<p>命名空间的作用有两个，一个是利用更长的全限定名来将不同的语句隔离开来，同时也实现了你上面见到的接口绑定。就算你觉得暂时用不到接口绑定，你也应该遵循这里的规定，以防哪天你改变了主意。 长远来看，只要将命名空间置于合适的 Java 包命名空间之中，你的代码会变得更加整洁，也有利于你更方便地使用 MyBatis。</p>
<p><strong>命名解析：</strong>为了减少输入量，MyBatis 对所有具有名称的配置元素（包括语句，结果映射，缓存等）使用了如下的命名解析规则。</p>
<ul>
<li>全限定名（比如 “com.mypackage.MyMapper.selectAllThings）将被直接用于查找及使用。</li>
<li>短名称（比如 “selectAllThings”）如果全局唯一也可以作为一个单独的引用。 如果不唯一，有两个或两个以上的相同名称（比如 “com.foo.selectAllThings” 和 “com.bar.selectAllThings”），那么使用时就会产生“短名称不唯一”的错误，这种情况下就必须使用全限定名。</li>
</ul>
</blockquote>
<p>对于像 BlogMapper 这样的映射器类来说，还有另一种方法来完成语句映射。 它们映射的语句可以不用 XML 来配置，而可以使用 Java 注解来配置。比如，上面的 XML 示例可以被替换成如下的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mybatis.example;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlogMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM blog WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    Blog <span class="title function_">selectBlog</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java 注解不仅力不从心，还会让本就复杂的 SQL 语句更加混乱不堪。 因此，如果你需要做一些很复杂的操作，最好用 XML 来映射语句。</p>
<p>选择何种方式来配置映射，以及是否应该要统一映射语句定义的形式，完全取决于你和你的团队。 换句话说，永远不要拘泥于一种方式，你可以很轻松地在基于注解和 XML 的语句映射方式间自由移植和切换。</p>
<h2 id="作用域（Scope）和生命周期"><a href="#作用域（Scope）和生命周期" class="headerlink" title="作用域（Scope）和生命周期"></a>作用域（Scope）和生命周期</h2><p>理解我们之前讨论过的不同作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题。</p>
<blockquote>
<p><strong>对象生命周期和依赖注入框架</strong></p>
<p>依赖注入框架可以创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。 如果对如何通过依赖注入框架使用 MyBatis 感兴趣，可以研究一下 MyBatis-Spring 或 MyBatis-Guice 两个子项目。</p>
</blockquote>
<h3 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h3><p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 <strong>因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）</strong>。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。</p>
<h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。<strong>因此 SqlSessionFactory 的最佳作用域是应用作用域</strong>。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p>
<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><p>每个线程都应该有它自己的 SqlSession 实例。<strong>SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域</strong>。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">    <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在所有代码中都遵循这种使用模式，可以保证所有数据库资源都能被正确地关闭。</p>
<h3 id="映射器实例"><a href="#映射器实例" class="headerlink" title="映射器实例"></a>映射器实例</h3><p>映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 SqlSession 相同。但<strong>方法作用域才是映射器实例的最合适的作用域</strong>。 也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。 映射器实例并不需要被显式地关闭。尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像 SqlSession 的资源会让你忙不过来。 因此，最好将映射器放在方法作用域内。就像下面的例子一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">    <span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(BlogMapper.class);</span><br><span class="line">    <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程 - 框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
</search>
