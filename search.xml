<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>异步操作测试工具Awaitility</title>
    <url>/2022/07/06/%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7Awaitility/</url>
    <content><![CDATA[<p>平时在写单元测试的时候，经常会遇到一些异步场景，不确定异步线程中当前的执行状态是否已经达到自己预期的观测点，这个时候我们都会使用<code>Thread.sleep(time)</code>方式武断的等待一段时间，或者自己写个while死循环来不停的检测某个条件是否满足。前一种方式会浪费测试用例执行时间，后一种方式不够优雅。awaitility工具就是用来解决这个场景的。</p>
<span id="more"></span>

<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>异步系统难以测试。不仅因为需要处理多线程、超时和并发问题，还因为这些细节会遮蔽测试代码的意图。Awaitility是一个DSL，允许你准确且易读地表达对于异步系统的期望。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updatesCustomerStatus</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Publish an asynchronous message to a broker (e.g. RabbitMQ):</span></span><br><span class="line">    messageBroker.publishMessage(updateCustomerStatusMessage);</span><br><span class="line">    <span class="comment">// Awaitility lets you wait until the asynchronous operation completes:</span></span><br><span class="line">    await().atMost(<span class="number">5</span>, SECONDS).until(customerStatusIsUpdated());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><p>Maven:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.awaitility<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>awaitility<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Gradle（Groovy DSL）:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">testImplementation <span class="string">&#x27;org.awaitility:awaitility:4.2.0&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="三、静态导入"><a href="#三、静态导入" class="headerlink" title="三、静态导入"></a>三、静态导入</h2><p>为了有效地使用Awaitility，建议从Awaitility框架静态导入如下方法：</p>
<ul>
<li><code>org.awaitility.Awaitility.*</code></li>
</ul>
<p>导入下面这些方法可能也是有用的：</p>
<ul>
<li><code>java.time.Duration.*</code></li>
<li><code>java.util.concurrent.TimeUnit.*</code></li>
<li><code>org.hamcrest.Matchers.*</code></li>
<li><code>org.junit.Assert.*</code></li>
</ul>
<h2 id="四、使用示例"><a href="#四、使用示例" class="headerlink" title="四、使用示例"></a>四、使用示例</h2><h3 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h3><p>假设我们发送”add user”消息给我们的异步系统，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">publish(<span class="keyword">new</span> <span class="title class_">AddUserMessage</span>(<span class="string">&quot;Awaitility Rocks&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>在你的测试用例中，Awaitility可以帮助你轻松的检测数据库已经被更新了。最简单的形式就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().until(newUserIsAdded());</span><br></pre></td></tr></table></figure>

<p>在测试用例中你自己得实现<code>newUserIsAdded</code>方法。只有当它指定的条件被满足了，Awaitility才会停止等待。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Callable&lt;Boolean&gt; <span class="title function_">newUserIsAdded</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> () -&gt; userRepository.size() == <span class="number">1</span>; <span class="comment">// The condition that must be fulfilled</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你当然也可以内联<code>newUserIsAdded</code>方法，就像下面这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().until(() -&gt; userRepository.size() == <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>默认情况下Awaitility将会等待10秒钟，并且当到这个时间的时候如果用户仓库的数据量不等于1，那么它就会抛出一个<a href="http://static.javadoc.io/org.awaitility/awaitility/4.2.0/org/awaitility/core/ConditionTimeoutException.html">ConditionTimeoutException</a>异常来使测试失败。如果你想要不同的超时时间，你可以像下面这样定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().atMost(<span class="number">5</span>, SECONDS).until(newUserWasAdded());</span><br></pre></td></tr></table></figure>

<h3 id="复用等待条件"><a href="#复用等待条件" class="headerlink" title="复用等待条件"></a>复用等待条件</h3><p>Awaitility也支持分割等待条件为数据提供（supplying）和条件匹配（matching）部分，这样可以更好的使用。下面是例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().until( userRepositorySize(), equalTo(<span class="number">1</span>) );</span><br></pre></td></tr></table></figure>

<p><code>userRepositorySize</code>方法现在是一个<code>Integer</code>类型的<code>Callable</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Callable&lt;Integer&gt; <span class="title function_">userRepositorySize</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> () -&gt; userRepository.size(); <span class="comment">// The suppling part of the condition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>equalTo</code> 是一个标准的 <a href="http://code.google.com/p/hamcrest/">Hamcrest</a> 匹配器（matcher），为Awaitility指定条件匹配部分。</p>
<p>现在我们可以在不同的测试用例中重用<code>userRepositorySize</code>。假设我们有一个测试用例在同一时间添加三个用户（user）对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">publish(<span class="keyword">new</span> <span class="title class_">AddUserMessage</span>(<span class="string">&quot;User 1&quot;</span>), <span class="keyword">new</span> <span class="title class_">AddUserMessage</span>(<span class="string">&quot;User 2&quot;</span>), <span class="keyword">new</span> <span class="title class_">AddUserMessage</span>(<span class="string">&quot;User 3&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>我们现在重用<code>userRepositorySize</code> “condition supplier”，并且简单的更新Hamcrest匹配器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().until( userRepositorySize(), equalTo(<span class="number">3</span>) );</span><br></pre></td></tr></table></figure>

<p>在下面这种简单的例子中，你当然也可以利用Java的方法引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().until(userRepository::size, equalTo(<span class="number">3</span>) );</span><br></pre></td></tr></table></figure>

<h3 id="字段类型条件"><a href="#字段类型条件" class="headerlink" title="字段类型条件"></a>字段类型条件</h3><p>你也可以通过字段引用来构建数据提供部分，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().until( fieldIn(object).ofType(<span class="type">int</span>.class), equalTo(<span class="number">2</span>) );</span><br></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().until( fieldIn(object).ofType(<span class="type">int</span>.class).andWithName(<span class="string">&quot;fieldName&quot;</span>), equalTo(<span class="number">2</span>) );</span><br></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().until( fieldIn(object).ofType(<span class="type">int</span>.class).andAnnotatedWith(MyAnnotation.class), equalTo(<span class="number">2</span>) );</span><br></pre></td></tr></table></figure>

<h3 id="Atomic-Adders-and-Accumulators"><a href="#Atomic-Adders-and-Accumulators" class="headerlink" title="Atomic, Adders and Accumulators"></a>Atomic, Adders and Accumulators</h3><p>如果你正在使用原子类型（Atomic），Awaitility提供简单的方法设置等待条件，直到原子类变量满足特定的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">atomic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// Do some async stuff that eventually updates the atomic integer</span></span><br><span class="line">await().untilAtomic(atomic, equalTo(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>等待一个<code>AtomicBoolean</code>更加简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AtomicBoolean</span> <span class="variable">atomic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// Do some async stuff that eventually updates the atomic boolean</span></span><br><span class="line">await().untilTrue(atomic);</span><br></pre></td></tr></table></figure>

<p>如果你在使用Adders，例如 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/LongAdder.html">LongAdder</a>，Awaitility允许你简单等待它到达一个特定值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().untilAdder(myLongAdder, equalTo(<span class="number">5L</span>))</span><br></pre></td></tr></table></figure>

<p>Likewise, if using Accumulators such as <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/LongAccumulator.html">LongAccumulator</a>, you can do:</p>
<p>同样地，如果使用Accumulators例如 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/LongAccumulator.html">LongAccumulator</a>，你可以像下面这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().untilAccumulator(myLongAccumulator, equalTo(<span class="number">5L</span>))</span><br></pre></td></tr></table></figure>



<h3 id="Lambdas"><a href="#Lambdas" class="headerlink" title="Lambdas"></a>Lambdas</h3><p>你可以条件中使用lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().atMost(<span class="number">5</span>, SECONDS).until(() -&gt; userRepository.size() == <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>或者方法引用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().atMost(<span class="number">5</span>, SECONDS).until(userRepository::isNotEmpty);</span><br></pre></td></tr></table></figure>

<p>或者组合方法引用和Hamcrest匹配器（matchers）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().atMost(<span class="number">5</span>, SECONDS).until(userRepository::size, is(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>你也可以使用断言：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().atMost(<span class="number">5</span>, SECONDS).until(userRepository::size, size -&gt; size == <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>使用示例参考： <a href="http://www.jayway.com/2014/04/23/java-8-and-assertj-support-in-awaitility-1-6-0/">Jayway team blog</a>.</p>
<h3 id="使用AssertJ或者Fest-Assert"><a href="#使用AssertJ或者Fest-Assert" class="headerlink" title="使用AssertJ或者Fest Assert"></a>使用AssertJ或者Fest Assert</h3><p>你可以使用 <a href="http://joel-costigliola.github.io/assertj/">AssertJ</a> 或 <a href="https://code.google.com/p/fest/">Fest Assert</a> 作为Hamcrest的替代者。实际上可以使用任意的第三方库，只要它会在发生错误的时候抛异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().atMost(<span class="number">5</span>, SECONDS).untilAsserted(() -&gt; assertThat(fakeRepository.getValue()).isEqualTo(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<h3 id="At-Least"><a href="#At-Least" class="headerlink" title="At Least"></a>At Least</h3><p>你可以使用Awaitility等待至少某段时间。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().atLeast(<span class="number">1</span>, SECONDS).and().atMost(<span class="number">2</span>, SECONDS).until(value(), equalTo(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>例子中，在由<code>atLeast</code>指定的时长之前条件会被满足，否则会抛出一个异常来表明在指定的时长之前条件可能不会被满足。</p>
<h3 id="断言值被保持"><a href="#断言值被保持" class="headerlink" title="断言值被保持"></a>断言值被保持</h3><p>从Awaitility 4.0.2开始，可以断言某个值被保持了指定的时长。例如，如果你需要确定在数据库中的某个值在1500毫秒中被保持了800毫秒，就可以像下面这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">await().during(<span class="number">800</span>, MILLISECONDS).atMost(<span class="number">1500</span>, MILLISECONDS).until(() -&gt; myRepository.findById(<span class="string">&quot;id&quot;</span>), equalTo(<span class="string">&quot;something&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>Awaitility最多等待1500毫秒，并且会检测<code>myRepository.findById(&quot;id&quot;)</code>必须等于”something”至少800毫秒。</p>
<h2 id="五、重要事项"><a href="#五、重要事项" class="headerlink" title="五、重要事项"></a>五、重要事项</h2><p>Awaitility不会确保线程安全和线程同步！那是你自己的责任！确保你的代码正确处理了同步，或者你正在使用线程安全的数据结构，例如volatile字段或类，比如AtomicInteger和ConcurrentHashMap。</p>
<p><strong>参考资料:</strong></p>
<ol>
<li>GitHub地址：<a href="https://github.com/awaitility/awaitility">https://github.com/awaitility/awaitility</a></li>
<li>Getting started：<a href="https://github.com/awaitility/awaitility/wiki/Getting_started">https://github.com/awaitility/awaitility/wiki/Getting_started</a></li>
<li>用户手册：<a href="https://github.com/awaitility/awaitility/wiki/Usage">https://github.com/awaitility/awaitility/wiki/Usage</a></li>
<li><a href="https://github.com/awaitility/awaitility/blob/master/awaitility/src/test/java/org/awaitility/AwaitilityTest.java">Awaitility test case</a></li>
<li><a href="https://github.com/awaitility/awaitility/blob/master/awaitility-java8-test/src/test/java/org/awaitility/AwaitilityJava8Test.java">Awaitility test case Java 8</a></li>
<li><a href="https://github.com/awaitility/awaitility/blob/master/awaitility/src/test/java/org/awaitility/UsingFieldSupplierTest.java">Field supplier test case</a></li>
<li><a href="https://github.com/awaitility/awaitility/blob/master/awaitility/src/test/java/org/awaitility/UsingAtomicTest.java">Atomic test case</a></li>
<li><a href="http://awaitility.googlecode.com/files/awaitility-khelg-2011.pdf">Presentation</a> from <a href="http://www.jayway.com/">Jayway</a>‘s KHelg 2011</li>
</ol>
]]></content>
      <categories>
        <category>编程 - 测试</category>
      </categories>
      <tags>
        <tag>Awaitility</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker技术原理</title>
    <url>/2022/07/09/Docker%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="一、Docker架构"><a href="#一、Docker架构" class="headerlink" title="一、Docker架构"></a>一、Docker架构</h2><p>Docker包括三个基本概念：</p>
<ul>
<li><strong>镜像（Image）</strong>: Docker 镜像（Image），就相当于是一个 <a href="https://blog.csdn.net/LEON1741/article/details/78159754">root 文件系统</a>。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li>
<li><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li>
<li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</li>
</ul>
<p>Docker 容器通过 Docker 镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类。</p>
<span id="more"></span>

<p>Docker 使用<strong>客户端-服务器 (C&#x2F;S) 架构模式</strong>，使用远程API来管理和创建Docker容器。<strong>TestContainer</strong>就是通过Docker Engine的API来创建和操作容器的。Docker架构模式结构如下图所示：</p>
<p><img src="/images/Docker%E7%9A%84CS%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="img"></p>
<p>下表介绍了架构模式图中涉及到的概念：</p>
<table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Docker 镜像(Images)</td>
<td align="left">Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</td>
</tr>
<tr>
<td align="left">Docker 容器(Container)</td>
<td align="left">容器是独立运行的一个或一组应用，是镜像运行时的实体。</td>
</tr>
<tr>
<td align="left">Docker 客户端(Client)</td>
<td align="left">Docker 客户端通过命令行或者其他工具使用 Docker SDK (<a href="https://docs.docker.com/develop/sdk/">https://docs.docker.com/develop/sdk/</a>) 与 Docker 的守护进程通信。</td>
</tr>
<tr>
<td align="left">Docker 主机(Host)</td>
<td align="left">一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td>
</tr>
<tr>
<td align="left">Docker Registry</td>
<td align="left">Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(<a href="https://hub.docker.com/">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <strong>&lt;仓库名&gt;:&lt;标签&gt;</strong> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <strong>latest</strong> 作为默认标签。</td>
</tr>
<tr>
<td align="left">Docker Machine</td>
<td align="left">Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</td>
</tr>
</tbody></table>
<h2 id="二、Docker-镜像"><a href="#二、Docker-镜像" class="headerlink" title="二、Docker 镜像"></a>二、Docker 镜像</h2><p>我们都知道，操作系统分为 <strong>内核</strong> 和 <strong>用户空间</strong>。对于 <code>Linux</code> 而言，内核启动后，会挂载 <a href="https://blog.csdn.net/LEON1741/article/details/78159754">root文件系统</a>为其提供用户空间支持。而 <strong>Docker 镜像</strong>（<code>Image</code>），就相当于是一个 root文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p>
<p><strong>Docker 镜像</strong> 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变。</p>
<h3 id="rootfs-根文件系统"><a href="#rootfs-根文件系统" class="headerlink" title="rootfs 根文件系统"></a>rootfs 根文件系统</h3><h4 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h4><p>文件系统是os用来明确存储设备（常见的是磁盘，也有基于NAND Flash的固态硬盘）或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。 </p>
<p>文件系统由三部分组成：文件系统的接口，对对象操作和管理的软件集合，对象及属性。从系统角度来看，文件系统是对<a href="https://cloud.tencent.com/product/cfs?from=10680">文件存储</a>设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，当用户不再使用时撤销文件等。</p>
<p>尽管内核是linux的核心，但文件却是用户与操作系统交互所采用的主要工具。这对linux来说尤其如此，这是因为在UNIX传统中，它使用文件I&#x2F;O机制管理硬件设备和数据文件。</p>
<h4 id="根文件系统"><a href="#根文件系统" class="headerlink" title="根文件系统"></a>根文件系统</h4><p>根文件系统首先是内核启动时所mount的第一个文件系统，内核代码映像文件保存在根文件系统中，而系统引导启动程序会在根文件系统挂载之后从中把一些基本的初始化脚本和服务等加载到内存中去运行。</p>
<p>根文件系统首先是一种文件系统，该文件系统不仅具有普通文件系统的存储数据文件的功能，但相对于普通的文件系统，它是内核启动时挂载（mount）的第一个文件系统，内核代码的映像文件保存在根文件系统中，系统引导启动程序会在根文件系统挂载之后从中把一些初始化脚本（如rcS,inittab）和服务加载到内存中去运行。 文件系统和内核是完全独立的两个部分。在嵌入式中移植的内核下载到开发板上，是没有办法真正的启动Linux操作系统的，会出现无法加载文件系统的错误。</p>
<h4 id="根文件系统为什么重要？"><a href="#根文件系统为什么重要？" class="headerlink" title="根文件系统为什么重要？"></a>根文件系统为什么重要？</h4><p>根文件系统之所以在前面加一个”根“，说明它是加载其它文件系统的”根“，那么如果没有这个根，其它的文件系统也就没有办法进行加载的。</p>
<p>根文件系统包含系统启动时所必须的目录和关键性的文件，以及使其他文件系统得以挂载（mount）所必要的文件。例如：</p>
<ol>
<li>init进程的应用程序必须运行在根文件系统上；</li>
<li>根文件系统提供了根目录“&#x2F;”；</li>
<li>linux挂载分区时所依赖的信息存放于根文件系统&#x2F;etc&#x2F;fstab这个文件中；</li>
<li>shell命令程序必须运行在根文件系统上，譬如ls、cd等命令；</li>
</ol>
<p>总之：一套linux体系，只有内核本身是不能工作的，必须要rootfs（上的etc目录下的配置文件、&#x2F;bin &#x2F;sbin等目录下的shell命令，还有&#x2F;lib目录下的库文件等···）相配合才能工作。</p>
<p>Linux启动时，第一个必须挂载的是根文件系统；若系统不能从指定设备上挂载根文件系统，则系统会出错而退出启动。成功之后可以自动或手动挂载其他的文件系统。</p>
<h4 id="Linux内核是怎么挂载根文件系统的？"><a href="#Linux内核是怎么挂载根文件系统的？" class="headerlink" title="Linux内核是怎么挂载根文件系统的？"></a>Linux内核是怎么挂载根文件系统的？</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">init/main.c-&gt;</span><br><span class="line">　start_kernel()-&gt;vfs_caches_init(totalram_pages)–&gt;</span><br><span class="line">　　　mnt_init()–&gt;</span><br><span class="line">　　　　　<span class="comment">/* sysfs用来记录和展示linux驱动模型，sysfs先于rootfs挂载是为全面展示linux驱动模型做好准备 */</span></span><br><span class="line">　　　　　<span class="comment">/* mnt_init()调用sysfs_init()注册并挂载sysfs文件系统，然后调用kobject_create_and_add()创建fs目录 */</span></span><br><span class="line">　　　　　sysfs_init();</span><br><span class="line">　　　　　<span class="comment">/* init_rootfs()注册rootfs，然后调用init_mount_tree()挂载rootfs */</span></span><br><span class="line">　　　　　init_rootfs();</span><br><span class="line">　　　　　init_mount_tree();</span><br></pre></td></tr></table></figure>

<p>1、sysfs文件系统目前还没有挂载到rootfs的某个挂载点上，后续init程序会把sysfs挂载到rootfs的sys挂载点上；</p>
<p>2、rootfs是基于内存的文件系统，所有操作都在内存中完成；也没有实际的存储设备，所以不需要设备驱动程序的参与。基于以上原因，linux在启动阶段使用rootfs文件系统，当磁盘驱动程序和磁盘文件系统成功加载后，<strong>linux系统会将系统根目录从rootfs切换到磁盘文件系统</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">start_kernel</span><br><span class="line">　　vfs_caches_init</span><br><span class="line">　　　　mnt_init</span><br><span class="line">　　　　　　init_rootfs注册rootfs文件系统</span><br><span class="line">　　　　　　init_mount_tree 挂载rootfs文件系统</span><br><span class="line">　　　　　　　　vfs_kern_mount</span><br><span class="line">　　　　　　　　　　mount_fs</span><br><span class="line">　　　　　　　　　　　　type-&gt;mount其实是rootfs_mount</span><br><span class="line">　　　　　　　　　　　　　　mount_nodev</span><br><span class="line">　　　　　　　　　　　　　　　　fill_super 其实是ramfs_fill_super</span><br><span class="line">　　　　　　　　　　　　　　　　　　inode = ramfs_get_inode(sb, <span class="literal">NULL</span>, S_IFDIR | fsi-&gt;mount_opts.mode, <span class="number">0</span>);</span><br><span class="line">　　　　　　　　　　　　　　　　　　sb-&gt;s_root = d_make_root(inode);</span><br><span class="line">　　　　　　　　　　　　　　　　　　　　<span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">name</span> =</span> QSTR_INIT(“/”, <span class="number">1</span>);[<span class="number">1</span>*]</span><br><span class="line">　　　　　　　　　　　　　　　　　　　　__d_alloc(root_inode-&gt;i_sb, &amp;name);</span><br><span class="line">　　　　　　　　　　…</span><br><span class="line">　　　　　　　　　　mnt-&gt;mnt.mnt_root = root;[<span class="number">2</span>*]</span><br><span class="line">　　　　　　　　　　mnt-&gt;mnt.mnt_sb = root-&gt;d_sb;[<span class="number">3</span>*]</span><br><span class="line">　　　　　　　　　　mnt-&gt;mnt_mountpoint = mnt-&gt;mnt.mnt_root;[<span class="number">4</span>*]</span><br><span class="line">　　　　　　　　　　mnt-&gt;mnt_parent = mnt;[<span class="number">5</span>*]</span><br><span class="line">root.mnt = mnt;</span><br><span class="line">　　　　　　　　root.dentry = mnt-&gt;mnt_root;</span><br><span class="line">　　　　　　　　mnt-&gt;mnt_flags |= MNT_LOCKED;</span><br><span class="line">　　　　　　　　set_fs_pwd(current-&gt;fs, &amp;root);</span><br><span class="line">　　　　　　　　set_fs_root(current-&gt;fs, &amp;root);</span><br><span class="line">　　…</span><br><span class="line">　　rest_init</span><br><span class="line">　　<span class="title function_">kernel_thread</span><span class="params">(kernel_init, <span class="literal">NULL</span>, CLONE_FS)</span>;</span><br></pre></td></tr></table></figure>

<p>在执行kernel_init之前，会建立roofs文件系统。</p>
<p>[1*]处设置了根目录的名字为“&#x2F;”； </p>
<p>[2*]处设置了vfsmount中的root目录； </p>
<p>[3*]处设置了vfsmount中的超级块； </p>
<p>[4*]处设置了vfsmount中的文件挂载点，指向了自己； </p>
<p>[5*]处设置了vfsmount中的父文件系统的vfsmount为自己；</p>
<h4 id="根文件系统各个常用目录简介"><a href="#根文件系统各个常用目录简介" class="headerlink" title="根文件系统各个常用目录简介"></a>根文件系统各个常用目录简介</h4><p>正常来说，根文件系统至少包括以下目录：</p>
<ul>
<li>&#x2F;etc&#x2F;：存储重要的配置文件。 </li>
<li>&#x2F;bin&#x2F;：存储常用且开机时必须用到的执行文件。 </li>
<li>&#x2F;sbin&#x2F;：存储着开机过程中所需的系统执行文件。 </li>
<li>&#x2F;lib&#x2F;：存储&#x2F;bin&#x2F;及&#x2F;sbin&#x2F;的执行文件所需的链接库，以及Linux的内核模块。 </li>
<li>&#x2F;dev&#x2F;：存储设备文件。</li>
</ul>
<p>五大目录必须存储在根文件系统上，缺一不可。</p>
<h3 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h3><p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 <code>ISO</code> 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>
<p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<img src="images/Docker分层存储.jpg" alt="img" style="zoom: 67%;" />

<p>下面使用redis镜像来实际查看一下镜像分层存储。执行下面的镜像分析命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image inspect redis</span><br><span class="line">......</span><br><span class="line"><span class="string">&quot;RootFS&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;layers&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Layers&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;sha256:2edcec3590a4ec7f40cf0743c15d78fb39d8326bc029073b41ef9727da6c851f&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:9b24afeb7c2f21e50a686ead025823cd2c6e9730c013ca77ad5f115c079b57cb&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:4b8e2801e0f956a4220c32e2c8b0a590e6f9bd2420ec65453685246b82766ea1&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:529cdb636f61e95ab91a62a51526a84fd7314d6aab0d414040796150b4522372&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:9975392591f2777d6bf4d9919ad1b2c9afa12f9a9b4d260f45025ec3cc9b18ed&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:8e5669d8329116b8444b9bbb1663dda568ede12d3dbcce950199b582f6e94952&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure>

<p>可以看到Layers里面的内容就是具体包含的层。这些层数据存储的位置和其他信息就在上面输出的”GraphDriver”项里面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;GraphDriver&quot;</span>: &#123;</span><br><span class="line">           <span class="string">&quot;Data&quot;</span>: &#123;</span><br><span class="line">               <span class="string">&quot;LowerDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/6d1f6b0b1bedea3ba9db/diff&quot;</span>,</span><br><span class="line">               <span class="string">&quot;MergedDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/6d1f6b0b1bedea3ba9db/merged&quot;</span>,</span><br><span class="line">               <span class="string">&quot;UpperDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/6d1f6b0b1bedea3ba9db/diff&quot;</span>,</span><br><span class="line">               <span class="string">&quot;WorkDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/6d1f6b0b1bedea3ba9db/work&quot;</span></span><br><span class="line">           &#125;,</span><br><span class="line">           <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;overlay2&quot;</span></span><br><span class="line">       &#125;,</span><br></pre></td></tr></table></figure>

<p>我们可以看到这里面存储的就是联合文件系统相关项的信息了。</p>
<h3 id="Union-FS-（联合文件系统）"><a href="#Union-FS-（联合文件系统）" class="headerlink" title="Union FS （联合文件系统）"></a>Union FS （联合文件系统）</h3><p>联合文件系统（<a href="https://en.wikipedia.org/wiki/UnionFS">UnionFS</a>）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。</p>
<p>UnionFS的联合挂载技术可以在一个挂载点同时挂载多个文件系统，将挂载点的原目录与被挂载内容进行整合，使得最终可见的文件系统将会包含整合之后的各层的文件和目录。</p>
<p>联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p>另外，不同 Docker 容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。</p>
<p>Docker 中使用的 AUFS（Advanced Multi-Layered Unification Filesystem）就是一种联合文件系统。 <code>AUFS</code> 支持为每一个成员目录（类似 Git 的分支）设定只读（readonly）、读写（readwrite）和写出（whiteout-able）权限, 同时 <code>AUFS</code> 里有一个类似分层的概念, 对只读权限的分支可以逻辑上进行增量地修改(不影响只读部分的)。</p>
<p>Docker 目前支持的联合文件系统包括 <code>OverlayFS</code>, <code>AUFS</code>, <code>Btrfs</code>, <code>VFS</code>, <code>ZFS</code> 和 <code>Device Mapper</code>。</p>
<p>下面Centos发行版的overlayFS联合文件系统示意图:</p>
<p><img src="/images/overlay2.png" alt="img"></p>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p>
<p>Dockerfile 是一个文本文件，其内包含了一条条的 **指令(Instruction)**，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<p>下面以定制nginx镜像为例，演示Dockerfile使用过程：</p>
<p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> mynginx</span><br><span class="line">$ <span class="built_in">cd</span> mynginx</span><br><span class="line">$ <span class="built_in">touch</span> Dockerfile</span><br></pre></td></tr></table></figure>

<p>其内容为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>

<p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p>
<h2 id="三、Docker-容器"><a href="#三、Docker-容器" class="headerlink" title="三、Docker 容器"></a>三、Docker 容器</h2><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p>
<p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。</p>
<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>
<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <a href="">数据卷（Volume）</a>、或者 <a href="">绑定宿主目录</a>，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>
<p><strong>数据卷</strong>的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>Namespace（命名空间）是Linux内核的一项功能，该功能对内核资源进行分区，使一组进程看到一组资源，而另一组进程看到另一组资源，就好像运行在单独的操作系统中一样。Namespace有很多种，包括下表中列出的7种。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>隔离的资源</th>
</tr>
</thead>
<tbody><tr>
<td>IPC</td>
<td>SystemV IPC(信号量, 消息队列和共享内存) 和 POSIX message queues</td>
</tr>
<tr>
<td>Network</td>
<td>网络设备, 网络栈, 端口等</td>
</tr>
<tr>
<td>Mount</td>
<td>文件挂载点</td>
</tr>
<tr>
<td>PID</td>
<td>进程编号</td>
</tr>
<tr>
<td>User</td>
<td>User &amp; Group IDs</td>
</tr>
<tr>
<td>UTS</td>
<td>主机名和NIS域名</td>
</tr>
<tr>
<td>Cgroup</td>
<td>cgroup的根目录</td>
</tr>
</tbody></table>
<p>比较重要的是network，mount和PID namespace。</p>
<p>每个容器都有自己单独的命名空间，运行在其中的应用都像是在独立的操作系统中运行一样。命名空间保证了容器之间彼此互不影响。</p>
<h3 id="控制组"><a href="#控制组" class="headerlink" title="控制组"></a>控制组</h3><p>Cgroups 是 control groups 的缩写，是Linux内核提供的一种可以限制，记录，隔离进程组(process groups)所使用物理资源的机制。主要功能有：资源限制(Resource limiting)，优先级分配(Prioritization)，资源统计（Accounting)，进程控制（Control）等。只有能控制分配到容器的资源，才能避免当多个容器同时运行时的对系统资源的竞争。</p>
<ul>
<li>资源限制(Resource limiting): Cgroups可以对进程组使用的资源总额进行限制。如对特定的进程进行内存使用上限限制，当超出上限时，会触发OOM。</li>
<li>优先级分配(Prioritization): 通过分配的CPU时间片数量及硬盘IO带宽大小，实际上就相当于控制了进程运行的优先级。</li>
<li>资源统计（Accounting): Cgroups可以统计系统的资源使用量，如CPU使用时长、内存用量等等，这个功能非常适用于计费。</li>
<li>进程控制（Control）：Cgroups可以对进程组执行挂起、恢复等操作。</li>
</ul>
<h3 id="容器的存储组织方式"><a href="#容器的存储组织方式" class="headerlink" title="容器的存储组织方式"></a>容器的存储组织方式</h3><p>综合考虑镜像的层级结构，以及 volume、init-layer、可读写层这些概念，一个完整的、在运行的容器的所有文件系统结构可如下图所示：</p>
<p><img src="/images/%E5%AE%B9%E5%99%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.png" alt="容器文件系统结构"></p>
<p>从图中我们不难看到，除了 echo hello 进程所在的 cgroups 和 namespace 环境之外，容器文件系统其实是一个相对独立的组织。可读写部分(read-write layer 以及 volumes)、init-layer、只读层(read-only layer) 这 3 部分结构共同组成了一个容器所需的下层文件系统，它们通过联合挂载的方式巧妙地表现为一层，使得容器进程对这些层的存在一无所知。</p>
<p>rootfs 是 docker 容器在启动时<strong>内部进程可见的文件系统</strong>，即 docker 容器的根目录。当我们运行docker exec命令进入container的时候看到的文件系统就是rootfs。rootfs 通常包含一个操作系统运行所需的文件系统，例如可能包含典型的类 Unix 操作系统中的目录系统，如 &#x2F;dev、&#x2F;proc、&#x2F;bin、&#x2F;etc、&#x2F;lib、&#x2F;usr、&#x2F;tmp 及运行 docker 容器所需的配置文件、工具等。</p>
<p>就像Linux启动会先用只读模式挂载rootfs，运行完完整性检查之后，再切换成读写模式一样。Docker deamon为container挂载rootfs时，也会先挂载为只读模式，但是与Linux做法不同的是，在挂载完只读的rootfs之后，docker deamon会利用联合挂载技术（Union Mount）在已有的rootfs上再挂一个读写层。container在运行过程中文件系统发生的变化只会写到读写层，并通过whiteout技术隐藏只读层中的旧版本文件。</p>
<p>容器的rootfs分为三个部分:  读写层(rw)、init层(ro+wh)、只读层(ro+wh)</p>
<p><strong>只读层</strong>对于的docker的镜像层, 这部分不可被修改.</p>
<p><strong>init层</strong>它是一个以“-init”结尾的层，夹在只读层和读写层之间。Init 层是 Docker 项目单独生成的一个内部层，专门用来存放 &#x2F;etc&#x2F;hosts、&#x2F;etc&#x2F;resolv.conf 等信息.</p>
<p><strong>读写层</strong>是 rootfs 最上面的一层,它的挂载方式为：rw，即 read write。在没有写入文件之前，这个目录是空的。而一旦在容器里做了写操作，你修改产生的内容就会以增量的方式出现在这个层中。 删除文件的话 ,AuFS 会在可读写层创建一个 whiteout 文件，把只读层里的文件“遮挡”起来。比如，你要删除只读层里一个名叫 foo 的文件，那么这个删除操作实际上是在可读写层创建了一个名叫.wh.foo 的文件。这样，当这两个层被联合挂载之后，foo 文件就会被.wh.foo 文件“遮挡”起来，“消失”了。这个功能，就是“ro+wh”的挂载方式，即只读 +whiteout 的含义</p>
<p><strong>容器存储层</strong></p>
<p>容器存储层会存储容器运行过程中产生的所有改变，对应到上边讲的rootfs的读写层。因为这一层是运行中容器与源Docker镜像唯一的不同，因此由同一个镜像创建的任意数量容器都可以共享相同的底层镜像，并且同时可以维持他们自己的独立状态。</p>
<img src="/images/Docker容器层结构图.png" alt="Docker容器层结构图" style="zoom:50%;" />



<h3 id="数据卷的实现原理"><a href="#数据卷的实现原理" class="headerlink" title="数据卷的实现原理"></a>数据卷的实现原理</h3><h4 id="Volume-挂载"><a href="#Volume-挂载" class="headerlink" title="Volume 挂载"></a>Volume 挂载</h4><p>容器技术使用了 rootfs 机制和 Mount Namespace，构建出了一个同宿主机完全隔离开的文件系统环境。这时候，我们就需要考虑这样两个问题：</p>
<ol>
<li>容器里进程新建的文件，怎么才能让宿主机获取到？</li>
<li>宿主机上的文件和目录，怎么才能让容器里的进程访问到？</li>
</ol>
<p>这正是 Docker Volume 要解决的问题：Volume 机制，允许你将宿主机上指定的目录或者文件，挂载到容器里面进行读取和修改操作。</p>
<p>在 Docker 项目里，它支持两种 Volume 声明方式，可以把宿主机目录挂载进容器的 &#x2F;test 目录当中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -v /test ...</span><br><span class="line">$ docker run -v /home:/test ...</span><br></pre></td></tr></table></figure>

<p>而这两种声明方式的本质，实际上是相同的：都是把一个宿主机的目录挂载进了容器的 &#x2F;test 目录。<br>只不过，在第一种情况下，由于你并没有显示声明宿主机目录，那么 Docker 就会默认在宿主机上创建一个临时目录 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;[VOLUME_ID]&#x2F;_data，然后把它挂载到容器的 &#x2F;test 目录上。而在第二种情况下，Docker 就直接把宿主机的 &#x2F;home 目录挂载到容器的 &#x2F;test 目录上.</p>
<h4 id="绑定挂载"><a href="#绑定挂载" class="headerlink" title="绑定挂载"></a>绑定挂载</h4><p>那么，Docker 又是如何做到把一个宿主机上的目录或者文件，挂载到容器里面去呢？</p>
<p>当容器进程被创建之后，尽管开启了 Mount Namespace，但是在它执行 chroot（或者 pivot_root）之前，容器进程一直可以看到宿主机上的整个文件系统。</p>
<p>而宿主机上的文件系统，也自然包括了我们要使用的容器镜像。这个镜像的各个层，保存在 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;diff 目录下，在容器进程启动后，它们会被联合挂载在 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;mnt&#x2F; 目录中，这样容器所需的 rootfs 就准备好了。<br>所以，我们只需要在 rootfs 准备好之后，在执行 chroot 之前，把 Volume 指定的宿主机目录（比如 &#x2F;home 目录），挂载到指定的容器目录（比如 &#x2F;test 目录）在宿主机上对应的目录（即 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;mnt&#x2F;[可读写层 ID]&#x2F;test）上，这个 Volume 的挂载工作就完成了。</p>
<p>更重要的是，由于执行这个挂载操作时，“容器进程”已经创建了，也就意味着此时 Mount Namespace 已经开启了。所以，这个挂载事件只在这个容器里可见。你在宿主机上，是看不见容器内部的这个挂载点的。这就保证了容器的隔离性不会被 Volume 打破。</p>
<p>注意：这里提到的 “ 容器进程 “，是 Docker 创建的一个容器初始化进程 (dockerinit)，而不是应用进程 (ENTRYPOINT + CMD)。dockerinit 会负责完成根目录的准备、挂载设备和目录、配置 hostname 等一系列需要在容器内进行的初始化操作。最后，它通过 execv() 系统调用，让应用进程取代自己，成为容器里的 PID&#x3D;1 的进程。</p>
<p>而这里要使用到的挂载技术，就是 Linux 的<strong>绑定挂载（bind mount）机制</strong>，对应的Linux命令为<code>mount --bind olddir newdir</code>。它的主要作用就是，允许你将一个目录或者文件，而不是整个设备，挂载到一个指定的目录上。并且，这时你在该挂载点上进行的任何操作，只是发生在被挂载的目录或者文件上，而原挂载点的内容则会被隐藏起来且不受影响。</p>
<p>其实，如果你了解 Linux 内核的话，就会明白，<strong>绑定挂载实际上是一个 inode 替换的过程</strong>。在 Linux 操作系统中，inode 可以理解为存放文件内容的“对象”，而 dentry，也叫目录项，就是访问这个 inode 所使用的“指针”。</p>
<p><img src="/images/Docker%E7%BB%91%E5%AE%9A%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Docker volume 的实现原理(36)_linux"></p>
<p>正如上图所示，mount –bind &#x2F;home &#x2F;test，会将 &#x2F;home 挂载到 &#x2F;test 上。其实相当于将 &#x2F;test 的 dentry，重定向到了 &#x2F;home 的 inode。这样当我们修改 &#x2F;test 目录时，实际修改的是 &#x2F;home 目录的 inode。这也就是为何，一旦执行 umount 命令，&#x2F;test 目录原先的内容就会恢复：因为修改真正发生在的，是 &#x2F;home 目录里。</p>
<p>所以，在一个正确的时机，进行一次绑定挂载，Docker 就可以成功地将一个宿主机上的目录或文件，不动声色地挂载到容器中。</p>
<p>这样，进程在容器里对这个 &#x2F;test 目录进行的所有操作，都实际发生在宿主机的对应目录（比如，&#x2F;home，或者 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;[VOLUME_ID]&#x2F;_data）里，而不会影响容器镜像的内容。</p>
<p>那么，这个 &#x2F;test 目录里的内容，既然挂载在容器 rootfs 的可读写层，它会不会被 docker commit 提交掉呢？<br>也不会。因为容器的镜像操作，比如 docker commit，都是发生在宿主机空间的，而由于 Mount Namespace 的隔离作用，宿主机并不知道这个绑定挂载的存在。所以，在宿主机看来，容器中可读写层的 &#x2F;test 目录（&#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;mnt&#x2F;[可读写层 ID]&#x2F;test），始终是空的。</p>
<p>不过，由于 Docker 一开始还是要创建 &#x2F;test 这个目录作为挂载点，所以执行了 docker commit 之后，你会发现新产生的镜像里，会多出来一个空的 &#x2F;test 目录。毕竟，新建目录操作，又不是挂载操作，Mount Namespace 对它可起不到“障眼法”的作用。</p>
<h3 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h3><p>Docker在安装后自动提供4种网络，可以使用<code>Docker network ls</code>命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">0cfebacda74b   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">322c4224124b   host      host      <span class="built_in">local</span></span><br><span class="line">c69dc8eed0ec   none      null      <span class="built_in">local</span></span><br></pre></td></tr></table></figure>

<p>Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。</p>
<h4 id="docker的4种网络模式"><a href="#docker的4种网络模式" class="headerlink" title="docker的4种网络模式"></a>docker的4种网络模式</h4><table>
<thead>
<tr>
<th>网络模式</th>
<th>配置</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>host</td>
<td>–network host</td>
<td>容器和宿主机共享Network namespace</td>
</tr>
<tr>
<td>container</td>
<td>–network container:NAME_OR_ID</td>
<td>容器和另外一个容器共享Network namespace</td>
</tr>
<tr>
<td>none</td>
<td>–network none</td>
<td>容器有独立的Network<br/>namespace，<br/>namespace，<br/>但并没有对其进行任何网络设置，<br/>如分配veth pair 和网桥连接，</td>
</tr>
<tr>
<td>bridge</td>
<td>–network bridge</td>
<td>默认模式</td>
</tr>
</tbody></table>
<p>下面是4种网络模式的示意图：</p>
<p>​		<img src="/images/Docker%E5%9B%9B%E7%A7%8D%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="在这里插入图片描述"></p>
<h4 id="bridge模式"><a href="#bridge模式" class="headerlink" title="bridge模式"></a>bridge模式</h4><p>当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。</p>
<p>从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。在主机上创建一对虚拟网卡veth pair设备，Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到docker0网桥中。可以通过brctl show命令查看。</p>
<p>bridge模式是docker的默认网络模式，不写–network参数，就是bridge模式。使用docker run -p时，docker实际是在iptables做了DNAT规则，实现端口转发功能。可以使用iptables -t nat -vnL查看。</p>
<p>bridge模式如下图所示：</p>
<p><img src="/images/Docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C-bridge%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="在这里插入图片描述"></p>
<p>假设上图的docker2中运行了一个nginx，大家来想几个问题：</p>
<ul>
<li>同主机间两个容器间是否可以直接通信？比如在docker1上能不能直接访问到docker2的nginx站点？答：可以。</li>
<li>在宿主机上能否直接访问到docker2的nginx站点？答：不能直接访问，需要端口映射或者配置iptables转发规则。</li>
<li>在另一台主机上如何访问node1上的这个nginx站点呢？DNAT发布？答：为node1上的nginx容器配置端口映射。</li>
</ul>
<p>Docker网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法通过直接Container-IP访问到容器。如果容器希望外部访问能够访问到，可以通过映射容器端口到宿主主机（端口映射），即docker run创建容器时候通过 -p 或 -P 参数来启用，访问容器的时候就通过[宿主机IP]:[容器端口]访问容器。</p>
<h5 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h5><p>在上文中提到了，在Docker网桥模式下，虚拟网桥Docker0不是一个实际的物理网卡，所以外部网络是访问不到容器IP地址的，外部网络要想访问到容器里面就得做端口映射。端口映射实际是在iptables做了DNAT规则，实现端口转发功能。下面我们就详细看下端口映射的细节。</p>
<p>端口映射结构示意图：</p>
<p><img src="/images/Docker%E7%BD%91%E6%A1%A5%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="img"></p>
<p>Iptables是一个复杂的存在，它里面有表（tables）、链（chains）和规则（rules）构成，我们就简单把它理解成网络数据包路由。在端口映射的时候，它负责把容器网络数据包的源地址转换为宿主机地址。</p>
<h5 id="iptables简述"><a href="#iptables简述" class="headerlink" title="iptables简述"></a>iptables简述</h5><p><a href="https://en.wikipedia.org/wiki/iptables">iptables</a>是Linux内核自带的包过滤防火墙，支持<a href="https://en.wikipedia.org/wiki/Network_address_translation">NAT</a>等诸多功能。iptables由表和规则chain概念组成，Docker中所 用的表包括filter表和nat表（参见上述命令输出结果），这也是iptables中最常用的两个表。iptables是一个复杂的存在，曾 有一本书《<a href="http://book.douban.com/subject/2148593/">linux firewalls</a>》 专门讲解iptables，这里先借用本书 中的一幅图来描述一下ip packets在各个表和chain之间的流转过程：</p>
<p><img src="/images/docker-single-host-networking-iptables.jpg" alt="img{500x165}"></p>
<p>网卡收到的数据包进入到iptables后，做路由选择，本地的包通过INPUT链送往user层应用；转发到其他网口的包通过FORWARD chain；本地产生的数据包在路由选择后，通过OUTPUT chain；最后POSTROUTING chain多用于source nat转换。</p>
<p>iptables在容器网络中最重要的两个功能：</p>
<p>1、限制container间的通信<br>2、将container到外部网络包的源地址换成宿主主机地址(MASQUERADE)</p>
<h5 id="Docker0的“双重身份”"><a href="#Docker0的“双重身份”" class="headerlink" title="Docker0的“双重身份”"></a>Docker0的“双重身份”</h5><p>如何理解Docker0？下图中给出了Docker0的双重身份，并对比物理交换机，来理解一下Docker0这个软网桥。</p>
<p><img src="/images/docker-single-host-networking-docker0.jpg" alt="img{500x165}"></p>
<p><strong>1、从容器视角，网桥（交换机）身份</strong></p>
<p>docker0对于通过veth pair“插在”网桥上的container1和container2来说，首先就是一个二层的交换机的角色：泛洪、维护cam表，在二层转发数据包；同 时由于docker0自身也具有mac地址（这个与纯二层交换机不同），并且绑定了ip(这里是172.17.0.1)，因此在 container中还作为container default路由的默认Gateway而存在。</p>
<p><strong>2、从宿主机视角，网卡身份</strong></p>
<p>物理交换机提供了由硬件实现的高效的背板通道，供连接在交换机上的主机高效实现二层通信；对于开启了三层协议的物理交换机而言，其ip路由的处理 也是由物理交换机管理程序提供的。对于docker0而言，其负责处理二层交换机逻辑以及三层的处理程序其实就是宿主机上的Linux内核 tcp&#x2F;ip协议栈程序。而从宿主机来看，所有docker0从veth（只是个二层的存在，没有绑定ipv4地址）接收到的数据包都会被宿主机 看成从docker0这块网卡（第二个身份，绑定172.17.0.1)接收进来的数据包，尤其是在进入三层时，宿主机上的iptables就会对docker0进来的数据包按照rules进行相应处理（通过一些内核网络设置也可以忽略docker0 brigde数据的处理）。</p>
<h4 id="container模式"><a href="#container模式" class="headerlink" title="container模式"></a>container模式</h4><p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p>
<p>container模式如下图所示：</p>
<p><img src="/images/Docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C-container%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="在这里插入图片描述"></p>
<h4 id="host模式"><a href="#host模式" class="headerlink" title="host模式"></a>host模式</h4><p>如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p>
<p>使用host模式的容器可以直接使用宿主机的IP地址与外界通信，容器内部的服务端口也可以使用宿主机的端口，不需要进行NAT，host最大的优势就是网络性能比较好，但是docker host上已经使用的端口就不能再用了，网络的隔离性不好。<br><img src="/images/Docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C-host%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="在这里插入图片描述"></p>
<h4 id="none模式"><a href="#none模式" class="headerlink" title="none模式"></a>none模式</h4><p>使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。</p>
<p>这种网络模式下容器只有lo回环网络，没有其他网卡。none模式可以在容器创建时通过–network none来指定。这种类型的网络没有办法联网，封闭的网络能很好的保证容器的安全性。</p>
<p>应用场景：</p>
<ul>
<li><p>启动一个容器处理数据，比如转换数据格式</p>
</li>
<li><p>一些后台的计算和处理任务</p>
</li>
</ul>
<p>none模式如下图所示：</p>
<p><img src="/images/Docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C-none%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="在这里插入图片描述"></p>
<h2 id="四、Docker-仓库"><a href="#四、Docker-仓库" class="headerlink" title="四、Docker 仓库"></a>四、Docker 仓库</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href="">Docker Registry</a> 就是这样的服务。</p>
<p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p>
<p>以 <a href="https://hub.docker.com/_/ubuntu">Ubuntu 镜像</a> 为例，<code>ubuntu</code> 是仓库的名字，其内包含有不同的版本标签，如，<code>16.04</code>, <code>18.04</code>。我们可以通过 <code>ubuntu:16.04</code>，或者 <code>ubuntu:18.04</code> 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 <code>ubuntu</code>，那将视为 <code>ubuntu:latest</code>。</p>
<p>仓库名经常以 <em>两段式路径</em> 形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p>
<h3 id="Docker-Registry-公开服务"><a href="#Docker-Registry-公开服务" class="headerlink" title="Docker Registry 公开服务"></a>Docker Registry 公开服务</h3><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>
<h3 id="私有-Docker-Registry"><a href="#私有-Docker-Registry" class="headerlink" title="私有 Docker Registry"></a>私有 Docker Registry</h3><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a href="https://hub.docker.com/_/registry/">Docker Registry</a> 镜像，可以直接使用做为私有 Registry 服务。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>上文中我们已经对Docker镜像、容器、仓库有了大致的了解，下面就让我们回顾一下Docker创建容器的完整过程，方便把所有的知识串起来。</p>
<p>docker创建容器过程如下图所示：<br><img src="/images/Docker%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8%E8%BF%87%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="https://ithelp.ithome.com.tw/upload/images/20200912/20025481WAftFZXMHY.png"></p>
<p>要创建Docker容器，首先得通过Docker客户端命令（一般情况）向Docker守护进程下发请求，然后守护进程会在本地检索镜像，如果没有检索到就会去远端镜像仓库拉取镜像，获得镜像后就会启动初始进程准备容器运行的文件系统、网络、可读写层等，最后启动容器应用进程替代初始化进程自身。</p>
<h2 id="参考资料与资源汇总"><a href="#参考资料与资源汇总" class="headerlink" title="参考资料与资源汇总"></a>参考资料与资源汇总</h2><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://tonybai.com/2016/01/15/understanding-container-networking-on-single-host/">理解Docker单机容器网络</a></li>
<li><a href="https://www.docker.org.cn/docker/205.html">Docker源码分析之整体架构图</a></li>
</ul>
<h3 id="菜鸟教程"><a href="#菜鸟教程" class="headerlink" title="菜鸟教程"></a>菜鸟教程</h3><ul>
<li>Docker教程： <a href="https://www.runoob.com/docker/docker-tutorial.html">https://www.runoob.com/docker/docker-tutorial.html</a></li>
</ul>
<h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><p>《Docker源码分析》</p>
<h3 id="Docker资源"><a href="#Docker资源" class="headerlink" title="Docker资源"></a>Docker资源</h3><ul>
<li>Docker 官方主页: <a href="https://www.docker.com/">https://www.docker.com</a></li>
<li>Docker 中文官网: <a href="https://www.docker.org.cn/index.html">https://www.docker.org.cn/index.html</a></li>
<li>Docker 官方博客: <a href="https://blog.docker.com/">https://blog.docker.com/</a></li>
<li>Docker 官方文档: <a href="https://docs.docker.com/">https://docs.docker.com/</a></li>
<li>Docker Store: <a href="https://store.docker.com/">https://store.docker.com</a></li>
<li>Docker Cloud: <a href="https://cloud.docker.com/">https://cloud.docker.com</a></li>
<li>Docker Hub: <a href="https://hub.docker.com/">https://hub.docker.com</a></li>
<li>Docker 的源代码仓库: <a href="https://github.com/moby/moby">https://github.com/moby/moby</a></li>
<li>Docker 发布版本历史: <a href="https://docs.docker.com/release-notes/">https://docs.docker.com/release-notes/</a></li>
<li>Docker 常见问题: <a href="https://docs.docker.com/engine/faq/">https://docs.docker.com/engine/faq/</a></li>
<li>Docker 远端应用 API: <a href="https://docs.docker.com/develop/sdk/">https://docs.docker.com/develop/sdk/</a></li>
</ul>
<h3 id="Docker国内镜像"><a href="#Docker国内镜像" class="headerlink" title="Docker国内镜像"></a>Docker国内镜像</h3><ul>
<li>阿里云的加速器：<a href="https://help.aliyun.com/document_detail/60750.html">https://help.aliyun.com/document_detail/60750.html</a></li>
<li>网易加速器：<a href="http://hub-mirror.c.163.com/">http://hub-mirror.c.163.com</a></li>
<li>官方中国加速器：<a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></li>
<li>ustc 的镜像：<a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></li>
<li>daocloud：<a href="https://www.daocloud.io/mirror#accelerator-doc%EF%BC%88%E6%B3%A8%E5%86%8C%E5%90%8E%E4%BD%BF%E7%94%A8%EF%BC%89">https://www.daocloud.io/mirror#accelerator-doc（注册后使用）</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟化 - 容器</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>基础知识</title>
    <url>/2022/07/03/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="一、基本数据类型及其封装类型"><a href="#一、基本数据类型及其封装类型" class="headerlink" title="一、基本数据类型及其封装类型"></a>一、基本数据类型及其封装类型</h2><p>Java基本类型共有八种，基本类型可以分为三类，字符类型char，布尔类型boolean以及数值类型byte、short、int、long、float、double。数值类型又可以分为整数类型byte、short、int、long和浮点数类型float、double。JAVA中的数值类型不存在无符号的，它们的取值范围是固定的，不会随着机器硬件环境或者<a href="http://lib.csdn.net/base/operatingsystem">操作系统</a>的改变而改变。实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。</p>
<span id="more"></span>

<p>8种类型表示范围如下：</p>
<table>
<thead>
<tr>
<th>简单类型</th>
<th>二进制位数</th>
<th>封装器类型</th>
<th>最大存储数据量</th>
<th>存储范围</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>1</td>
<td>Boolean</td>
<td></td>
<td>true或者false</td>
</tr>
<tr>
<td>byte</td>
<td>8</td>
<td>Byte</td>
<td>255</td>
<td>-128~127</td>
</tr>
<tr>
<td>char</td>
<td>16</td>
<td>Character</td>
<td></td>
<td></td>
</tr>
<tr>
<td>short</td>
<td>16</td>
<td>Short</td>
<td>65536</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>Int</td>
<td>32</td>
<td>Integer</td>
<td>32次方减1</td>
<td>负的2的31次方到正的2的31次方减1</td>
</tr>
<tr>
<td>long</td>
<td>64</td>
<td>Long</td>
<td>2的64次方减1</td>
<td>负的2的63次方到正的2的63次方减1</td>
</tr>
<tr>
<td>float</td>
<td>32</td>
<td>Float</td>
<td>——</td>
<td>3.4e-45~1.4e38</td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>Double</td>
<td>——</td>
<td>4.9e-324~1.8e308</td>
</tr>
<tr>
<td>void</td>
<td>——</td>
<td>Void</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Java决定了每种简单类型的大小。这些大小并不随着机器结构的变化而变化。这种大小的不可更改正是Java程序具有很强移植能力的原因之一。下表列出了Java中定义的简单类型、占用二进制位数及对应的封装器类。</p>
<p>对于数值类型的基本类型的取值范围，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了。如：</p>
<p>基本类型byte 二进制位数：Byte.SIZE 最小值：Byte.MIN_VALUE 最大值：Byte.MAX_VALUE</p>
<p>基本类型short二进制位数：Short.SIZE 最小值：Short.MIN_VALUE 最大值：Short.MAX_VALUE</p>
<p>基本类型char二进制位数：Character.SIZE 最小值：Character.MIN_VALUE 最大值：Character.MAX_VALUE</p>
<p>基本类型double 二进制位数：Double.SIZE 最小值：Double.MIN_VALUE 最大值：Double.MAX_VALUE</p>
<p><strong>注意</strong>：float、double两种类型的最小值与Float.MIN_VALUE、 Double.MIN_VALUE的值并不相同，实际上Float.MIN_VALUE和Double.MIN_VALUE分别指的是 float和double类型所能表示的最小正数。也就是说存在这样一种情况，0到±Float.MIN_VALUE之间的值float类型无法表示，0 到±Double.MIN_VALUE之间的值double类型无法表示。这并没有什么好奇怪的，因为这些范围内的数值超出了它们的精度范围。</p>
<p>Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的”E+数字”表示E之前的数字要乘以10的多少倍。比如3.14E3就是3.14×1000&#x3D;3140，3.14E-3就是3.14&#x2F;1000&#x3D;0.00314。</p>
<p>Java基本类型存储在栈中，因此它们的存取速度要快于存储在堆中的对应包装类的实例对象。从Java5.0（1.5）开始，JAVA虚拟机（Java Virtual Machine）可以完成基本类型和它们对应包装类之间的自动转换。因此我们在赋值、参数传递以及数学运算的时候像使用基本类型一样使用它们的包装类，但这并不意味着你可以通过基本类型调用它们的包装类才具有的方法。另外，所有基本类型（包括void）的包装类都使用了final修饰，因此我们无法继承它们扩展新的类，也无法重写它们的任何方法。</p>
<p>基本类型的优势：数据存储相对简单，运算效率比较高</p>
<p>包装类型的优势：有的地方必须使用包装器类型，比如集合的元素必须是对象类型，满足了java一切皆是对象的思想</p>
<h2 id="二、自动装箱与拆箱"><a href="#二、自动装箱与拆箱" class="headerlink" title="二、自动装箱与拆箱"></a>二、自动装箱与拆箱</h2><p>简单一点说，装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。</p>
<h2 id="三、运算符"><a href="#三、运算符" class="headerlink" title="三、运算符"></a>三、运算符</h2><p>Java运算符按功能可分为：算数运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和条件运算符。</p>
<h3 id="3-1-算数运算符"><a href="#3-1-算数运算符" class="headerlink" title="3.1 算数运算符"></a>3.1 算数运算符</h3><p>算术运算符包括通常的加（+）、减（-）、乘（*）、除（&#x2F;）、取模（%），完成整数型和浮点型数据的算术运算。</p>
<p>许多语言中的取模运算只能用于整数型，Java对此做了扩展，它允许对浮点数进行取模操作。例如，3%2 的结果是 1, 15.2%5 的结果是 0.2。取模操作还可以用于负数，结果的符号与第一个操作数的符号相同，例如，5%-3 的结果是 2，-5%3 的结果是-2。</p>
<p>此外，算术运算符还有“++”和“–”两种，分别称为加1和减1运算符。这两种运算符有前缀形式和后缀形式，含有有所不同。例如，i++ 和 ++i 的执行顺序是不一样的，i++ 在 i 使用之后再 +1，++i 在 i 使用之前先 +1。i– 和 –i 的情况于此类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">System.out.println(i++); <span class="comment">// i++, 使用之后 +1, 此处输出1</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">System.out.println(++i); <span class="comment">// ++i, 先+1再使用，此处输出2</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">System.out.println(i--); <span class="comment">// i--, 使用之后-1, 此处输出1</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">System.out.println(--i); <span class="comment">// --i, 先-1再使用，此处输出0</span></span><br></pre></td></tr></table></figure>



<h3 id="3-2-关系运算符"><a href="#3-2-关系运算符" class="headerlink" title="3.2 关系运算符"></a>3.2 关系运算符</h3><p>关系运算符用来比较两个值，包括大于（&gt;）、小于（&lt;）、大于等于（&gt;&#x3D;）、小于等于（&lt;&#x3D;）、等于（&#x3D;&#x3D;）和不等于（!&#x3D;）6种。关系运算符都是二元运算符，也就是每个运算符都带有两个操作数，运算的结果是一个逻辑值。Java允许“&#x3D;&#x3D;”和“!&#x3D;”两种运算符用于任何数据类型。例如，既可以判断两个数的值是否相等，也可以判断对象或数组的实例是否相等。判断实例时比较的是两个对象在内存中的引用地址是否相等。</p>
<h3 id="3-3-逻辑运算符"><a href="#3-3-逻辑运算符" class="headerlink" title="3.3 逻辑运算符"></a>3.3 逻辑运算符</h3><p>逻辑运算符包括逻辑与（&amp;&amp;）、逻辑或（||）和逻辑非（!）。前两个是二元运算符，后一个是一元运算符。Java对逻辑与和逻辑或提供“短路”功能，也就是在进行运算时，先计算运算符左侧的表达式的值，如果使用该值能得到整个表达式的值，则跳过运算符右侧表达式的计算，否则计算运算符右侧表达式，并得到整个表达式的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 逻辑与 &amp;&amp;， 有一个表达式的结果是false，整体结果就是false</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (str != <span class="literal">null</span> &amp;&amp; str.length() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// str是null, &amp;&amp;左侧表达式的结果是false, 不会计算&amp;&amp;右侧表达式，直接整体返回false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (str != <span class="literal">null</span> &amp;&amp; str.length() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="comment">// &amp;&amp;左侧表达式的结果是true, 会接着计算&amp;&amp;右侧的表达式，右侧表达式的值是false, 整个if中的表达式的结果就是返回false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逻辑或 ||， 有一个表达式的结果是true，整体就返回true。</span></span><br><span class="line">str = <span class="string">&quot;qq&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// || 左侧的表达式的结果是false, 会接着计算 || 右侧的表达式，右侧结果是true，则整体返回true。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str != <span class="literal">null</span> || str.length() == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// || 左侧的表达式的结果是true, 不会计算 || 右侧的表达式，直接整体返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逻辑非!, 表达式结果是true, 就返回false; 表达式结果是false，就返回true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">System.out.println(!flag); <span class="comment">// 输出false</span></span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line">System.out.println(!flag); <span class="comment">// 输出true;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-位运算符"><a href="#3-4-位运算符" class="headerlink" title="3.4 位运算符"></a>3.4 位运算符</h3><p>位运算符用来对二进制位进行操作，包括按位取反（~）、按位与（&amp;）、按位或（|）、异或（^）、右移（&gt;&gt;）、左移（&lt;&lt;）和无符号右移（&gt;&gt;&gt;）。位运算符只能对整数型和字符型数据进行操作。</p>
<p><strong>取反（~）</strong></p>
<p>参加运算的一个数据，按二进制位进行“取反”运算。</p>
<p>运算规则：~1&#x3D;0； ~0&#x3D;1；</p>
<p>即：对一个二进制数按位取反，即将0变1，1变0。</p>
<p><strong>按位与（&amp;）</strong></p>
<p>参加运算的两个数据，按二进制位进行“与”运算。</p>
<p>运算规则：0&amp;0&#x3D;0; 0&amp;1&#x3D;0; 1&amp;0&#x3D;0; 1&amp;1&#x3D;1；即：两位同时为“1，结果才为“1，否则为0。</p>
<p>例如：3&amp;5 即 0000 0011 &amp; 0000 0101 &#x3D; 0000 0001 因此，3 &amp; 5的值得1。</p>
<p><strong>按位或（|）</strong></p>
<p>参加运算的两个对象，按二进制位进行“或”运算。</p>
<p>运算规则：0 | 0&#x3D;0； 0 | 1&#x3D;1； 1 | 0&#x3D;1； 1 | 1&#x3D;1；</p>
<p>即 ：参加运算的两个对象只要有一个为1，其值为1。</p>
<p>例如：3 | 5，即 0000 0011 | 0000 0101 &#x3D; 0000 0111 因此，3 | 5的值得7。</p>
<p><strong>异或（^）</strong></p>
<p>参加运算的两个数据，按二进制位进行“异或”运算。</p>
<p>运算规则：0^0&#x3D;0； 0^1&#x3D;1； 1^0&#x3D;1； 1^1&#x3D;0；</p>
<p>即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。</p>
<p><strong>左移（&lt;&lt;）</strong></p>
<p>运算规则：按二进制形式把所有的数字向左移动对应的位数，高位移出（舍弃），低位的空位补零。例如： 12345 &lt;&lt; 1，则是将数字12345左移1位：</p>
<p><img src="/images/1ad5ad6eddc451da078a1edf5b646c60d0163221.jpeg" alt="img"></p>
<p>位移后十进制数值变成：24690，刚好是12345的二倍，所以有些人会用左位移运算符代替乘2的操作，但是这并不代表是真的就是乘以2，很多时候，我们可以这样使用，但是一定要知道，位移运算符很多时候可以代替乘2操作，但是这个并不代表两者是一样的。</p>
<p>思考一下：如果任意一个十进制的数左位移32位，右边补位32个0，十进制岂不是都是0了？当然不是！！！ 当int 类型的数据进行左移的时候，当左移的位数大于等于32位的时候，位数会先求余数，然后再进行左移，也就是说，如果真的左移32位 12345 &lt;&lt; 32 的时候，会先进行位数求余数，即为 12345&lt;&lt;(32%32) 相当于 12345&lt;&lt; 0 ，所以12345&lt;&lt; 33 的值和12345&lt;&lt;1 是一样的，都是 24690。</p>
<p><strong>右移（&gt;&gt;）</strong></p>
<p>同样，还是以12345这个数值为例，12345右移1位： 12345&gt;&gt;1。</p>
<p><img src="/images/d6ca7bcb0a46f21f19ec19641bbd55660d33ae49.jpeg" alt="img"></p>
<p>右移后得到的值为 6172 和int 类型的数据12345除以2取整所得的值一样，所以有些时候也会被用来替代除2操作。另外，对于超过32位的位移，和左移运算符一样，，会先进行位数求余数。</p>
<p><strong>无符号右移（&gt;&gt;&gt;）</strong></p>
<p>无符号右移运算符和右移运算符是一样的，不过无符号右移运算符在右移的时候是补0的，而右移运算符是补符号位的。以下是-12345二进制表示：</p>
<p><img src="/images/21a4462309f790522f7425fafd6ae9cc7acbd52f.jpeg" alt="img"></p>
<p>对于源码、反码、补码不熟悉的同学，请自行学习，这里就不再进行补充了讲解了，这里提醒一下，在右移运算符中，右移后补0，是由于正数 12345 符号位为0 ，如果为1，则应补1。</p>
<p><img src="/images/b17eca8065380cd7f23c4b284ddd933258828171.jpeg" alt="img"></p>
<p><strong>原码、反码和补码说明：</strong></p>
<p>一个数可以分成符号位（0正1负）+ 真值，原码是我们正常想法写出来的二进制。由于计算机只能做加法，负数用单纯的二进制原码书写会出错，于是大家发明了反码（正数不变，负数符号位不变，真值部分取反）；再后来由于+0， -0的争端，于是改进反码，变成补码（正数不变，负数符号位不变，真值部分取反，然后+1）。二进制前面的0都可以省略，所以总结来说：计算机里的负数都是用补码（符号位1，真值部分取反+1）表示的。</p>
<p><strong>位运算符和2的关系</strong></p>
<p>位运算符和乘2、除2在大多数时候是很相似的，可以进行替代，同时效率也会高的多，但是两者切记不能混淆 ；很多时候有人会把两者的概念混淆，尤其是数据刚好是 2、4、6、8、100等偶数的时候，看起来就更相似了，但是对于奇数，如本文使用的12345 ，右移之后结果为6172 ，这个结果就和数学意义上的除以2不同了，不过对于int 类型的数据，除2 会对结果进行取整，所以结果也是6172 ，这就更有迷惑性了。</p>
<h3 id="3-5-赋值运算符"><a href="#3-5-赋值运算符" class="headerlink" title="3.5 赋值运算符"></a>3.5 赋值运算符</h3><p>赋值运算符的作用就是将常量、变量或表达式的值赋给某一个变量。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>运算</th>
<th>范例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>赋值</td>
<td>a&#x3D;3;b&#x3D;3</td>
<td>a&#x3D;3;b&#x3D;2;</td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>加等于</td>
<td>a&#x3D;3;b&#x3D;2;a+&#x3D;b;</td>
<td>a&#x3D;5;b&#x3D;2;</td>
</tr>
<tr>
<td>-&#x3D;</td>
<td>减等于</td>
<td>a&#x3D;3;b&#x3D;2;a-&#x3D;b;</td>
<td>a&#x3D;1;b&#x3D;2;</td>
</tr>
<tr>
<td>*&#x3D;</td>
<td>乘等于</td>
<td>a&#x3D;3;b&#x3D;2;a*&#x3D;b;</td>
<td>a&#x3D;6;b&#x3D;2;</td>
</tr>
<tr>
<td>&#x2F;&#x3D;</td>
<td>除等于</td>
<td>a&#x3D;3;b&#x3D;2;a&#x2F;&#x3D;b;</td>
<td>a&#x3D;1;b&#x3D;2;</td>
</tr>
<tr>
<td>%&#x3D;</td>
<td>模等于</td>
<td>a&#x3D;3;b&#x3D;2;a%&#x3D;b;</td>
<td>a&#x3D;1;b&#x3D;2;</td>
</tr>
</tbody></table>
<p>除了“&#x3D;”，其它的都是特殊的赋值运算符，以“+&#x3D;”为例，x +&#x3D; 3就相当于x &#x3D; x + 3，首先会进行加法运算x+3，再将运算结果赋值给变量x。-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;赋值运算符都可依此类推。</p>
<h3 id="3-6-条件运算符"><a href="#3-6-条件运算符" class="headerlink" title="3.6 条件运算符"></a>3.6 条件运算符</h3><p>条件运算符（ ? : ）也称为 “三元运算符”或“三目运算符”。</p>
<p>语法形式：布尔表达式 ？ 表达式1 ：表达式2。</p>
<p>运算过程：如果布尔表达式的值为true，则返回表达式1的值，否则返回表达式2的值。</p>
<h3 id="3-7-运算符的优先次序"><a href="#3-7-运算符的优先次序" class="headerlink" title="3.7 运算符的优先次序"></a>3.7 运算符的优先次序</h3><p>在对一个表达式进行计算时，如果表达式中含有多种运算符，则要安运算符的优先次序一次从高向低进行。运算符的优先次序如下：</p>
<p><img src="/images/a2cc7cd98d1001e96323d451569745ea55e797f5.png" alt="img"></p>
<h2 id="四、控制执行流程"><a href="#四、控制执行流程" class="headerlink" title="四、控制执行流程"></a>四、控制执行流程</h2><h3 id="4-1-if-else"><a href="#4-1-if-else" class="headerlink" title="4.1 if else"></a>4.1 if else</h3><p>只有一个if</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>一个if 一个else</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个if N个else if 可能可无else</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-for循环"><a href="#4-2-for循环" class="headerlink" title="4.2 for循环"></a>4.2 for循环</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化; 布尔表达式; 运算) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次循环都会进行布尔表达式的判断，布尔表达式为true时，相应的也会执行一次运算，当布尔表达式为false时，循环终止。</p>
<h3 id="4-3-do-while循环"><a href="#4-3-do-while循环" class="headerlink" title="4.3 do while循环"></a>4.3 do while循环</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (布尔表达式) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与do while不同，while是先执行布尔表达式的判断，然后执行代码块，两者的选择就看布尔表达式的位置。</p>
<h3 id="4-4-while循环"><a href="#4-4-while循环" class="headerlink" title="4.4 while循环"></a>4.4 while循环</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (布尔表达式) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与do while不同，while是先执行布尔表达式的判断，然后执行代码块，两者的选择就看布尔表达式的位置。</p>
<h3 id="4-5-break-continue"><a href="#4-5-break-continue" class="headerlink" title="4.5 break continue"></a>4.5 break continue</h3><p>任何迭代语句的代码块部分，都可以用break和continue控制循环的流程</p>
<h3 id="4-5-1-break-终止并跳出循环"><a href="#4-5-1-break-终止并跳出循环" class="headerlink" title="4.5.1 break 终止并跳出循环"></a>4.5.1 break 终止并跳出循环</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] ints = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : ints) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h3 id="4-5-2-continue-结束当次循环，进入下次循环"><a href="#4-5-2-continue-结束当次循环，进入下次循环" class="headerlink" title="4.5.2 continue 结束当次循环，进入下次循环"></a>4.5.2 continue 结束当次循环，进入下次循环</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] ints = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : ints) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//1 3</span></span><br></pre></td></tr></table></figure>

<p>当有多层循环时，break和continue只对当前循环生效。这时候可以用另一种语法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">out:</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : ints) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j : ints) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//1 1 1</span></span><br></pre></td></tr></table></figure>

<p>跳到外层循环继续执行，break的用法也是类似。</p>
<h3 id="4-6-return语句"><a href="#4-6-return语句" class="headerlink" title="4.6 return语句"></a>4.6 return语句</h3><p>方法直接返回，不再执行</p>
<h3 id="4-7-switch语句"><a href="#4-7-switch语句" class="headerlink" title="4.7 switch语句"></a>4.7 switch语句</h3><p>根据值来选择执行的代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (key) &#123;	<span class="comment">//	值</span></span><br><span class="line">    <span class="keyword">case</span> value:	<span class="comment">//	多个case下的value都是唯一的 case块也没有  key与值相等则执行代码块</span></span><br><span class="line">        <span class="keyword">break</span>;	<span class="comment">//	可有可无 有的话直接跳出 没有的话 继续往下执行</span></span><br><span class="line">    <span class="keyword">default</span>:	<span class="comment">//	如果前面都没有执行break 则执行</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、数组"><a href="#五、数组" class="headerlink" title="五、数组"></a>五、数组</h2><h3 id="5-1-数组的定义"><a href="#5-1-数组的定义" class="headerlink" title="5.1 数组的定义"></a>5.1 数组的定义</h3><p>数组是相同类型数据的有序集合。数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。其中，每一个数据称作一个元素，每个元素可以通过一个索引(下标)来访问它们。</p>
<h3 id="5-2-数组的基本特点"><a href="#5-2-数组的基本特点" class="headerlink" title="5.2 数组的基本特点"></a>5.2 数组的基本特点</h3><p>1）长度是确定的。数组一旦被创建，它的大小就是不可以改变的。<br>2）其元素必须是相同类型，不允许出现混合类型。元素的类型可以是java 支持的任意类型<br>3）数组类型可以是任何数据类型，包括基本类型和引用类型。<br>4）数组的元素在堆内存中被分配空间，并且是连续分配的<br>5）使用new 关键字对数组进行 内存的分配。每个元素都会被jvm 赋予默认值。默认规则：整数：0 浮点数：0.0 字符：\u0000 布尔：false 引用数据类型：null。<br>6）数组的元素都是有序号的，序号从0开始，0序的。称作数组的下标、索引、角标</p>
<h3 id="5-3-数组的声明"><a href="#5-3-数组的声明" class="headerlink" title="5.3 数组的声明"></a>5.3 数组的声明</h3><p>1）声明的时候并没有实例化任何对象，只有在实例化数组对象时，JVM才分配空间，这时才与长度有关。<br>2）声明一个数组的时候并没有数组真正被创建。<br>3）构造一个数组，必须指定长度</p>
<h3 id="5-4-数组初始化"><a href="#5-4-数组初始化" class="headerlink" title="5.4  数组初始化"></a>5.4  数组初始化</h3><p>静态初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态初始化：<span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;; <span class="comment">// 静态初始化基本类型数组；</span></span><br></pre></td></tr></table></figure>

<p>动态初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>]; <span class="comment">// 动态初始化数组，先分配空间；</span></span><br><span class="line">arr[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">// 给数组元素赋值；</span></span><br><span class="line">arr[<span class="number">1</span>]=<span class="number">2</span>; <span class="comment">// 给数组元素赋值；</span></span><br></pre></td></tr></table></figure>

<p>默认初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>]; <span class="comment">// 默认值：0,0</span></span><br><span class="line"><span class="type">boolean</span>[] b = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2</span>]; <span class="comment">// 默认值：false,false</span></span><br><span class="line">String[] s = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2</span>]; <span class="comment">// 默认值：null, null</span></span><br></pre></td></tr></table></figure>



<p>例子：</p>
<p><img src="/images/1211462-20180901151338439-769400636.png" alt="img"></p>
<p><img src="/images/1211462-20180901151431717-277396520.png" alt="img"></p>
<h3 id="5-5-数组的遍历"><a href="#5-5-数组的遍历" class="headerlink" title="5.5 数组的遍历"></a>5.5 数组的遍历</h3><p>fo循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="comment">// 初始化数组元素的值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    a[i] = <span class="number">100</span> * i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取元素的值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for-each循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] ss = &#123;<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>, <span class="string">&quot;ddd&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (String temp : ss) &#123;</span><br><span class="line">    System.out.println(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-6-拷贝、删除、扩容操作"><a href="#5-6-拷贝、删除、扩容操作" class="headerlink" title="5.6 拷贝、删除、扩容操作"></a>5.6 拷贝、删除、扩容操作</h3><p>System类里也包含了一个<code>static void arraycopy(object src，int srcpos，object dest， int destpos，int length)</code>方法，该方法可以将src数组里的元素值赋给dest数组的元素，其中srcpos指定从src数组的第几个元素开始赋值，length参数指定将src数组的多少个元素赋给dest数组的元素。</p>
<p>函数原型如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src,  <span class="type">int</span>  srcPos,</span></span><br><span class="line"><span class="params">                                    Object dest, <span class="type">int</span> destPos,</span></span><br><span class="line"><span class="params">                                    <span class="type">int</span> length)</span>;</span><br></pre></td></tr></table></figure>

<p>使用<code>arraycopy</code>函数实现的数组拷贝、删除、扩容操作如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.boom.arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关于数组的操作:拷贝，删除，扩容</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayCopyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        arrayCopy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//        String[] str = &#123; &quot;Java&quot;, &quot;C&quot;, &quot;C++&quot;, &quot;Python&quot;, &quot;JScript&quot; &#125;;</span></span><br><span class="line">        <span class="comment">//        removeElement(str, 1);</span></span><br><span class="line">        <span class="comment">//        </span></span><br><span class="line">        <span class="comment">//        String[] str = &#123; &quot;Java&quot;, &quot;C&quot;, &quot;C++&quot;, &quot;Python&quot;, &quot;JScript&quot; &#125;;</span></span><br><span class="line">        <span class="comment">//        extendRange(str);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的拷贝</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">arrayCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] s1 = &#123; <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;dd&quot;</span>, <span class="string">&quot;ee&quot;</span>, &#125;;</span><br><span class="line">        String[] s2 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">7</span>];</span><br><span class="line">        <span class="comment">// 从s1 里下标为1的数组开始拷贝到s2,存放在s2里下标为2的位置开始，拷贝3个数组。</span></span><br><span class="line">        System.arraycopy(s1, <span class="number">1</span>, s2, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s2.length; i++) &#123;</span><br><span class="line">            System.out.print(s2[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除数组中指定索引的位置,并返回原数组.实则还是拷贝数组，再覆盖原来的数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] removeElement(String[] s, <span class="type">int</span> index) &#123;</span><br><span class="line">        System.arraycopy(s, index + <span class="number">1</span>, s, index, s.length - index - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 特殊处理最后一个数组</span></span><br><span class="line">        s[s.length - <span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">            System.out.print(s[i] + <span class="string">&quot; &quot;</span> + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的扩容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] extendRange(String[] s1)&#123;</span><br><span class="line">        <span class="comment">// 传入的数组基础上空间+3</span></span><br><span class="line">        String[] s2  = <span class="keyword">new</span> <span class="title class_">String</span>[s1.length+<span class="number">3</span>];</span><br><span class="line">        System.arraycopy(s1, <span class="number">0</span>, s2, <span class="number">0</span>, s1.length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;s2.length;i++)&#123;</span><br><span class="line">            System.out.println(s2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-7-java-util-Arrays类"><a href="#5-7-java-util-Arrays类" class="headerlink" title="5.7 java.util.Arrays类"></a>5.7 java.util.Arrays类</h3><p>JDK提供的java.util.Arrays类，包含了常用的数组操作，方便我们日常开发。Arrays类包含了：排序、查找、填充、打印内容等常见的操作。</p>
<p><strong>打印数组</strong><code>Arrays.toString(arr)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a= &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">System.out.println(a); <span class="comment">// 打印数组引用的值</span></span><br><span class="line">System.out.println(Arrays.toString(a)); <span class="comment">// 打印数组元素的值</span></span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[I@15db9742</span><br><span class="line">[1, 2]</span><br></pre></td></tr></table></figure>

<p><strong>数组元素的排序</strong><code>Arrays.toString(arr)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">323</span>, <span class="number">23</span>, <span class="number">543</span>, <span class="number">12</span>, <span class="number">59</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[1, 2, 323, 23, 543, 12, 59]</span><br><span class="line">[1, 2, 12, 23, 59, 323, 543]</span><br></pre></td></tr></table></figure>

<p><strong>二分查找</strong><code>Arrays.binarySearch(arr, key)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">323</span>, <span class="number">23</span>, <span class="number">543</span>, <span class="number">12</span>, <span class="number">59</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">Arrays.sort(arr);  <span class="comment">// 使用二分查找，必须先对数组进行排序</span></span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"><span class="comment">// 返回排序后新的索引位置，若未找到返回负数。</span></span><br><span class="line">System.out.println(<span class="string">&quot;该元素的索引：&quot;</span> + Arrays.binarySearch(arr, <span class="number">12</span>));</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">323</span>, <span class="number">23</span>, <span class="number">543</span>, <span class="number">12</span>, <span class="number">59</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">323</span>, <span class="number">543</span>]</span><br><span class="line">该元素的索引：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>数组填充</strong><code>Arrays.fill(...)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">323</span>, <span class="number">23</span>, <span class="number">543</span>, <span class="number">12</span>, <span class="number">59</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">Arrays.fill(arr, <span class="number">2</span>, <span class="number">4</span>, <span class="number">100</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[1, 2, 323, 23, 543, 12, 59]</span><br><span class="line">[1, 2, 100, 100, 543, 12, 59]</span><br></pre></td></tr></table></figure>

<h3 id="5-8-数组的排序"><a href="#5-8-数组的排序" class="headerlink" title="5.8 数组的排序"></a>5.8 数组的排序</h3><p>数组的排序算法有冒泡排序、选择排序、插入排序、归并排序、快速排序、基数排序、堆排序。</p>
<p><font color="red">TODO 补充上述算法的实现</font></p>
<h3 id="5-9-数组的查找"><a href="#5-9-数组的查找" class="headerlink" title="5.9 数组的查找"></a>5.9 数组的查找</h3><p>数组的查找有遍历搜索、二分查找。</p>
<p><font color="red">TODO 补充上述算法的实现</font></p>
<h3 id="5-10-数组的常见问题"><a href="#5-10-数组的常见问题" class="headerlink" title="5.10 数组的常见问题"></a>5.10 数组的常见问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> []arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">System.out.println(arr[<span class="number">3</span>]); <span class="comment">// ArrayIndexOutofBoundsException</span></span><br><span class="line"><span class="comment">// 当访问到数组中不存在的时下标时：下标越界</span></span><br><span class="line"></span><br><span class="line">arr = <span class="literal">null</span>;</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]); <span class="comment">// NullPointerException</span></span><br><span class="line"><span class="comment">// 当引用类型变量没有指向任何实体时，继续访问引用类型变量，发生空指针异常。</span></span><br><span class="line"></span><br><span class="line">System.out.println(arr); <span class="comment">// [I@3219ab8d:哈希值</span></span><br></pre></td></tr></table></figure>

<h3 id="5-11-数组的内存分析"><a href="#5-11-数组的内存分析" class="headerlink" title="5.11 数组的内存分析"></a>5.11 数组的内存分析</h3><p><img src="/images/20161030125110163.jpeg" alt="img"></p>
<p><img src="/images/20161030125422730.jpeg" alt="img"></p>
<p><img src="/images/1211462-20180901152037185-1093109634.png" alt="img"></p>
<h3 id="5-12-数组的优缺点"><a href="#5-12-数组的优缺点" class="headerlink" title="5.12 数组的优缺点"></a>5.12 数组的优缺点</h3><p><strong>优点</strong></p>
<p>1：可以保存若干个数据。</p>
<p>2：随机访问的效率很高。根据下标访问元素效率高的原因是，元素存放在连续分配的空间上。</p>
<p><strong>缺点</strong></p>
<p>1：数组的元素类型必须一致。</p>
<p>2：连续分配的空间在堆中，如果数组的元素很多，对内存的要求更加严格。</p>
<p>3：根据内容查找元素效率比较低，需要逐个比较个。</p>
<p>4：删除元素、插入元素效率比较低，需要移动大量的元素。</p>
<p>5：数组定长，不能自动扩容。</p>
<p>6：数组没有封装，数组对象只提供了一个数组长度的属性，但是没有提供方法用来操作元素。</p>
<p>java 提供了一整套的 针对不同需求的 对于容器的解决的方案。集合框架部分。不同的容器有不同的特点，满足不同的需求。数组的缺点都会被干掉。</p>
<h3 id="5-13-二维数组"><a href="#5-13-二维数组" class="headerlink" title="5.13 二维数组"></a>5.13 二维数组</h3><p>二维数组实质就是存储元素是一维数组的数组。</p>
<p><strong>二维数组定义：</strong></p>
<p>数组类型[][] 数组名 &#x3D; new 数组类型[一维数组的个数][每一个一维数组中元素的个数];</p>
<p><img src="/images/20161030125652145.jpeg" alt="img"></p>
<p>疑问： 为什么a.length &#x3D; 3, a[0].length &#x3D; 4?</p>
<p><img src="/images/20161030125751375.jpeg" alt="img"></p>
<p><strong>二维数组的初始化：</strong></p>
<p>静态初始化:  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> [][] a = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123; &#123;<span class="number">12</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">89</span>&#125;,&#123;<span class="number">34</span>,<span class="number">56</span>,<span class="number">78</span>,<span class="number">10</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>动态初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>];   <span class="comment">// 长度为3*4=12</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j &lt; a[i].length; j++) &#123;</span><br><span class="line">        a[i][j] =  ++value; <span class="comment">// 例如：a[1][0] = 4;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="六、字符串"><a href="#六、字符串" class="headerlink" title="六、字符串"></a>六、字符串</h2><p>字符串是内存中连续排列的0个或多个字符。不变字符串是指字符串一旦创建，其内容就不能改变，Java中使用String类来处理不变字符串。</p>
<h3 id="6-1-常量字符串与变量字符串"><a href="#6-1-常量字符串与变量字符串" class="headerlink" title="6.1 常量字符串与变量字符串"></a>6.1 常量字符串与变量字符串</h3><p>Java程序中的字符串分为常量和变量两种，其中，字符串常量使用双引号括起来的一串字符，系统为程序中出现的字符串常量自动创建一个String对象。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这句代码将创建一个String对象，值为“hello world!”。</p>
<p>对于字符串变量，在使用之前要显式声明，并进行初始化。字符串的声明方式有三种：</p>
<p><strong>直接创建</strong>：<code>String str1 = &quot;Hello&quot;;</code></p>
<p>字符串是对象，虽然我们在这里没有用new创建对象，其实是编译器给我们做了这些操作。这种创建的字符串对象有一个特点，如果同样的对象如果存在了，就不会创建一个新的对象，而是指向了同样的对象。例如String str2 &#x3D; “Hello”;，则str1和str2是指向了字符串池中同样的内存地址，即 str1 &#x3D;&#x3D; str2 为true。</p>
<p><strong>使用字符串连接创建：</strong> <code>String str = &quot;Hello&quot; + &quot;World&quot;;</code></p>
<p>这种形式其实可以看做是第一种的形式的特殊形式。 “Hello” + “World”在编译期会被自动折叠为常量“HelloWorld”，所以，最后只会创建一个对象：String str &#x3D; “HelloWorld”;</p>
<p>JDK1.7开始，javac会进行常量折叠，全字面量字符串相加是可以折叠为一个字面常量，而且是进入常量池的。这个问题涉及到了<strong>字符串常量池</strong>和<strong>字符串拼接</strong>。<code>String a=&quot;a&quot;+&quot;b&quot;+&quot;c&quot;;</code>通过编译器优化后，得到的效果是：<code>String a=&quot;abc&quot;;</code></p>
<p><strong>new创建字符串</strong>： <code>String str1 = new String(&quot;Hello&quot;);</code></p>
<p>用new关键字创建的字符串每次都会创建一个新的对象。即使这时创建一个字符串<code>String str2 = new String(&quot;Hello&quot;);</code>，str1与str2是两个对象，str1 &#x3D;&#x3D; str2 为false。</p>
<p><img src="/images/v2-784dc6d3bd25910757178f70f0e67a06_1440w.jpg" alt="img"></p>
<p><strong>注意点：</strong> <code>String str = new String(&quot;Hello&quot;);</code> 会产生几个对象？<br>如果字符串池里面没有“Hello”对象，会在字符串池里面生成一个对象，然后再生成一个字符串对象，str指向这个对象；如果字符串池里面已经有了“Hello”对象，则只会生成一个对象，str指向这个对象。</p>
<h3 id="6-2-字符串不可变性的解释"><a href="#6-2-字符串不可变性的解释" class="headerlink" title="6.2 字符串不可变性的解释"></a>6.2 字符串不可变性的解释</h3><p>面试经常会碰到一个问题，就是String不可变，大部分答的时候会讲因为String的源码里面，它是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br></pre></td></tr></table></figure>

<p>它是被final修饰的，被final修饰的真正含义是什么呢？一定能讲出是不可变，那么到底是什么不可变啊？我们可以来试一试:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span>[] value = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">value = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Error:(<span class="number">33</span>, <span class="number">9</span>) java: 无法为最终变量value分配值</span><br></pre></td></tr></table></figure>

<p>这说明引用不可变，value不能再指向另一个变量，但是这能说明value的值不可变吗？我们再来试试看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span>[] value = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">value[<span class="number">1</span>]=<span class="number">4</span>;</span><br><span class="line">System.out.println(value[<span class="number">0</span>]+<span class="string">&quot; &quot;</span>+value[<span class="number">1</span>]+<span class="string">&quot; &quot;</span>+value[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<p>输出就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>因此，final不可变指的是引用对象不可变，而不是对象的值不可变，那么到底是什么让String对象不可变呢？再去源码看看，是不是还有个private，这个让value的值在外部是不可变的。</p>
<h3 id="6-3-字符串常量池"><a href="#6-3-字符串常量池" class="headerlink" title="6.3 字符串常量池"></a>6.3 字符串常量池</h3><p>作为最基础的引用数据类型，Java 设计者为 String 提供了字符串常量池以提高其性能，那么字符串常量池的具体原理是什么，我们带着以下三个问题，去理解字符串常量池：</p>
<ul>
<li><p>字符串常量池的设计意图是什么？</p>
</li>
<li><p>字符串常量池在哪里？</p>
</li>
<li><p>如何操作字符串常量池？</p>
</li>
</ul>
<h4 id="（1）字符串常量池的设计思想"><a href="#（1）字符串常量池的设计思想" class="headerlink" title="（1）字符串常量池的设计思想"></a>（1）字符串常量池的设计思想</h4><p>字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串使用的非常多。JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。由于String字符串的不可变性，常量池中一定不存在两个相同的字符串。</p>
<p>JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化：</p>
<ul>
<li>为字符串开辟一个字符串常量池，类似于缓存区</li>
<li>创建字符串常量时，首先检查字符串常量池是否存在该字符串</li>
<li>存在该字符串，返回引用实例；不存在，实例化该字符串并放入池中</li>
</ul>
<p>实现的基础如下：</p>
<ul>
<li>实现该优化的基础是因为字符串是不可变的，可以不用担心数据冲突进行共享</li>
<li>运行时实例创建的全局字符串常量池中有一个表，总是为池中每个唯一的字符串对象维护一个引用,这就意味着它们一直引用着字符串常量池中的对象，所以，在常量池中的这些字符串不会被垃圾收集器回收</li>
</ul>
<p>从字符串常量池中获取相应的字符串，代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> “hello”;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> “hello”;</span><br><span class="line"></span><br><span class="line">System.out.printl（<span class="string">&quot;str1 == str2&quot;</span> : str1 == str2 ) <span class="comment">//true </span></span><br></pre></td></tr></table></figure>

<h4 id="（2）字符串常量池在哪里"><a href="#（2）字符串常量池在哪里" class="headerlink" title="（2）字符串常量池在哪里"></a>（2）字符串常量池在哪里</h4><p>在分析字符串常量池的位置时，首先了解一下堆、栈、方法区：</p>
<p><img src="/images/java%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83.png" alt="820e4d34-b89d-33a6-a776-4c088a08d2a9.png"></p>
<p>堆区：</p>
<ul>
<li>存储的是对象，每个对象都包含一个与之对应的class</li>
<li>JVM只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身</li>
<li>对象的由垃圾回收器负责回收，因此大小和生命周期不需要确定</li>
</ul>
<p>栈区：</p>
<ul>
<li>每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)</li>
<li>每个栈中的数据(原始类型和对象引用)都是私有的</li>
<li>栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)</li>
<li>数据大小和生命周期是可以确定的，当没有引用指向数据时，这个数据就会自动消失</li>
</ul>
<p>方法区：</p>
<ul>
<li>静态区，跟堆一样，被所有的线程共享</li>
<li>方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。</li>
</ul>
<p><strong>字符串常量池内存区域</strong></p>
<p>在HotSpot VM中字符串常量池是通过一个StringTable类实现的，它是一个Hash表，默认值大小长度是1009；这个StringTable在每个HotSpot VM的实例中只有一份，被所有的类共享；字符串常量由一个一个字符组成，放在了StringTable上。要注意的是，如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降（因为要一个一个找）。</p>
<p>在JDK6及之前版本，字符串常量池是放在Perm Gen区(也就是方法区)中的，StringTable的长度是固定的1009；在JDK7版本中，字符串常量池被移到了堆中，StringTable的长度可以通过**-XX:StringTableSize&#x3D;66666**参数指定。至于JDK7为什么把常量池移动到堆上实现，原因可能是由于方法区的内存空间太小且不方便扩展，而堆的内存空间比较大且扩展方便。</p>
<p><strong>字符串常量池中存放的内容</strong></p>
<p>在JDK6及之前版本中，String Pool里放的都是字符串常量；在JDK7.0中，由于String.intern()发生了改变，因此String Pool中也可以存放放于堆内的字符串对象的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;AB&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;AB&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;AB&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">System.out.println(s1 == s3); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>由于常量池中不存在两个相同的对象，所以s1和s2都是指向JVM字符串常量池中的”AB”对象。new关键字一定会产生一个对象，并且这个对象存储在堆中。所以String s3 &#x3D; new String(“AB”);产生了两个对象：保存在栈中的s3和保存堆中的String对象。</p>
<p><img src="/images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%86%85%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.jpeg" alt="这里写图片描述"></p>
<p>当执行String s1 &#x3D; “AB”时，JVM首先会去字符串常量池中检查是否存在”AB”对象，如果不存在，则在字符串常量池中创建”AB”对象，并将”AB”对象的地址返回给s1；如果存在，则不创建任何对象，直接将字符串常量池中”AB”对象的地址返回给s1。</p>
<p><strong>字符串对象的创建</strong></p>
<p>面试题：String str4 &#x3D; new String(“abc”) 创建多少个对象？</p>
<p>step 1  在常量池中查找是否有“abc”对象，有则返回对应的引用实例，没有则创建对应的实例对象。</p>
<p>step 2  在堆中 new 一个 String(“abc”) 对象。</p>
<p>step 3  将对象地址赋值给str4,创建一个引用。</p>
<p>所以，常量池中没有“abc”字面量则创建两个对象，否则创建一个对象，以及创建一个引用</p>
<p><strong>延伸</strong></p>
<p>基础类型的变量和常量，变量和引用存储在栈中，常量存储在常量池中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a3</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">INT1</span> <span class="operator">=</span><span class="number">1</span> ;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">INT2</span> <span class="operator">=</span><span class="number">1</span> ;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">INT3</span> <span class="operator">=</span><span class="number">1</span> ;</span><br></pre></td></tr></table></figure>

<p><img src="/images/int%E7%B1%BB%E5%9E%8B%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="798b04f9ga8e2c6779148&amp;690"></p>
<h4 id="（3）字面量和常量池的关系"><a href="#（3）字面量和常量池的关系" class="headerlink" title="（3）字面量和常量池的关系"></a>（3）字面量和常量池的关系</h4><p>字符串对象内部是用字符数组存储的，那么看下面的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会分配一个11长度的char数组，并在常量池分配一个由这个char数组组成的字符串，然后由m去引用这个字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">m</span> <span class="operator">=</span> <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line"><span class="comment">// 用n去引用常量池里边的字符串，所以n和m引用的是同一个对象。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">n</span> <span class="operator">=</span> <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line"><span class="comment">// 生成一个新的字符串，但内部的字符数组引用着m内部的字符数组。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(m);</span><br><span class="line"><span class="comment">// 同样会生成一个新的字符串，但内部的字符数组引用常量池里边的字符串内部的字符数组，意思是和u是同样的字符数组。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello,world&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>使用图来表示的话，情况就大概是这样的(使用虚线只是表示两者其实没什么特别的关系)：</p>
<p><img src="/images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9B%E5%BB%BA%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="string1.png"></p>
<p>测试demo代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">m</span> <span class="operator">=</span> <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">n</span> <span class="operator">=</span> <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(m);</span><br><span class="line"><span class="type">String</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(m == n); <span class="comment">//true </span></span><br><span class="line">System.out.println(m == u); <span class="comment">//false</span></span><br><span class="line">System.out.println(m == v); <span class="comment">//false</span></span><br><span class="line">System.out.println(u == v); <span class="comment">//false </span></span><br></pre></td></tr></table></figure>

<p>通过上述代码得到的结论如下：</p>
<ul>
<li>m和n指向的是同一个对象。</li>
<li>m,u,v都是指向不同的对象。</li>
<li>m,u,v,n但都使用了同样的字符数组，并且用equal判断的话也会返回true。</li>
</ul>
<h3 id="6-4-intern-方法"><a href="#6-4-intern-方法" class="headerlink" title="6.4 intern()方法"></a>6.4 intern()方法</h3><p>直接使用双引号声明出来的String对象会直接存储在字符串常量池中，如果不是用双引号声明的String对象，可以使用String提供的intern方法。intern 方法是一个native方法，intern方法会从字符串常量池中查询当前字符串是否存在，如果存在，就直接返回当前字符串；如果不存在就会将当前字符串放入常量池中，之后再返回。</p>
<p>JDK1.7的改动：</p>
<ol>
<li>将String常量池 从 Perm 区移动到了 Java Heap区</li>
<li>String.intern() 方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象。</li>
</ol>
<p>下面是jdk中<code>intern()</code>方法的详细内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a canonical representation for the string object.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * A pool of strings, initially empty, is maintained privately by the</span></span><br><span class="line"><span class="comment"> * class &#123;<span class="doctag">@code</span> String&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * When the intern method is invoked, if the pool already contains a</span></span><br><span class="line"><span class="comment"> * string equal to this &#123;<span class="doctag">@code</span> String&#125; object as determined by</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> #equals(Object)&#125; method, then the string from the pool is</span></span><br><span class="line"><span class="comment"> * returned. Otherwise, this &#123;<span class="doctag">@code</span> String&#125; object is added to the</span></span><br><span class="line"><span class="comment"> * pool and a reference to this &#123;<span class="doctag">@code</span> String&#125; object is returned.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * It follows that for any two strings &#123;<span class="doctag">@code</span> s&#125; and &#123;<span class="doctag">@code</span> t&#125;,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> s.intern() == t.intern()&#125; is &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> * if and only if &#123;<span class="doctag">@code</span> s.equals(t)&#125; is &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * All literal strings and string-valued constant expressions are</span></span><br><span class="line"><span class="comment"> * interned. String literals are defined in section 3.10.5 of the</span></span><br><span class="line"><span class="comment"> * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  a string that has the same contents as this string, but is</span></span><br><span class="line"><span class="comment"> *          guaranteed to be from a pool of unique strings.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">intern</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>



<p><strong>intern() 的用法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Integer[] DB_DATA = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">10</span> * <span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; DB_DATA.length; i++) &#123;</span><br><span class="line">        DB_DATA[i] = random.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX; i++) &#123;</span><br><span class="line">        <span class="comment">//arr[i] = new String(String.valueOf(DB_DATA[i % DB_DATA.length]));</span></span><br><span class="line">         arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(DB_DATA[i % DB_DATA.length])).intern();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println((System.currentTimeMillis() - t) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行的参数是：-Xmx2g -Xms2g -Xmn1500M 上述代码是一个演示代码，其中有两条语句不一样，一条是未使用 intern，一条是使用 intern。结果如下图</p>
<p>未使用intern，耗时826ms：</p>
<p><img src="/images/%E6%9C%AA%E4%BD%BF%E7%94%A8intern%E8%80%97%E6%97%B6.jpeg" alt="这里写图片描述"></p>
<p>使用intern，耗时2160ms：</p>
<p><img src="/images/%E4%BD%BF%E7%94%A8intern%E8%80%97%E6%97%B6.jpeg" alt="这里写图片描述"></p>
<p>细心的同学会发现使用了 intern 方法后时间上有了一些增长。这是因为程序中每次都是用了 new String 后，然后又进行 intern 操作的耗时时间。</p>
<h3 id="6-5-“-”-连接符"><a href="#6-5-“-”-连接符" class="headerlink" title="6.5 “+” 连接符"></a>6.5 “+” 连接符</h3><h4 id="（1）”-”-链接符的实现原理"><a href="#（1）”-”-链接符的实现原理" class="headerlink" title="（1）”+” 链接符的实现原理"></a>（1）”+” 链接符的实现原理</h4><p>Java语言为“+”连接符以及对象转换为字符串提供了特殊的支持，字符串对象可以使用“+”连接其他对象。其中字符串连接是通过 StringBuilder（或 StringBuffer）类及其append 方法实现的，对象转换为字符串是通过 toString 方法实现的，该方法由 Object 类定义，并可被 Java 中的所有类继承。有关字符连接和转换的更多信息，可以参阅 Gosling、Joy 和 Steele 合著的 《The Java Language Specification》。</p>
<p>我们可以通过反编译验证一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(s + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译后的结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;    <span class="comment">//删除了默认构造函数和字节码</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">byte0</span> <span class="operator">=</span> <span class="number">10</span>;      </span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;      </span><br><span class="line">        System.out.println((<span class="keyword">new</span> <span class="title class_">StringBuilder</span>()).append(s).append(byte0).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上可以看出，Java中使用”+”连接字符串对象时，会创建一个StringBuilder()对象，并调用append()方法将数据拼接，最后调用toString()方法返回拼接好的字符串。由于append()方法的各种重载形式会调用String.valueOf方法，所以我们可以认为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下两者是等价的</span></span><br><span class="line">s = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">s = String.valueOf(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下两者也是等价的</span></span><br><span class="line">s = <span class="string">&quot;abc&quot;</span> + i;</span><br><span class="line">s = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;abc&quot;</span>).append(i).toString();</span><br></pre></td></tr></table></figure>

<h4 id="（2）“-”连接符的效率"><a href="#（2）“-”连接符的效率" class="headerlink" title="（2）“+”连接符的效率"></a>（2）“+”连接符的效率</h4><p>使用“+”连接符时，JVM会隐式创建StringBuilder对象，这种方式在大部分情况下并不会造成效率的损失，不过在进行大量循环拼接字符串时则需要注意。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">    s += <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反编译后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    s = (<span class="keyword">new</span> <span class="title class_">StringBuilder</span>()).append(s).append(<span class="string">&quot;abc&quot;</span>).toString();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样由于大量StringBuilder创建在堆内存中，肯定会造成效率的损失，所以在这种情况下建议在循环体外创建一个StringBuilder对象调用append()方法手动拼接（如上面例子如果使用手动拼接运行时间将缩小到1&#x2F;200左右）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 循环中使用StringBuilder代替“+”连接符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    sb.append(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">sb.toString();</span><br></pre></td></tr></table></figure>

<p>与此之外还有一种特殊情况，也就是当”+”两端均为编译期确定的字符串常量时，编译器会进行相应的优化，直接将两个字符串常量拼接好，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span> + <span class="string">&quot;World&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反编译后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编译期确定</span></span><br><span class="line"><span class="comment"> * 对于final修饰的变量，它在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中。</span></span><br><span class="line"><span class="comment"> * 所以此时的&quot;a&quot; + s1和&quot;a&quot; + &quot;b&quot;效果是一样的。故结果为true。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s0</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; </span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>; </span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + s1;  </span><br><span class="line">System.out.println((s0 == s2)); <span class="comment">//result = true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编译期无法确定</span></span><br><span class="line"><span class="comment"> * 这里面虽然将s1用final修饰了，但是由于其赋值是通过方法调用返回的，那么它的值只能在运行期间确定</span></span><br><span class="line"><span class="comment"> * 因此s0和s2指向的不是同一个对象，故程序执行结果为false。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s0</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; </span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> getS1(); </span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + s1; </span><br><span class="line">System.out.println((s0 == s2)); <span class="comment">//result = false </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getS1</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;b&quot;</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上，“+”连接符对于直接相加的字符串常量效率很高，因为在编译期间便确定了它的值，也就是说形如”I”+“love”+“java”; 的字符串相加，在编译期间便被优化成了”Ilovejava”。对于间接相加（即包含字符串引用，且编译期无法确定值的），形如s1+s2+s3; 效率要比直接相加低，因为在编译器不会对引用变量进行优化。</p>
<h3 id="6-6-字符串的操作"><a href="#6-6-字符串的操作" class="headerlink" title="6.6 字符串的操作"></a>6.6 字符串的操作</h3><p>字符串创建以后，可以使用字符串类中的方法对它进行操作。日常开发中常用的操作字符串的方法有：</p>
<h4 id="（1）String当中与获取相关的常用方法"><a href="#（1）String当中与获取相关的常用方法" class="headerlink" title="（1）String当中与获取相关的常用方法"></a>（1）String当中与获取相关的常用方法</h4><p><code>public int length()</code>：获取字符串当中含有的字符个数，拿到字符串长度。</p>
<p><code>public String concat(String str)</code>：将当前字符串和参数字符串<strong>拼接</strong>成为返回值新的字符串。</p>
<p><code>public char charAt(int index)</code>：获取指定索引位置的单个字符，索引从0开始。</p>
<p><code>public int indexOf(String str)</code>：查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回-1值。</p>
<h4 id="（2）字符串的截取方法"><a href="#（2）字符串的截取方法" class="headerlink" title="（2）字符串的截取方法"></a>（2）字符串的截取方法</h4><p><code>public String substring(int index)</code>：截取从参数位置一直到字符串末尾，返回新字符串。</p>
<p><code>public String substring(int begin, int end)</code>：截取从begin开始，一直到end结束，中间的字符串，不包括end。</p>
<h4 id="（3）字符串转换的方法"><a href="#（3）字符串转换的方法" class="headerlink" title="（3）字符串转换的方法"></a>（3）字符串转换的方法</h4><p><code>public char[] toCharArray()</code>：将当前字符串拆分成为字符数组作为返回值。</p>
<p><code>public byte[] getBytes()</code>：获得当前字符串底层的字节数组。</p>
<p><code>public String replace(CharSequence oldString, CharSequence newString)：</code>用<code>newString</code>替换所有的<code>oldString</code>。</p>
<h4 id="（4）分割字符串"><a href="#（4）分割字符串" class="headerlink" title="（4）分割字符串"></a>（4）分割字符串</h4><p><code>public String[] split(String regex)</code>：按照正则表达式参数的规则，将字符串切分成为若干部分。</p>
<h4 id="（5）字符串的比较"><a href="#（5）字符串的比较" class="headerlink" title="（5）字符串的比较"></a>（5）字符串的比较</h4><p>String字符串可以使用<code>==</code>和<code>equals()</code>方法比较。当两个字符串使用<code>==</code>进行比较时，比较的是两个字符串在内存中的地址。当两个字符串使用<code>equals</code>方法比较时，比较的是两个字符串的值是否相等。</p>
<h3 id="6-7-String、StringBuffer和StringBuilder的关系"><a href="#6-7-String、StringBuffer和StringBuilder的关系" class="headerlink" title="6.7 String、StringBuffer和StringBuilder的关系"></a>6.7 String、StringBuffer和StringBuilder的关系</h3><h4 id="（1）继承结构"><a href="#（1）继承结构" class="headerlink" title="（1）继承结构"></a>（1）继承结构</h4><p><img src="/images/String%E3%80%81StringBuilder%E5%92%8CStringBuffer%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.jpeg" alt="这里写图片描述"></p>
<h4 id="（2）主要区别"><a href="#（2）主要区别" class="headerlink" title="（2）主要区别"></a>（2）主要区别</h4><p>1）String是不可变字符序列，StringBuilder和StringBuffer是可变字符序列。<br>2）执行速度StringBuilder &gt; StringBuffer &gt; String。<br>3）StringBuilder是非线程安全的，StringBuffer是线程安全的。</p>
<h3 id="6-8-总结"><a href="#6-8-总结" class="headerlink" title="6.8 总结"></a>6.8 总结</h3><p>String类是我们使用频率最高的类之一，也是面试官经常考察的题目，下面是一个小测验。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;AB&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;AB&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;B&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;A&quot;</span> + <span class="string">&quot;B&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s3 + s4;</span><br><span class="line">    System.out.println(s1 == s2);</span><br><span class="line">    System.out.println(s1 == s5);</span><br><span class="line">    System.out.println(s1 == s6);</span><br><span class="line">    System.out.println(s1 == s6.intern());</span><br><span class="line">    System.out.println(s2 == s2.intern());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="/images/String%E9%9D%A2%E8%AF%95%E9%A2%98%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpeg" alt="这里写图片描述"></p>
<p>题目解析：真正理解此题目需要清楚以下三点<br>1）直接使用双引号声明出来的String对象会直接存储在常量池中；<br>2）String对象的intern方法会得到字符串对象在常量池中对应的引用，如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用；<br>3） 字符串的+操作其本质是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象用toString方法处理成String对象，这一点可以用javap -c命令获得class文件对应的JVM字节码指令就可以看出来。</p>
<p><img src="/images/String%E9%9D%A2%E8%AF%95%E9%A2%98%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90.jpeg" alt="这里写图片描述"></p>
<h3 id="6-9-参考资料"><a href="#6-9-参考资料" class="headerlink" title="6.9 参考资料"></a>6.9 参考资料</h3><p>​		<a href="https://docs.oracle.com/javase/8/docs/api/">https://docs.oracle.com/javase/8/docs/api/</a><br>​		<a href="https://blog.csdn.net/sinat_19425927/article/details/38663461">https://blog.csdn.net/sinat_19425927/article/details/38663461</a><br>​		<a href="https://www.cnblogs.com/xiaoxi/p/6036701.html">https://www.cnblogs.com/xiaoxi/p/6036701.html</a><br>​		<a href="https://tech.meituan.com/in_depth_understanding_string_intern.html">https://tech.meituan.com/in_depth_understanding_string_intern.html</a></p>
]]></content>
      <categories>
        <category>编程 - 基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
