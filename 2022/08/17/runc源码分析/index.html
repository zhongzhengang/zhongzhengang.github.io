<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="为了探究标题上的问题，我们先来看看runc启动容器的示例。 一、runc启动容器示例依据runc的文档，可以知道启动一个容器有下面的步骤。 1、创建OCI 容器启动包使用下面的命令生成rootfs： 123456789# create the top most bundle directory$ mkdir &#x2F;mycontainer$ cd &#x2F;mycontainer# create the roo">
<meta property="og:type" content="article">
<meta property="og:title" content="容器进程是怎么启动的？（runc源码分析）">
<meta property="og:url" content="http://example.com/2022/08/17/runc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="钟镇刚的博客">
<meta property="og:description" content="为了探究标题上的问题，我们先来看看runc启动容器的示例。 一、runc启动容器示例依据runc的文档，可以知道启动一个容器有下面的步骤。 1、创建OCI 容器启动包使用下面的命令生成rootfs： 123456789# create the top most bundle directory$ mkdir &#x2F;mycontainer$ cd &#x2F;mycontainer# create the roo">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/runc%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8.png">
<meta property="og:image" content="http://example.com/images/runc%E5%AE%B9%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C.png">
<meta property="og:image" content="http://example.com/images/runc%E4%B8%89%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB%E5%9B%BE.png">
<meta property="og:image" content="http://example.com/images/nsexec%E5%87%BD%E6%95%B0%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png">
<meta property="article:published_time" content="2022-08-17T11:47:35.528Z">
<meta property="article:modified_time" content="2022-08-17T11:47:35.529Z">
<meta property="article:author" content="钟镇刚">
<meta property="article:tag" content="runc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/runc%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8.png">


<link rel="canonical" href="http://example.com/2022/08/17/runc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/08/17/runc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","path":"2022/08/17/runc源码分析/","title":"容器进程是怎么启动的？（runc源码分析）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>容器进程是怎么启动的？（runc源码分析） | 钟镇刚的博客</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?84040c23487973dba4fe76676ed34bf5"></script>




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">钟镇刚的博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81runc%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.</span> <span class="nav-text">一、runc启动容器示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%88%9B%E5%BB%BAOCI-%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%8C%85"><span class="nav-number">1.1.</span> <span class="nav-text">1、创建OCI 容器启动包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8"><span class="nav-number">1.2.</span> <span class="nav-text">2、运行容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81runc%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA%E5%88%86%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">二、runc容器创建分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">三、容器启动分析</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">钟镇刚</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zhongzhengang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhongzhengang" rel="noopener" target="_blank">GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/mucaoyx" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;mucaoyx" rel="noopener" target="_blank">CSDN</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/17/runc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="钟镇刚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="钟镇刚的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="容器进程是怎么启动的？（runc源码分析） | 钟镇刚的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          容器进程是怎么启动的？（runc源码分析）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-17 19:47:35" itemprop="dateCreated datePublished" datetime="2022-08-17T19:47:35+08:00">2022-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B-docker/" itemprop="url" rel="index"><span itemprop="name">编程 - docker</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>26k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>24 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>为了探究标题上的问题，我们先来看看runc启动容器的示例。</p>
<h2 id="一、runc启动容器示例"><a href="#一、runc启动容器示例" class="headerlink" title="一、runc启动容器示例"></a>一、runc启动容器示例</h2><p>依据runc的文档，可以知道启动一个容器有下面的步骤。</p>
<h3 id="1、创建OCI-容器启动包"><a href="#1、创建OCI-容器启动包" class="headerlink" title="1、创建OCI 容器启动包"></a>1、创建OCI 容器启动包</h3><p>使用下面的命令生成rootfs：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create the top most bundle directory</span></span><br><span class="line">$ <span class="built_in">mkdir</span> /mycontainer</span><br><span class="line">$ <span class="built_in">cd</span> /mycontainer</span><br><span class="line"></span><br><span class="line"><span class="comment"># create the rootfs directory</span></span><br><span class="line">$ <span class="built_in">mkdir</span> rootfs</span><br><span class="line"></span><br><span class="line"><span class="comment"># export busybox via Docker into the rootfs directory</span></span><br><span class="line">$ docker <span class="built_in">export</span> $(docker create busybox) | tar -C rootfs -xvf -</span><br></pre></td></tr></table></figure>

<p>roortfs生成之后，只需要在生成规格说明文件config.json，就完成了OCI容器启动包。使用下面的命令可以生成一个基本的config.json文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ runc spec</span><br></pre></td></tr></table></figure>

<span id="more"></span>


<h3 id="2、运行容器"><a href="#2、运行容器" class="headerlink" title="2、运行容器"></a>2、运行容器</h3><p>依据前面的步骤，你已经有了一个OCI容器包，现在你可以有两种方式执行容器。</p>
<p>第一种方式是你可以使用<code>runc</code>命令轻松的创建、开启、删除容器。下面的命令可以开启容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># run as root</span></span><br><span class="line"><span class="built_in">cd</span> /mycontainer</span><br><span class="line">runc run mycontainerid</span><br></pre></td></tr></table></figure>

<p>如果你使用的是没有修改的<code>runc spec</code>生成的config.json模板，那么你将会得到一个运行在容器中的sh会话。</p>
<p>下面是容器启动之后的截图：</p>
<p><img src="/images/runc%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8.png" alt="image-20220805090657093"></p>
<p>第二种开启容器的方式是使用spec声明周期操作，具体的就是修改config.json文件。这种方式可以有效的管理容器的创建和运行。如果移除了config.json中的<code>terminal</code>设置，那么容器就会在后台运行，下面是一个简单的例子。在config.json文件<code>process</code>字段设置<code>&quot;terminal&quot;: false</code> 和 <code>&quot;args&quot;: [&quot;sleep&quot;, &quot;10&quot;]</code>.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;process&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;terminal&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;uid&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;gid&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;sleep&quot;</span><span class="punctuation">,</span> <span class="string">&quot;10&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;TERM=xterm&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;capabilities&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;bounding&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;CAP_AUDIT_WRITE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;CAP_KILL&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;CAP_NET_BIND_SERVICE&quot;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;effective&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;CAP_AUDIT_WRITE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;CAP_KILL&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;CAP_NET_BIND_SERVICE&quot;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;inheritable&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;CAP_AUDIT_WRITE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;CAP_KILL&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;CAP_NET_BIND_SERVICE&quot;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;permitted&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;CAP_AUDIT_WRITE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;CAP_KILL&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;CAP_NET_BIND_SERVICE&quot;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ambient&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;CAP_AUDIT_WRITE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;CAP_KILL&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;CAP_NET_BIND_SERVICE&quot;</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;rlimits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RLIMIT_NOFILE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;hard&quot;</span><span class="punctuation">:</span> <span class="number">1024</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;soft&quot;</span><span class="punctuation">:</span> <span class="number">1024</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;noNewPrivileges&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>现在我们就可以在shell中进行生命周期操作了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># run as root</span></span><br><span class="line"><span class="built_in">cd</span> /mycontainer</span><br><span class="line">runc create mycontainerid</span><br><span class="line"></span><br><span class="line"><span class="comment"># view the container is created and in the &quot;created&quot; state</span></span><br><span class="line">runc list</span><br><span class="line"></span><br><span class="line"><span class="comment"># start the process inside the container</span></span><br><span class="line">runc start mycontainerid</span><br><span class="line"></span><br><span class="line"><span class="comment"># after 5 seconds view that the container has exited and is now in the stopped state</span></span><br><span class="line">runc list</span><br><span class="line"></span><br><span class="line"><span class="comment"># now delete the container</span></span><br><span class="line">runc delete mycontainerid</span><br></pre></td></tr></table></figure>

<p>下面是执行容器生命周期操作的截图：</p>
<p><img src="/images/runc%E5%AE%B9%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C.png" alt="image-20220805100024378"></p>
<p>这种方式启动容器，可以运行更高层级的系统配置容器创建逻辑。例如，容器的网络栈一般就是在<code>create</code>之后<code>start</code>之前设置的。</p>
<p>接下来我们就看看runc代码中是怎么完成容器生命周期的，下文的源码分析基于runc源码release-1.1版本</p>
<h2 id="二、runc容器创建分析"><a href="#二、runc容器创建分析" class="headerlink" title="二、runc容器创建分析"></a>二、runc容器创建分析</h2><p>runc的命令行是使用urfave&#x2F;cli创建的。</p>
<p>首先在main函数中创建并注册了命令：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    	app := cli.NewApp()</span><br><span class="line">	app.Name = <span class="string">&quot;runc&quot;</span></span><br><span class="line">	app.Usage = usage</span><br><span class="line">    ...... <span class="comment">// 省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册命令</span></span><br><span class="line">    app.Commands = []cli.Command&#123;</span><br><span class="line">		checkpointCommand,</span><br><span class="line">		createCommand, <span class="comment">//  创建容器的命令  // ref-1</span></span><br><span class="line">		deleteCommand,</span><br><span class="line">		eventsCommand,</span><br><span class="line">		execCommand,</span><br><span class="line">		killCommand,</span><br><span class="line">		listCommand,</span><br><span class="line">		pauseCommand,</span><br><span class="line">		psCommand,</span><br><span class="line">		restoreCommand,</span><br><span class="line">		resumeCommand,</span><br><span class="line">		runCommand,</span><br><span class="line">		specCommand,</span><br><span class="line">		startCommand, <span class="comment">// 开启容器的命令  // ref-2</span></span><br><span class="line">		stateCommand,</span><br><span class="line">		updateCommand,</span><br><span class="line">		featuresCommand,</span><br><span class="line">	&#125;</span><br><span class="line">    ...... <span class="comment">// 省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行命令</span></span><br><span class="line">    <span class="keyword">if</span> err := app.Run(os.Args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接下来看看<code>ref-1</code>处的<code>createCommand</code>命令都干了些什么事情？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create.go 文件</span></span><br><span class="line"><span class="keyword">var</span> createCommand = cli.Command&#123;</span><br><span class="line">	Name:  <span class="string">&quot;create&quot;</span>,</span><br><span class="line">	Usage: <span class="string">&quot;create a container&quot;</span>,</span><br><span class="line">	ArgsUsage: <span class="string">`&lt;container-id&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Where &quot;&lt;container-id&gt;&quot; is your name for the instance of the container that you</span></span><br><span class="line"><span class="string">are starting. The name you provide for the container instance must be unique on</span></span><br><span class="line"><span class="string">your host.`</span>,</span><br><span class="line">	Description: <span class="string">`The create command creates an instance of a container for a bundle. The bundle</span></span><br><span class="line"><span class="string">is a directory with a specification file named &quot;`</span> + specConfig + <span class="string">`&quot; and a root</span></span><br><span class="line"><span class="string">filesystem.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The specification file includes an args parameter. The args parameter is used</span></span><br><span class="line"><span class="string">to specify command(s) that get run when the container is started. To change the</span></span><br><span class="line"><span class="string">command(s) that get executed on start, edit the args parameter of the spec. See</span></span><br><span class="line"><span class="string">&quot;runc spec --help&quot; for more explanation.`</span>,</span><br><span class="line">	Flags: []cli.Flag&#123;</span><br><span class="line">		...... <span class="comment">// 省略flag绑定</span></span><br><span class="line">	&#125;,</span><br><span class="line">	Action: <span class="function"><span class="keyword">func</span><span class="params">(context *cli.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := checkArgs(context, <span class="number">1</span>, exactArgs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"> 		<span class="comment">// 执行创建容器命令的函数</span></span><br><span class="line">		status, err := startContainer(context, CT_ACT_CREATE, <span class="literal">nil</span>) <span class="comment">// ref-3</span></span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// exit with the container&#x27;s exit status so any external supervisor</span></span><br><span class="line">			<span class="comment">// is notified of the exit with the correct exit status.</span></span><br><span class="line">			os.Exit(status)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;runc create failed: %w&quot;</span>, err)</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意<code>create</code>命令的<code>Description</code>部分，它指出了<code>runc</code>会依据由<code>rootfs</code>和<code>config.json</code>组成的bundle来创建容器，如果有什么定制化，那么就去修改<code>config.json</code>文件。</p>
<p>我们在<code>createCommand</code>的<code>Action</code>字段看见了处理容器创建命令的真实函数<code>startContainer(context, CT_ACT_CREATE, nil)</code>，也就是代码<code>ref-3</code>处。我们接着往下看。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils_linux.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startContainer</span><span class="params">(context *cli.Context, action CtAct, criuOpts *libcontainer.CriuOpts)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    ...... <span class="comment">// 省略</span></span><br><span class="line">    <span class="comment">// 获取规格说明</span></span><br><span class="line">	spec, err := setupSpec(context)</span><br><span class="line">	<span class="comment">// 获取传入的容器id</span></span><br><span class="line">	id := context.Args().First()</span><br><span class="line">    ...... <span class="comment">// 省略</span></span><br><span class="line">    <span class="comment">// 加载factory，创建libcontainer.Container对象，实际上就是创建容器需要用到的目录</span></span><br><span class="line">	container, err := createContainer(context, id, spec)</span><br><span class="line">    ...... <span class="comment">// 省略</span></span><br><span class="line">	r := &amp;runner&#123;</span><br><span class="line">		enableSubreaper: !context.Bool(<span class="string">&quot;no-subreaper&quot;</span>),</span><br><span class="line">		shouldDestroy:   !context.Bool(<span class="string">&quot;keep&quot;</span>),</span><br><span class="line">		container:       container,</span><br><span class="line">		listenFDs:       listenFDs,</span><br><span class="line">		notifySocket:    notifySocket,</span><br><span class="line">		consoleSocket:   context.String(<span class="string">&quot;console-socket&quot;</span>),</span><br><span class="line">		detach:          context.Bool(<span class="string">&quot;detach&quot;</span>),</span><br><span class="line">		pidFile:         context.String(<span class="string">&quot;pid-file&quot;</span>),</span><br><span class="line">		preserveFDs:     context.Int(<span class="string">&quot;preserve-fds&quot;</span>),</span><br><span class="line">		action:          action,</span><br><span class="line">		criuOpts:        criuOpts,</span><br><span class="line">		init:            <span class="literal">true</span>,</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 执行容器指定的命令</span></span><br><span class="line">	<span class="keyword">return</span> r.run(spec.Process)  <span class="comment">// ref-4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看看<code>ref-4</code>处的<code>run</code>函数内容：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils_linux.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *runner)</span></span> run(config *specs.Process) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">    <span class="comment">// 创建容器进程结构体libcontainer.Process对象</span></span><br><span class="line">	process, err := newProcess(*config) <span class="comment">// ref-5</span></span><br><span class="line">	process.LogLevel = strconv.Itoa(<span class="type">int</span>(logrus.GetLevel()))</span><br><span class="line">	<span class="comment">// Populate the fields that come from runner.</span></span><br><span class="line">	process.Init = r.init</span><br><span class="line">	process.SubCgroupPaths = r.subCgroupPaths</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(r.listenFDs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		process.Env = <span class="built_in">append</span>(process.Env, <span class="string">&quot;LISTEN_FDS=&quot;</span>+strconv.Itoa(<span class="built_in">len</span>(r.listenFDs)), <span class="string">&quot;LISTEN_PID=1&quot;</span>)</span><br><span class="line">		process.ExtraFiles = <span class="built_in">append</span>(process.ExtraFiles, r.listenFDs...)</span><br><span class="line">	&#125;</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="keyword">switch</span> r.action &#123;</span><br><span class="line">	<span class="keyword">case</span> CT_ACT_CREATE:</span><br><span class="line">		err = r.container.Start(process)  <span class="comment">// ref-6</span></span><br><span class="line">	<span class="keyword">case</span> CT_ACT_RESTORE:</span><br><span class="line">		err = r.container.Restore(process, r.criuOpts)</span><br><span class="line">	<span class="keyword">case</span> CT_ACT_RUN:</span><br><span class="line">		err = r.container.Run(process)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;Unknown action&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">    <span class="comment">// 处理信号</span></span><br><span class="line">	status, err := handler.forward(process, tty, detach)</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="keyword">return</span> status, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ref-5</code>处创建了一个代表容器进程的<code>process</code>对象，然后再<code>ref-6</code>处执行了启动，我们看看<code>r.container.Start(process) </code>又干了什么事情？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libcontainer/container_linux.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *linuxContainer)</span></span> Start(process *Process) <span class="type">error</span> &#123;</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="keyword">if</span> process.Init &#123; <span class="comment">// ref-7</span></span><br><span class="line">        <span class="comment">// 创建用于和子进程通信的fifo文件</span></span><br><span class="line">		<span class="keyword">if</span> err := c.createExecFifo(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := c.start(process); err != <span class="literal">nil</span> &#123; <span class="comment">// ref-8</span></span><br><span class="line">		<span class="keyword">if</span> process.Init &#123;</span><br><span class="line">			c.deleteExecFifo()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ref-7</code>处会判断<code>process</code>是否为容器中的第一个进程，如果是的话，就会调用<code>c.createExecFifo()</code>创建后续与子进程通信的管道。</p>
<p>在<code>ref-8</code>处就会开启容器中的进程process，我们看看runc是怎么开启进程的？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// container_linux.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *linuxContainer)</span></span> start(process *Process) (retErr <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 创建父进程</span></span><br><span class="line">    parent, err := c.newParentProcess(process) <span class="comment">// ref-9</span></span><br><span class="line">	<span class="comment">// 设置同步子进程的日志</span></span><br><span class="line">	logsDone := parent.forwardChildLogs()</span><br><span class="line">	<span class="keyword">if</span> logsDone != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// Wait for log forwarder to finish. This depends on</span></span><br><span class="line">			<span class="comment">// runc init closing the _LIBCONTAINER_LOGPIPE log fd.</span></span><br><span class="line">			err := &lt;-logsDone</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; retErr == <span class="literal">nil</span> &#123;</span><br><span class="line">				retErr = fmt.Errorf(<span class="string">&quot;unable to forward init logs: %w&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := parent.start(); err != <span class="literal">nil</span> &#123; <span class="comment">// ref-10</span></span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to start container process: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ref-9</code>创建了一个父进程，这个可能后面需要好好看看，我们先看下<code>ref-10</code>处的父进程开启操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// process_linux.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *initProcess)</span></span> start() (retErr <span class="type">error</span>) &#123;</span><br><span class="line">	err := p.cmd.Start() <span class="comment">// ref-11 使用系统调用创建了子进程，但是和当前进程并不是父子进程关系</span></span><br><span class="line">	p.process.ops = p</span><br><span class="line">	<span class="comment">// close the write-side of the pipes (controlled by child)</span></span><br><span class="line">	_ = p.messageSockPair.child.Close()</span><br><span class="line">	_ = p.logFilePair.child.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		p.process.ops = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to start init: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">    <span class="comment">// 创建等待子进程完成任务的channel</span></span><br><span class="line">	waitInit := initWaiter(p.messageSockPair.parent)</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">    <span class="comment">// 将启动数据bootstrapData发送给子进程</span></span><br><span class="line">	<span class="keyword">if</span> _, err := io.Copy(p.messageSockPair.parent, p.bootstrapData); err != <span class="literal">nil</span> &#123; <span class="comment">// ref-16</span></span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;can&#x27;t copy bootstrap data to pipe: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	err = &lt;-waitInit <span class="comment">// 等待子进程完成工作</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	childPid, err := p.getChildPid()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;can&#x27;t get final child&#x27;s PID from pipe: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">    <span class="comment">// 创建网卡</span></span><br><span class="line">	<span class="keyword">if</span> err := p.createNetworkInterfaces(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error creating network interfaces: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 更新状态</span></span><br><span class="line">	<span class="keyword">if</span> err := p.updateSpecState(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error updating spec state: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 向子进程发送配置</span></span><br><span class="line">	<span class="keyword">if</span> err := p.sendConfig(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error sending config to init process: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		sentRun    <span class="type">bool</span></span><br><span class="line">		sentResume <span class="type">bool</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	ierr := parseSync(p.messageSockPair.parent, <span class="function"><span class="keyword">func</span><span class="params">(sync *syncT)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="comment">// 处理子进程消息的逻辑	</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 关闭和子进程通信的管道</span></span><br><span class="line">	<span class="keyword">if</span> err := unix.Shutdown(<span class="type">int</span>(p.messageSockPair.parent.Fd()), unix.SHUT_WR); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;os.PathError&#123;Op: <span class="string">&quot;shutdown&quot;</span>, Path: <span class="string">&quot;(init pipe)&quot;</span>, Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>ref-11</code>处的<code>cmd</code>其实是由下面的代码<code>ref-12</code>中指定的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libcontainer/factory_linux.go 文件</span></span><br><span class="line"><span class="comment">// New returns a linux based container factory based in the root directory and</span></span><br><span class="line"><span class="comment">// configures the factory with the provided option funcs.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(root <span class="type">string</span>, options ...<span class="keyword">func</span>(*LinuxFactory)</span></span> <span class="type">error</span>) (Factory, <span class="type">error</span>) &#123;</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">	l := &amp;LinuxFactory&#123;</span><br><span class="line">		Root:      root,</span><br><span class="line">		InitPath:  <span class="string">&quot;/proc/self/exe&quot;</span>, <span class="comment">// ref-12 执行路径其实就是runc自己</span></span><br><span class="line">		InitArgs:  []<span class="type">string</span>&#123;os.Args[<span class="number">0</span>], <span class="string">&quot;init&quot;</span>&#125;,</span><br><span class="line">		Validator: validate.New(),</span><br><span class="line">		CriuPath:  <span class="string">&quot;criu&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="keyword">return</span> l, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在的重点是这个父进程<code>parentProcess</code>里面具体都有些什么？我们来看看<code>ref-9</code>处的<code>c.newParentProcess(process)</code>实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libcontainer/container_linux.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *linuxContainer)</span></span> newParentProcess(p *Process) (parentProcess, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 创建用于父子进程传递消息的文件对</span></span><br><span class="line">    parentInitPipe, childInitPipe, err := utils.NewSockPair(<span class="string">&quot;init&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unable to create init pipe: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	messageSockPair := filePair&#123;parentInitPipe, childInitPipe&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 创建用于父子进程传输日志的文件对</span></span><br><span class="line">	parentLogPipe, childLogPipe, err := os.Pipe()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unable to create log pipe: %w&quot;</span>, err)</span><br><span class="line">	&#125;  </span><br><span class="line">	logFilePair := filePair&#123;parentLogPipe, childLogPipe&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依据模板创建命令</span></span><br><span class="line">	cmd := c.commandTemplate(p, childInitPipe, childLogPipe) <span class="comment">// ref-13</span></span><br><span class="line">	<span class="keyword">if</span> !p.Init &#123;</span><br><span class="line">        <span class="comment">// 如果不是容器的第一个进程就创建SetnsProcess</span></span><br><span class="line">		<span class="keyword">return</span> c.newSetnsProcess(p, cmd, messageSockPair, logFilePair) <span class="comment">// ref-14</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We only set up fifoFd if we&#x27;re not doing a `runc exec`. The historic</span></span><br><span class="line">	<span class="comment">// reason for this is that previously we would pass a dirfd that allowed</span></span><br><span class="line">	<span class="comment">// for container rootfs escape (and not doing it in `runc exec` avoided</span></span><br><span class="line">	<span class="comment">// that problem), but we no longer do that. However, there&#x27;s no need to do</span></span><br><span class="line">	<span class="comment">// this for `runc exec` so we just keep it this way to be safe.</span></span><br><span class="line">	<span class="keyword">if</span> err := c.includeExecFifo(cmd); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unable to setup exec fifo: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果是容器的第一个进程就创建InitProcess</span></span><br><span class="line">	<span class="keyword">return</span> c.newInitProcess(p, cmd, messageSockPair, logFilePair) <span class="comment">// ref-15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我接下来看看<code>ref-13</code>处的命令模板情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libcontainer/container_linux.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *linuxContainer)</span></span> commandTemplate(p *Process, childInitPipe *os.File, childLogPipe *os.File) *exec.Cmd &#123;</span><br><span class="line">    <span class="comment">// 创建操作系统支持的command</span></span><br><span class="line">	cmd := exec.Command(c.initPath, c.initArgs[<span class="number">1</span>:]...)</span><br><span class="line">    <span class="comment">// 下面就是设置命令的参数和环境变量，其实就是在向子进程传递信息</span></span><br><span class="line">	cmd.Args[<span class="number">0</span>] = c.initArgs[<span class="number">0</span>]</span><br><span class="line">	cmd.Stdin = p.Stdin</span><br><span class="line">	cmd.Stdout = p.Stdout</span><br><span class="line">	cmd.Stderr = p.Stderr</span><br><span class="line">	cmd.Dir = c.config.Rootfs</span><br><span class="line">	<span class="keyword">if</span> cmd.SysProcAttr == <span class="literal">nil</span> &#123;</span><br><span class="line">		cmd.SysProcAttr = &amp;unix.SysProcAttr&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cmd.Env = <span class="built_in">append</span>(cmd.Env, <span class="string">&quot;GOMAXPROCS=&quot;</span>+os.Getenv(<span class="string">&quot;GOMAXPROCS&quot;</span>))</span><br><span class="line">	cmd.ExtraFiles = <span class="built_in">append</span>(cmd.ExtraFiles, p.ExtraFiles...)</span><br><span class="line">	<span class="keyword">if</span> p.ConsoleSocket != <span class="literal">nil</span> &#123;</span><br><span class="line">		cmd.ExtraFiles = <span class="built_in">append</span>(cmd.ExtraFiles, p.ConsoleSocket)</span><br><span class="line">		cmd.Env = <span class="built_in">append</span>(cmd.Env,</span><br><span class="line">			<span class="string">&quot;_LIBCONTAINER_CONSOLE=&quot;</span>+strconv.Itoa(stdioFdCount+<span class="built_in">len</span>(cmd.ExtraFiles)<span class="number">-1</span>),</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">	cmd.ExtraFiles = <span class="built_in">append</span>(cmd.ExtraFiles, childInitPipe)</span><br><span class="line">	cmd.Env = <span class="built_in">append</span>(cmd.Env,</span><br><span class="line">		<span class="string">&quot;_LIBCONTAINER_INITPIPE=&quot;</span>+strconv.Itoa(stdioFdCount+<span class="built_in">len</span>(cmd.ExtraFiles)<span class="number">-1</span>),</span><br><span class="line">		<span class="string">&quot;_LIBCONTAINER_STATEDIR=&quot;</span>+c.root,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	cmd.ExtraFiles = <span class="built_in">append</span>(cmd.ExtraFiles, childLogPipe)</span><br><span class="line">	cmd.Env = <span class="built_in">append</span>(cmd.Env,</span><br><span class="line">		<span class="string">&quot;_LIBCONTAINER_LOGPIPE=&quot;</span>+strconv.Itoa(stdioFdCount+<span class="built_in">len</span>(cmd.ExtraFiles)<span class="number">-1</span>),</span><br><span class="line">		<span class="string">&quot;_LIBCONTAINER_LOGLEVEL=&quot;</span>+p.LogLevel,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们看看<code>ref-15</code>处的<code>InitProcess</code>创建过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libcontainer/container_linux.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *linuxContainer)</span></span> newInitProcess(p *Process, cmd *exec.Cmd, messageSockPair, logFilePair filePair) (*initProcess, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 追加环境变量</span></span><br><span class="line">	cmd.Env = <span class="built_in">append</span>(cmd.Env, <span class="string">&quot;_LIBCONTAINER_INITTYPE=&quot;</span>+<span class="type">string</span>(initStandard))</span><br><span class="line">    <span class="comment">// 设置namespace信息</span></span><br><span class="line">	nsMaps := <span class="built_in">make</span>(<span class="keyword">map</span>[configs.NamespaceType]<span class="type">string</span>)</span><br><span class="line">	<span class="keyword">for</span> _, ns := <span class="keyword">range</span> c.config.Namespaces &#123; <span class="comment">// ref-17</span></span><br><span class="line">		<span class="keyword">if</span> ns.Path != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			nsMaps[ns.Type] = ns.Path</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	_, sharePidns := nsMaps[configs.NEWPID]</span><br><span class="line">    <span class="comment">// 创建子进程的bootstrap数据</span></span><br><span class="line">	data, err := c.bootstrapData(c.config.Namespaces.CloneFlags(), nsMaps, initStandard)<span class="comment">// ref-23</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.shouldSendMountSources() &#123;</span><br><span class="line">		...... <span class="comment">// 省略创建挂载信息的代码</span></span><br><span class="line">		cmd.Env = <span class="built_in">append</span>(cmd.Env,</span><br><span class="line">			<span class="string">&quot;_LIBCONTAINER_MOUNT_FDS=&quot;</span>+<span class="type">string</span>(mountFdsJson),</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	init := &amp;initProcess&#123;</span><br><span class="line">		cmd:             cmd, <span class="comment">// 其实就是/proc/self/exe   runc命令自己的执行程序</span></span><br><span class="line">		messageSockPair: messageSockPair, <span class="comment">// 消息通信</span></span><br><span class="line">		logFilePair:     logFilePair, <span class="comment">// 日志通信</span></span><br><span class="line">		manager:         c.cgroupManager, <span class="comment">// cgroups管理</span></span><br><span class="line">		intelRdtManager: c.intelRdtManager,</span><br><span class="line">		config:          c.newInitConfig(p), <span class="comment">// 初始化配置</span></span><br><span class="line">		container:       c,  <span class="comment">// 容器对象</span></span><br><span class="line">		process:         p, <span class="comment">// 进程对象</span></span><br><span class="line">		bootstrapData:   data, <span class="comment">// 子进程引导数据</span></span><br><span class="line">		sharePidns:      sharePidns, <span class="comment">// 子进程要完成的pid命名空间切换</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.initProcess = init</span><br><span class="line">	<span class="keyword">return</span> init, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ref-17</code>在设置namespace信息组成的ma，,根据config.json中namespaces配置，生成一个namespace为key，path为value的map。这个namespace的map在构造bootstrapdata时，会判断每个namespace是否配置了path，如果配置了，则之后不再创建新的namespace，而是将这种类型的namespace  join 到这个path下。</p>
<p>我们再来看看<code>ref-23</code>处的代码都创建了哪些bootstrap参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mapping etc.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *linuxContainer)</span></span> bootstrapData(cloneFlags <span class="type">uintptr</span>, nsMaps <span class="keyword">map</span>[configs.NamespaceType]<span class="type">string</span>, it initType) (_ io.Reader, Err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// create the netlink message</span></span><br><span class="line">	r := nl.NewNetlinkRequest(<span class="type">int</span>(InitMsg), <span class="number">0</span>)</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="comment">// write cloneFlags</span></span><br><span class="line">	r.AddData(&amp;Int32msg&#123;</span><br><span class="line">		Type:  CloneFlagsAttr,</span><br><span class="line">		Value: <span class="type">uint32</span>(cloneFlags),</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// write custom namespace paths</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nsMaps) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		nsPaths, err := c.orderNamespacePaths(nsMaps)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		r.AddData(&amp;Bytemsg&#123;</span><br><span class="line">			Type:  NsPathsAttr,</span><br><span class="line">			Value: []<span class="type">byte</span>(strings.Join(nsPaths, <span class="string">&quot;,&quot;</span>)),</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// write namespace paths only when we are not joining an existing user ns</span></span><br><span class="line">	_, joinExistingUser := nsMaps[configs.NEWUSER]</span><br><span class="line">	<span class="keyword">if</span> !joinExistingUser &#123;</span><br><span class="line">		<span class="comment">// write uid mappings</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(c.config.UidMappings) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            ...... <span class="comment">// 写入uid</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// write gid mappings</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(c.config.GidMappings) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			...... <span class="comment">// 写入gid</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.config.OomScoreAdj != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// write oom_score_adj</span></span><br><span class="line">		r.AddData(&amp;Bytemsg&#123;</span><br><span class="line">			Type:  OomScoreAdjAttr,</span><br><span class="line">			Value: []<span class="type">byte</span>(strconv.Itoa(*c.config.OomScoreAdj)),</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// write rootless</span></span><br><span class="line">	r.AddData(&amp;Boolmsg&#123;</span><br><span class="line">		Type:  RootlessEUIDAttr,</span><br><span class="line">		Value: c.config.RootlessEUID,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Bind mount source to open.</span></span><br><span class="line">	<span class="keyword">if</span> it == initStandard &amp;&amp; c.shouldSendMountSources() &#123;</span><br><span class="line">		...... <span class="comment">// 构建挂载信息</span></span><br><span class="line">		r.AddData(&amp;Bytemsg&#123;</span><br><span class="line">			Type:  MountSourcesAttr,</span><br><span class="line">			Value: mounts,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通过netlink消息格式封装</span></span><br><span class="line">	<span class="keyword">return</span> bytes.NewReader(r.Serialize()), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bootstrapData: 构造出 run init 阶段需要用到的启动参数。包括clone(2)的clone flag，uid&#x2F;gid映射, oom阈值，rootless相关的设置等等。这些配置都通过netlink消息格式封装。然后通过之前的那对unix socketpair将其发送给子进程。</p>
<p>现在就是有一个疑问了，子进程中是怎么处理这些信息的呢？子进程又给父进程发送了哪些信息呢？</p>
<p>这些疑问的答案都被runc隐藏在<code>init.go</code>文件中了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init.go 文件</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/opencontainers/runc/libcontainer&quot;</span></span><br><span class="line">	_ <span class="string">&quot;github.com/opencontainers/runc/libcontainer/nsenter&quot;</span> <span class="comment">// ref-22</span></span><br><span class="line">	<span class="string">&quot;github.com/sirupsen/logrus&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &amp;&amp; os.Args[<span class="number">1</span>] == <span class="string">&quot;init&quot;</span> &#123; <span class="comment">// ref-18</span></span><br><span class="line">		<span class="comment">// This is the golang entry point for runc init, executed</span></span><br><span class="line">		<span class="comment">// before main() but after libcontainer/nsenter&#x27;s nsexec().</span></span><br><span class="line">		runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">		runtime.LockOSThread() <span class="comment">// ref-19</span></span><br><span class="line"></span><br><span class="line">		level, err := strconv.Atoi(os.Getenv(<span class="string">&quot;_LIBCONTAINER_LOGLEVEL&quot;</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		logPipeFd, err := strconv.Atoi(os.Getenv(<span class="string">&quot;_LIBCONTAINER_LOGPIPE&quot;</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		logrus.SetLevel(logrus.Level(level))</span><br><span class="line">		logrus.SetOutput(os.NewFile(<span class="type">uintptr</span>(logPipeFd), <span class="string">&quot;logpipe&quot;</span>))</span><br><span class="line">		logrus.SetFormatter(<span class="built_in">new</span>(logrus.JSONFormatter))</span><br><span class="line">		logrus.Debug(<span class="string">&quot;child process in init()&quot;</span>)</span><br><span class="line"></span><br><span class="line">		factory, _ := libcontainer.New(<span class="string">&quot;&quot;</span>) <span class="comment">// ref-20</span></span><br><span class="line">		<span class="keyword">if</span> err := factory.StartInitialization(); err != <span class="literal">nil</span> &#123; <span class="comment">// ref-21</span></span><br><span class="line">			<span class="comment">// as the error is sent back to the parent there is no need to log</span></span><br><span class="line">			<span class="comment">// or write it to stderr because the parent process will handle this</span></span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;libcontainer: container init failed to exec&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别注意<code>ref-18</code>处的注释，这个<code>init()</code>方法会<code>在main()</code>函数之前，<code>libcontainer/nsenter</code>的<code>nsexec()</code>之后，执行。这个<code>libcontainer/nsenter</code>是在<code>import</code>中导入的，在<code>ref-22</code>处代码。</p>
<p>我们得先看看<code>nsexec()</code>函数干了些什么事情？</p>
<p><code>nsexec()</code>是使用C代码实现的，具体的作用就是实现命名空间的切换。这段C代码我没有看懂，参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39970689/article/details/112454983">mount 内核源码_runc源码分析</a>进行了理解。</p>
<p>我们就下来再回过头来看看<code>initProcess</code>的<code>start()</code>函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libcontainer/process_linux.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *initProcess)</span></span> start() (retErr <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> p.messageSockPair.parent.Close() <span class="comment">//nolint: errcheck</span></span><br><span class="line">	err := p.cmd.Start() <span class="comment">// 开始执行 runc init  // ref-25</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向runc init 子进程发送bootstrap数据</span></span><br><span class="line">	<span class="keyword">if</span> _, err := io.Copy(p.messageSockPair.parent, p.bootstrapData); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;can&#x27;t copy bootstrap data to pipe: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">    ...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="comment">//  等待第一个子进程退出</span></span><br><span class="line">	<span class="keyword">if</span> err := p.waitForChildExit(childPid); err != <span class="literal">nil</span> &#123; <span class="comment">// ref-24</span></span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error waiting for our first child to exit: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//  设置网卡状态为up</span></span><br><span class="line">	<span class="keyword">if</span> err := p.createNetworkInterfaces(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error creating network interfaces: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//  更新当前状态到 state.json</span></span><br><span class="line">	<span class="keyword">if</span> err := p.updateSpecState(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error updating spec state: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//  向子进程runc init发送配置。子进程runc init在ref-24处已经退出了，这个其实是给子进程runc init的子进程发送数据, 也就是ref-25处start()子进程创建的子进程</span></span><br><span class="line">	<span class="keyword">if</span> err := p.sendConfig(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error sending config to init process: %w&quot;</span>, err)</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//  等待子进程发送回来的同步消息</span></span><br><span class="line">	ierr := parseSync(p.messageSockPair.parent, <span class="function"><span class="keyword">func</span><span class="params">(sync *syncT)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> sync.Type &#123;</span><br><span class="line">		<span class="keyword">case</span> procSeccomp:</span><br><span class="line">			...... <span class="comment">// 省略</span></span><br><span class="line">		<span class="keyword">case</span> procReady:</span><br><span class="line">			...... <span class="comment">// 省略</span></span><br><span class="line">		<span class="keyword">case</span> procHooks:</span><br><span class="line">			...... <span class="comment">// 省略</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> errors.New(<span class="string">&quot;invalid JSON payload from child&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">    ...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="comment">// 开始关闭自己</span></span><br><span class="line">	<span class="keyword">if</span> err := unix.Shutdown(<span class="type">int</span>(p.messageSockPair.parent.Fd()), unix.SHUT_WR); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;os.PathError&#123;Op: <span class="string">&quot;shutdown&quot;</span>, Path: <span class="string">&quot;(init pipe)&quot;</span>, Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Must be done after Shutdown so the child will exit and we can wait for it.</span></span><br><span class="line">	<span class="keyword">if</span> ierr != <span class="literal">nil</span> &#123;</span><br><span class="line">		_, _ = p.wait()</span><br><span class="line">		<span class="keyword">return</span> ierr</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了更清楚地理解目前几个进程之间的关系，按照进程出现的先后顺序，暂且将几个进程称为:</p>
<p><strong>runc:CREATE -&gt; runc:[0:PARENT] -&gt; runc:[1:CHILD] -&gt; runc:[2:INIT]</strong></p>
<p>其中，<strong>runc:[0:PARENT]</strong> clone时指定了<strong>CLONE_PARENT</strong>，后面三个进程在进程父子视图上并不是 父子关系，而是 兄弟关系。如下图所示：</p>
<p><img src="/images/runc%E4%B8%89%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="b59f16d2db630309761b51d4c6fa6b47.png"></p>
<p>下面我们通过一张图来理解<code>nsexec()</code>函数：</p>
<p><img src="/images/nsexec%E5%87%BD%E6%95%B0%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="9acc46b0cbac77817c9aa450545a37a5.png"></p>
<p>runc中实现切换新的namespace都是使用unshare()。</p>
<p>namespace切换发生在runc:[1:CHILD]。CLONE_NEWUSER首先需要单独做一次unshare()。CLONE_NEWUSER不能与CLONE_PARENT同时指定。具体细节读者可见：man 2 clone</p>
<p>runc:[1:CHILD]执行完unshare(cloneflags&amp;~CLONE_NEWGROUP),主要的namespaces已经改变了，但CLONE_NEWPID这个namespace并未发生切换，需要再次clone()。</p>
<p>一旦clone_parent(JUMP_INIT)开始执行，runc:[2:INIT]进程产生，pid namespae切换。runc:[1:CHILD]进程一只脚在容器内，一只脚在容器外；而runc:[2:INIT]是完全进入到容器的进程。</p>
<p>runc:[1:CHILD]，runc:[0:PARENT] 相继退出，runc:[2:INIT]中执行完nsexec()函数后，后续流程开始进入runc init剩下的go runtime部分。</p>
<p>当<code>nsexec()</code>函数执行完之后，就该执行<code>init.go</code>中的初始化函数了，下面我们一起看看：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libcontainer/factory_linux.go 文件</span></span><br><span class="line"><span class="comment">// StartInitialization loads a container by opening the pipe fd from the parent to read the configuration and state</span></span><br><span class="line"><span class="comment">// This is a low level implementation detail of the reexec and should not be consumed externally</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LinuxFactory)</span></span> StartInitialization() (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// Get the INITPIPE.</span></span><br><span class="line">	envInitPipe := os.Getenv(<span class="string">&quot;_LIBCONTAINER_INITPIPE&quot;</span>)</span><br><span class="line">	pipefd, err := strconv.Atoi(envInitPipe)</span><br><span class="line">	pipe := os.NewFile(<span class="type">uintptr</span>(pipefd), <span class="string">&quot;pipe&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> pipe.Close()</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="comment">// Only init processes have FIFOFD.</span></span><br><span class="line">	fifofd := <span class="number">-1</span></span><br><span class="line">	envInitType := os.Getenv(<span class="string">&quot;_LIBCONTAINER_INITTYPE&quot;</span>)</span><br><span class="line">	it := initType(envInitType)</span><br><span class="line">	<span class="keyword">if</span> it == initStandard &#123;</span><br><span class="line">		envFifoFd := os.Getenv(<span class="string">&quot;_LIBCONTAINER_FIFOFD&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> fifofd, err = strconv.Atoi(envFifoFd); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to convert _LIBCONTAINER_FIFOFD: %w&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="comment">// Get mount files (O_PATH).</span></span><br><span class="line">	mountFds, err := parseMountFds()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// clear the current process&#x27;s environment to clean any libcontainer</span></span><br><span class="line">	<span class="comment">// specific env vars.</span></span><br><span class="line">	os.Clearenv()</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">    <span class="comment">// 创建容器初始化器</span></span><br><span class="line">	i, err := newContainerInit(it, pipe, consoleSocket, fifofd, logPipeFd, mountFds) <span class="comment">// ref-26</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If Init succeeds, syscall.Exec will not return, hence none of the defers will be called.</span></span><br><span class="line">	<span class="keyword">return</span> i.Init() <span class="comment">// ref-27</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来最后来看看容器初始化器做了什么？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libcontainer/standard_init_linux.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *linuxStandardInit)</span></span> Init() <span class="type">error</span> &#123; <span class="comment">// 这个函数在子进程runc init的子进程中执行。</span></span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">    <span class="comment">// 设置网卡为up</span></span><br><span class="line">	<span class="keyword">if</span> err := setupNetwork(l.config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 设置路由表</span></span><br><span class="line">	<span class="keyword">if</span> err := setupRoute(l.config.Config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// initialises the labeling system</span></span><br><span class="line">	selinux.GetEnabled()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We don&#x27;t need the mountFds after prepareRootfs() nor if it fails.</span></span><br><span class="line">    <span class="comment">// 准备rootfs</span></span><br><span class="line">	err := prepareRootfs(l.pipe, l.config, l.mountFds)</span><br><span class="line">	<span class="keyword">for</span> _, m := <span class="keyword">range</span> l.mountFds &#123;</span><br><span class="line">		<span class="keyword">if</span> m == <span class="number">-1</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err := unix.Close(m); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;Unable to close mountFds fds: %w&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="comment">// Tell our parent that we&#x27;re ready to Execv. This must be done before the</span></span><br><span class="line">	<span class="comment">// Seccomp rules have been applied, because we need to be able to read and</span></span><br><span class="line">	<span class="comment">// write to a socket.</span></span><br><span class="line">    <span class="comment">// 告诉父进程，现在已经都准备好了，父进程(parentProcess)收到消息后就会退出</span></span><br><span class="line">	<span class="keyword">if</span> err := syncParentReady(l.pipe); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;sync ready: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">		...... <span class="comment">// 省略</span></span><br><span class="line">	<span class="comment">// Wait for the FIFO to be opened on the other side before exec-ing the</span></span><br><span class="line">	<span class="comment">// user process. We open it through /proc/self/fd/$fd, because the fd that</span></span><br><span class="line">	<span class="comment">// was given to us was an O_PATH fd to the fifo itself. Linux allows us to</span></span><br><span class="line">	<span class="comment">// re-open an O_PATH fd through /proc.</span></span><br><span class="line">	fifoPath := <span class="string">&quot;/proc/self/fd/&quot;</span> + strconv.Itoa(l.fifoFd)</span><br><span class="line">    <span class="comment">// 这个open方法会导致阻塞，直到另外一端也打开</span></span><br><span class="line">	fd, err := unix.Open(fifoPath, unix.O_WRONLY|unix.O_CLOEXEC, <span class="number">0</span>) <span class="comment">// ref-27</span></span><br><span class="line">    <span class="comment">// 阻塞结束后，就真正的执行用户指定的容器中执行的命令了</span></span><br><span class="line">	<span class="comment">// 告诉父进程现在开始启动用户给容器指定的命令。</span></span><br><span class="line">	<span class="keyword">if</span> _, err := unix.Write(fd, []<span class="type">byte</span>(<span class="string">&quot;0&quot;</span>)); err != <span class="literal">nil</span> &#123; <span class="comment">// ref-28</span></span><br><span class="line">		<span class="keyword">return</span> &amp;os.PathError&#123;Op: <span class="string">&quot;write exec fifo&quot;</span>, Path: fifoPath, Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Close the O_PATH fifofd fd before exec because the kernel resets</span></span><br><span class="line">	<span class="comment">// dumpable in the wrong order. This has been fixed in newer kernels, but</span></span><br><span class="line">	<span class="comment">// we keep this to ensure CVE-2016-9962 doesn&#x27;t re-emerge on older kernels.</span></span><br><span class="line">	<span class="comment">// N.B. the core issue itself (passing dirfds to the host filesystem) has</span></span><br><span class="line">	<span class="comment">// since been resolved.</span></span><br><span class="line">	<span class="comment">// https://github.com/torvalds/linux/blob/v4.9/fs/exec.c#L1290-L1318</span></span><br><span class="line">	_ = unix.Close(l.fifoFd)</span><br><span class="line"></span><br><span class="line">	s := l.config.SpecState</span><br><span class="line">	s.Pid = unix.Getpid()</span><br><span class="line">	s.Status = specs.StateCreated</span><br><span class="line">	<span class="keyword">if</span> err := l.config.Config.Hooks[configs.StartContainer].RunHooks(s); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 使用系统调用执行用户指定的容器要执行的命令，伴随着的还有子进程runc init的子进程也就退出了。</span></span><br><span class="line">	<span class="keyword">return</span> system.Exec(name, l.config.Args[<span class="number">0</span>:], os.Environ())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、容器启动分析"><a href="#三、容器启动分析" class="headerlink" title="三、容器启动分析"></a>三、容器启动分析</h2><p>上面已经分析到<code>runc create</code>命令最后一步就是在等待一个消息，然后就开启用户指定的容器命令了。这个消息就是<code>runc start</code>发出的。接下来我们具体看看。</p>
<p>首先看看<code>runc start</code>命令的执行函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start.go文件</span></span><br><span class="line"><span class="keyword">var</span> startCommand = cli.Command&#123;</span><br><span class="line">	Name:  <span class="string">&quot;start&quot;</span>,</span><br><span class="line">	Usage: <span class="string">&quot;executes the user defined process in a created container&quot;</span>,</span><br><span class="line">	ArgsUsage: <span class="string">`&lt;container-id&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Where &quot;&lt;container-id&gt;&quot; is your name for the instance of the container that you</span></span><br><span class="line"><span class="string">are starting. The name you provide for the container instance must be unique on</span></span><br><span class="line"><span class="string">your host.`</span>,</span><br><span class="line">	Description: <span class="string">`The start command executes the user defined process in a created container.`</span>,</span><br><span class="line">	Action: <span class="function"><span class="keyword">func</span><span class="params">(context *cli.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := checkArgs(context, <span class="number">1</span>, exactArgs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		container, err := getContainer(context)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		status, err := container.Status()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> status &#123;</span><br><span class="line">		<span class="keyword">case</span> libcontainer.Created: <span class="comment">// ref-29</span></span><br><span class="line">            <span class="comment">// ref-30</span></span><br><span class="line">			notifySocket, err := notifySocketStart(context, os.Getenv(<span class="string">&quot;NOTIFY_SOCKET&quot;</span>), container.ID())</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err := container.Exec(); err != <span class="literal">nil</span> &#123; <span class="comment">// ref-31</span></span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> notifySocket != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// ref-32</span></span><br><span class="line">				<span class="keyword">return</span> notifySocket.waitForContainer(container)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> libcontainer.Stopped:</span><br><span class="line">			<span class="keyword">return</span> errors.New(<span class="string">&quot;cannot start a container that has stopped&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> libcontainer.Running:</span><br><span class="line">			<span class="keyword">return</span> errors.New(<span class="string">&quot;cannot start an already running container&quot;</span>)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;cannot start a container in the %s state&quot;</span>, status)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ref-29</code>处在判断容器的当前状态，<code>ref-31</code>的<code>container.Exec()</code>，我们来看看里面具体干了啥：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libcontainer/container_linux.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *linuxContainer)</span></span> exec() <span class="type">error</span> &#123; <span class="comment">// linux container 执行start任务的具体函数</span></span><br><span class="line">	path := filepath.Join(c.root, execFifoFilename) <span class="comment">// 获取用于子进程通信的文件路径</span></span><br><span class="line">	pid := c.initProcess.pid()</span><br><span class="line">    blockingFifoOpenCh := awaitFifoOpen(path) <span class="comment">// 打开文件，子进程(runc init的子进程)阻塞结束</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> result := &lt;-blockingFifoOpenCh: <span class="comment">// 收到子进程发送过来的数据</span></span><br><span class="line">			<span class="keyword">return</span> handleFifoResult(result) <span class="comment">// ref-32 读取数据就返回了，这儿就真的只是读取数据，啥也没干</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(time.Millisecond * <span class="number">100</span>): <span class="comment">// 超时控制</span></span><br><span class="line">			stat, err := system.Stat(pid)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> || stat.State == system.Zombie &#123;</span><br><span class="line">				<span class="comment">// could be because process started, ran, and completed between our 100ms timeout and our system.Stat() check.</span></span><br><span class="line">				<span class="comment">// see if the fifo exists and has data (with a non-blocking open, which will succeed if the writing process is complete).</span></span><br><span class="line">				<span class="keyword">if</span> err := handleFifoResult(fifoOpen(path, <span class="literal">false</span>)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> errors.New(<span class="string">&quot;container process is already dead&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们最后来看看<code>ref-32</code>的数据读取都做了什么操作？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libcontainer/container_linux.go 文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleFifoResult</span><span class="params">(result openResult)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> result.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> result.err</span><br><span class="line">	&#125;</span><br><span class="line">	f := result.file</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	<span class="keyword">if</span> err := readFromExecFifo(f); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> os.Remove(f.Name())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就是读取了一下文件管道中的数据，然后真的就啥也没干！</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFromExecFifo</span><span class="params">(execFifo io.Reader)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	data, err := io.ReadAll(execFifo)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(data) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;cannot start an already running container&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>到这儿，docker 容器进程启动分析就结束了。可以看到runc要想把容器中用户指定的命令进程完全与宿主机隔离，还是非常曲折的。</p>
<p>参考资料：</p>
<p>1、<a target="_blank" rel="noopener" href="https://mkdev.me/posts/the-tool-that-really-runs-your-containers-deep-dive-into-runc-and-oci-specifications">https://mkdev.me/posts/the-tool-that-really-runs-your-containers-deep-dive-into-runc-and-oci-specifications</a></p>
<p>2、runc仓库地址：<a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc">https://github.com/opencontainers/runc</a></p>
<p>3、mount 内核源码_runc源码分析：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39970689/article/details/112454983">https://blog.csdn.net/weixin_39970689/article/details/112454983</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/runc/" rel="tag"># runc</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/07/31/Docker%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/" rel="prev" title="Docker容器创建过程解析">
                  <i class="fa fa-chevron-left"></i> Docker容器创建过程解析
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/08/17/Java%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E5%90%84%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/" rel="next" title="Java远程调试各参数说明">
                  Java远程调试各参数说明 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">钟镇刚</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">145k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:12</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
